LU-12550 ldlm: contention detection

************************************************
NOT READY FOR REVIEW
ONLY REBASE..D
************************************************

This patch rewrites the contention detection code in LDLM.
The existing contention detection code does not detection
contention in most scenarios, because it ignores locks
which do not have overlapping requests. (See LU ticket for
detailed discussion)

This patch replaces the server side contention detection
code with a version which takes into account all lock
contention, by counting each lock request that conflicts
with an existing lock.  If enough conflicting requests are
seen within a certain time (both tunable), contention is
reported to the client.

Each lock request only contributes to contention
detection once - This is so we do not report contention
when one lock request cancels many existing locks, which
happens if a file with many read locks is written to. A
one time event like this is not contention.

Contention reporting to the client is also changed.  The
existing way of reporting contention is returning -EUSERS,
which tells the client to use lockless i/o.

However, lockless i/o is badly broken, going back many
versions.  Fixing it is challenging, and interoperability
concerns mean we will need to limit -EUSERS to clients with
fixed lockless i/o.

Because it is not always desirable to refuse lock requests
and future lockless I/O designs may be different, this
patch avoids the existing behavior and instead sets an LDLM
flag on the lock, informing the client of contention.  This
allows the *client* to decide what to do.

This patch disables the lockless I/O tests (which fail in
some configs already), rather than removing them, as there
is some movement towards fixing lockless I/O.  Note that
the contention detection in this patch should also be
usable for future lockless I/O implementations.

This is intended to be used with client side I/O pattern
detection to allow clients to pick which optimizations they
want to use.

We use Sliding Window Counter algorithm to calculate the
contention degree and determine whether the lock resource is
under lock contention.
It uses a rolling window of time to smooth burst.
It can smooth out spikes in the lock traffic because the rate
is based on the average rate of the previous window.

Signed-off-by: Patrick Farrell <pfarrell@whamcloud.com>
Signed-off-by: Qian Yingjin <qian@ddn.com>
Signed-off-by: squalfof <squalfof@gmail.com>
Change-Id: Ib6f3e1c16c952d5652fa4bae2bb1255b65554347
