From 0de5e2437d3f4e45f9f7fd64436dfd294a5ebb2f Mon Sep 17 00:00:00 2001
From: Vitaliy Kuznetsov <vkuznetsov@ddn.com>
Date: Fri, 3 Oct 2025 00:36:21 +0200
Subject: [PATCH 1/1] LU-16554 tgt: Specify exact size for packet in out_handle

Out update request always lists reply size minimum as 4K in
out_update_header (lustre/osp/osp_trans.c::osp_prep_update_req())

Out update reply blindly uses this size to create the pack size,
not actually checking the size of the packed reply.
(lustre/target/out_handler.c::out_handle())

If the former behavior is changed, than the later behavior will
break. Currently there's a 4K buffer to hold ~100B of data.

This patch fix changes the size for generating the response
packet size to be more accurate.

Signed-off-by: Vitaliy Kuznetsov <vkuznetsov@ddn.com>
Change-Id: I9d195a2f646ae6e2a838cb15c4a543ba109da232
---
 lustre/include/lustre_update.h |  2 +-
 lustre/include/obj_update.h    |  3 ++-
 lustre/osp/osp_md_object.c     | 15 ++++++---------
 lustre/osp/osp_object.c        | 15 ++++++---------
 lustre/osp/osp_trans.c         | 28 +++++++++++++++++-----------
 lustre/ptlrpc/batch.c          | 26 ++++++++++++++++++++++----
 lustre/target/out_handler.c    | 13 +++++++------
 7 files changed, 61 insertions(+), 41 deletions(-)

diff --git a/lustre/include/lustre_update.h b/lustre/include/lustre_update.h
index 798f672ec6..d238c76456 100644
--- a/lustre/include/lustre_update.h
+++ b/lustre/include/lustre_update.h
@@ -258,7 +258,7 @@ object_update_result_data_get(const struct object_update_reply *reply,
 	LASSERT(lbuf != NULL);
 	update_result = object_update_result_get(reply, index, &size);
 	if (update_result == NULL ||
-	    size < round_up(sizeof(struct object_update_reply), 8) ||
+	    size < round_up(sizeof(struct object_update_result), 8) ||
 	    update_result->our_datalen > size)
 		RETURN(-EFAULT);
 
diff --git a/lustre/include/obj_update.h b/lustre/include/obj_update.h
index 3081a0c961..db2a1e0639 100644
--- a/lustre/include/obj_update.h
+++ b/lustre/include/obj_update.h
@@ -79,7 +79,8 @@ object_update_result_get(const struct object_update_reply *reply,
 	unsigned int i;
 	void *ptr;
 
-	if (index >= count)
+	/* For empty replies (count=0), there are no results to return */
+	if (index >= count || count == 0)
 		return NULL;
 
 	ptr = (char *)reply +
diff --git a/lustre/osp/osp_md_object.c b/lustre/osp/osp_md_object.c
index 975249d498..ff0108d7d5 100644
--- a/lustre/osp/osp_md_object.c
+++ b/lustre/osp/osp_md_object.c
@@ -491,9 +491,8 @@ static int osp_md_index_lookup(const struct lu_env *env, struct dt_object *dt,
 	if (rc < 0)
 		GOTO(out, rc);
 
-	reply = req_capsule_server_sized_get(&req->rq_pill,
-					     &RMF_OUT_UPDATE_REPLY,
-					     OUT_UPDATE_REPLY_SIZE);
+	reply = req_capsule_server_get(&req->rq_pill,
+				       &RMF_OUT_UPDATE_REPLY);
 	if (reply->ourp_magic != UPDATE_REPLY_MAGIC) {
 		CERROR("%s: Wrong version %x expected %x: rc = %d\n",
 		       dt_dev->dd_lu_dev.ld_obd->obd_name,
@@ -867,9 +866,8 @@ static int osp_md_xattr_list(const struct lu_env *env, struct dt_object *dt,
 		GOTO(out, rc);
 	}
 
-	reply = req_capsule_server_sized_get(&req->rq_pill,
-					     &RMF_OUT_UPDATE_REPLY,
-					     OUT_UPDATE_REPLY_SIZE);
+	reply = req_capsule_server_get(&req->rq_pill,
+				       &RMF_OUT_UPDATE_REPLY);
 	if (reply->ourp_magic != UPDATE_REPLY_MAGIC) {
 		DEBUG_REQ(D_ERROR, req,
 			  "%s: Wrong version %x expected %x "DFID": rc = %d",
@@ -1337,9 +1335,8 @@ static ssize_t osp_md_read(const struct lu_env *env, struct dt_object *dt,
 	if (rc < 0)
 		GOTO(out, rc);
 
-	reply = req_capsule_server_sized_get(&req->rq_pill,
-					     &RMF_OUT_UPDATE_REPLY,
-					     OUT_UPDATE_REPLY_SIZE);
+	reply = req_capsule_server_get(&req->rq_pill,
+				       &RMF_OUT_UPDATE_REPLY);
 
 	if (reply->ourp_magic != UPDATE_REPLY_MAGIC) {
 		CERROR("%s: invalid update reply magic %x expected %x:"
diff --git a/lustre/osp/osp_object.c b/lustre/osp/osp_object.c
index d01e6fed76..0c12d00967 100644
--- a/lustre/osp/osp_object.c
+++ b/lustre/osp/osp_object.c
@@ -622,9 +622,8 @@ int osp_attr_get(const struct lu_env *env, struct dt_object *dt,
 
 	osp2lu_obj(obj)->lo_header->loh_attr |= LOHA_EXISTS;
 	obj->opo_non_exist = 0;
-	reply = req_capsule_server_sized_get(&req->rq_pill,
-					     &RMF_OUT_UPDATE_REPLY,
-					     OUT_UPDATE_REPLY_SIZE);
+	reply = req_capsule_server_get(&req->rq_pill,
+				       &RMF_OUT_UPDATE_REPLY);
 	if (reply == NULL || reply->ourp_magic != UPDATE_REPLY_MAGIC)
 		GOTO(out, rc = -EPROTO);
 
@@ -1060,9 +1059,8 @@ unlock:
 				dt->do_lu.lo_header->loh_attr &= ~LOHA_EXISTS;
 			GOTO(out, rc);
 		}
-		reply = req_capsule_server_sized_get(&req->rq_pill,
-						     &RMF_OUT_UPDATE_REPLY,
-				OUT_UPDATE_REPLY_SIZE);
+		reply = req_capsule_server_get(&req->rq_pill,
+					       &RMF_OUT_UPDATE_REPLY);
 		if (reply->ourp_magic != UPDATE_REPLY_MAGIC) {
 			CERROR("%s: Wrong version %x expected %x "DFID
 			       ": rc = %d\n", dname, reply->ourp_magic,
@@ -1103,9 +1101,8 @@ unlock:
 		GOTO(out, rc);
 	}
 
-	reply = req_capsule_server_sized_get(&req->rq_pill,
-					     &RMF_OUT_UPDATE_REPLY,
-					     OUT_UPDATE_REPLY_SIZE);
+	reply = req_capsule_server_get(&req->rq_pill,
+				       &RMF_OUT_UPDATE_REPLY);
 	if (reply->ourp_magic != UPDATE_REPLY_MAGIC) {
 		CERROR("%s: Wrong version %x expected %x "DFID": rc = %d\n",
 		       dname, reply->ourp_magic, UPDATE_REPLY_MAGIC,
diff --git a/lustre/osp/osp_trans.c b/lustre/osp/osp_trans.c
index c5ee41c830..6da67e8a04 100644
--- a/lustre/osp/osp_trans.c
+++ b/lustre/osp/osp_trans.c
@@ -328,9 +328,10 @@ int osp_prep_update_req(const struct lu_env *env, struct obd_import *imp,
 	__u32				buf_count = 0;
 	int				page_count = 0;
 	int				repsize = 0;
-	struct object_update_reply	*reply;
 	int				rc, i;
 	int				total = 0;
+	unsigned int			updates = 0;
+	int				min_reply;
 	ENTRY;
 
 	list_for_each_entry(ours, &our->our_req_list, ours_list) {
@@ -341,23 +342,29 @@ int osp_prep_update_req(const struct lu_env *env, struct obd_import *imp,
 			struct object_update	*update;
 			size_t			size = 0;
 
-
 			/* XXX: it's very inefficient to lookup update
 			 *	this way, iterating from the beginning
 			 *	each time */
 			update = object_update_request_get(ourq, i, &size);
 			LASSERT(update != NULL);
 
-			repsize += sizeof(reply->ourp_lens[0]);
-			repsize += sizeof(struct object_update_result);
-			repsize += update->ou_result_size;
+			updates++;
+			repsize +=
+				round_up(sizeof(struct object_update_result) +
+					 update->ou_result_size, 8);
 		}
 
 		buf_count++;
 	}
-	repsize += sizeof(*reply);
-	if (repsize < OUT_UPDATE_REPLY_SIZE)
-		repsize = OUT_UPDATE_REPLY_SIZE;
+
+	repsize = round_up(offsetof(struct object_update_reply,
+				    ourp_lens[updates]), 8) + repsize;
+
+	min_reply = round_up(offsetof(struct object_update_reply,
+				      ourp_lens[0]), 8);
+	if (repsize < min_reply)
+		repsize = min_reply;
+
 	LASSERT(buf_count > 0);
 
 	req = ptlrpc_request_alloc(imp, &RQF_OUT_UPDATE);
@@ -633,9 +640,8 @@ static int osp_update_interpret(const struct lu_env *env,
 
 	/* Unpack the results from the reply message. */
 	if (req->rq_repmsg != NULL && req->rq_replied) {
-		reply = req_capsule_server_sized_get(&req->rq_pill,
-						     &RMF_OUT_UPDATE_REPLY,
-						     OUT_UPDATE_REPLY_SIZE);
+		reply = req_capsule_server_get(&req->rq_pill,
+					       &RMF_OUT_UPDATE_REPLY);
 		if (reply == NULL || reply->ourp_magic != UPDATE_REPLY_MAGIC) {
 			if (rc == 0)
 				rc = -EPROTO;
diff --git a/lustre/ptlrpc/batch.c b/lustre/ptlrpc/batch.c
index 15bed34460..f8bb447879 100644
--- a/lustre/ptlrpc/batch.c
+++ b/lustre/ptlrpc/batch.c
@@ -119,9 +119,14 @@ static int batch_prep_update_req(struct batch_update_head *head,
 	int rc;
 
 	ENTRY;
-	repsize += round_up(offsetof(struct batch_update_reply, burp_repmsg[0]), 8);
-	if (repsize < OUT_UPDATE_REPLY_SIZE)
-		repsize = OUT_UPDATE_REPLY_SIZE;
+	repsize += round_up(offsetof(struct batch_update_reply,
+				     burp_repmsg[0]), 8);
+	if (repsize <
+	    round_up(offsetof(struct batch_update_reply, burp_repmsg[0]), 8) +
+	    lustre_msg_early_size)
+		repsize = round_up(offsetof(struct batch_update_reply,
+					    burp_repmsg[0]), 8) +
+			  lustre_msg_early_size;
 
 	LASSERT(head->buh_buf_count > 0);
 
@@ -553,9 +558,12 @@ static void cli_batch_resend_work(struct work_struct *data)
 	struct batch_update_head *head;
 	struct batch_update_buffer *buf;
 	struct batch_update_buffer *tmp;
+	struct lustre_msg *repmsg = NULL;
+	int sum = 0;
 	int index = work->bwr_index;
 	int rc = 0;
 	int i = 0;
+	int k;
 
 	ENTRY;
 
@@ -622,7 +630,17 @@ repeat:
 	list_for_each_entry(ouc, &head->buh_cb_list, ouc_item)
 		ouc->ouc_head = head;
 
-	head->buh_repsize = BUT_MAXREPSIZE - SPTLRPC_MAX_PAYLOAD;
+	list_for_each_entry(buf, &head->buh_buf_list, bub_item) {
+		struct batch_update_request *bur = buf->bub_req;
+
+		for (k = 0, repmsg = NULL; k < bur->burq_count; k++) {
+			repmsg = batch_update_reqmsg_next(bur, repmsg);
+			/* lm_repsize is the packed reply message size */
+			sum += repmsg->lm_repsize;
+		}
+	}
+
+	head->buh_repsize = sum;
 	rc = batch_send_update_req(NULL, head);
 	if (rc)
 		GOTO(err_up, rc);
diff --git a/lustre/target/out_handler.c b/lustre/target/out_handler.c
index f8576cf24a..de61e5cf74 100644
--- a/lustre/target/out_handler.c
+++ b/lustre/target/out_handler.c
@@ -1057,12 +1057,14 @@ int out_handle(struct tgt_session_info *tsi)
 
 			/* XXX: what ou_result_size can be considered safe? */
 
-			reply_size += sizeof(reply->ourp_lens[0]);
-			reply_size += sizeof(struct object_update_result);
-			reply_size += update->ou_result_size;
+			reply_size +=
+				round_up(sizeof(struct object_update_result) +
+					 update->ou_result_size, 8);
 		}
  	}
-	reply_size += sizeof(*reply);
+	/* header (reply + lens[updates]) aligned to 8 bytes plus results */
+	reply_size = round_up(offsetof(struct object_update_reply,
+				       ourp_lens[updates]), 8) + reply_size;
 
 	if (unlikely(reply_size > ouh->ouh_reply_size)) {
 		CERROR("%s: too small reply buf %u for %u, need %u at least\n",
@@ -1072,7 +1074,7 @@ int out_handle(struct tgt_session_info *tsi)
 	}
 
 	req_capsule_set_size(pill, &RMF_OUT_UPDATE_REPLY, RCL_SERVER,
-			     ouh->ouh_reply_size);
+			     reply_size);
 	rc = req_capsule_server_pack(pill);
 	if (rc != 0) {
 		CERROR("%s: Can't pack response: rc = %d\n",
@@ -1247,4 +1249,3 @@ struct tgt_handler tgt_out_handlers[] = {
 TGT_UPDATE_HDL(IS_MUTABLE,	OUT_UPDATE,	out_handle),
 };
 EXPORT_SYMBOL(tgt_out_handlers);
-
