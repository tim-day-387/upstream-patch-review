From 8ac14b92a0c5c22590a07070d4e022461b09671b Mon Sep 17 00:00:00 2001
From: Sohei Koyama <skoyama@ddn.com>
Date: Wed, 19 Feb 2025 13:44:38 +0900
Subject: [PATCH 1/1] LU-18725 utils: create ll_decode_lov

Like ll_decode_linkea, create ll_decode_lov.
This allows us to directly scan the MDT for information that can
be obtained with lfs getstripe.

Signed-off-by: Sohei Koyama <skoyama@ddn.com>
Change-Id: I50fcb0be067a4cda80aea19fa4b64b8ccf3a9667
---
 lustre/doc/Makefile.am            |  1 +
 lustre/doc/ll_decode_lov.8        | 58 ++++++++++++++++++++++
 lustre/tests/sanity.sh            | 10 ++++
 lustre/tests/test-framework.sh    |  3 ++
 lustre/utils/Makefile.am          |  6 ++-
 lustre/utils/liblustreapi.c       | 63 ++++++++++++++++++++----
 lustre/utils/ll_decode_lov.c      | 82 +++++++++++++++++++++++++++++++
 lustre/utils/lustreapi_internal.h | 13 +++++
 8 files changed, 225 insertions(+), 11 deletions(-)
 create mode 100644 lustre/doc/ll_decode_lov.8
 create mode 100644 lustre/utils/ll_decode_lov.c

diff --git a/lustre/doc/Makefile.am b/lustre/doc/Makefile.am
index 3de9f5f38f..8505d74f0b 100644
--- a/lustre/doc/Makefile.am
+++ b/lustre/doc/Makefile.am
@@ -28,6 +28,7 @@ MANFILES =					\
 	lgss_sk.8				\
 	lhbadm.8				\
 	ll_decode_linkea.8			\
+	ll_decode_lov.8				\
 	llsom_sync.8				\
 	llstat.8				\
 	lustre_routes_config.8			\
diff --git a/lustre/doc/ll_decode_lov.8 b/lustre/doc/ll_decode_lov.8
new file mode 100644
index 0000000000..675e8c75a0
--- /dev/null
+++ b/lustre/doc/ll_decode_lov.8
@@ -0,0 +1,58 @@
+.TH LL_DECODE_LOV 8 2025-02-19 Lustre "Lustre Configuration Utilities"
+.SH NAME
+ll_decode_lov - decode and print layout information of a Lustre file
+
+.SH SYNOPSIS
+.SY ll_decode_lov
+.RB [ -y | --yaml ]
+.RB [ -x | --hex ]
+.RB [ -h | --help ]
+.I FILE
+.RI [ FILE ...]
+.YS
+
+.SH DESCRIPTION
+.B ll_decode_lov
+decodes and prints the Lustre layout information stored in the "trusted.lov"
+extended attribute of a given file or directory. This information includes
+the layout magic number, pool name, and object storage targets (OSTs)
+associated with the file. This provides functionality similar to
+.BR lfs (1)
+.BR getstripe ,
+but outputs the raw on-disk layout information for debugging and analysis.
+
+.PP
+The layout information is useful for debugging and analyzing the file distribution across OSTs in Lustre.
+
+.SH OPTIONS
+.TP
+.BR -y ", " --yaml
+Output in YAML format for better readability.
+.TP
+.BR -x ", " --hex
+Display OST indices in hexadecimal format.
+.TP
+.BR -h ", " --help
+Show usage information.
+
+.SH EXAMPLES
+.EX
+.B root@mdt1# ll_decode_lov /mnt/ldiskfs/ROOT/file_0000.txt
+lmm_stripe_count:  1
+lmm_stripe_size:   1048576
+lmm_pattern:       raid0
+lmm_layout_gen:    0
+lmm_stripe_offset: 0
+	obdidx		 objid		 objid		 group
+	     0	             2	          0x2	   0x240000400
+.EE
+
+.SH AVAILABILITY
+.B ll_decode_lov
+is part of the
+.BR lustre (7)
+filesystem package.
+
+.SH SEE ALSO
+.BR lfs (1),
+.BR lustre (7)
\ No newline at end of file
diff --git a/lustre/tests/sanity.sh b/lustre/tests/sanity.sh
index a6e1b0ff52..051fac7142 100755
--- a/lustre/tests/sanity.sh
+++ b/lustre/tests/sanity.sh
@@ -19157,6 +19157,16 @@ test_154C() {
 }
 run_test 154C "lfs fid2path on OST FID"
 
+test_154D() {
+	mkdir -p $DIR/$tdir || error "mkdir $tdir failed"
+	touch $DIR/$tdir/$tfile || error "touch $DIR/$tdir/$tfile failed"
+	local lov=$($LL_DECODE_LOV $DIR/$tdir/$tfile | grep 'lmm_stripe_count')
+	[[ -n "$lov" ]] || error "decode lov $DIR/$tdir/$tfile failed"
+
+	rm -rf $DIR/$tdir || error "Can not delete directory $DIR/$tdir"
+}
+run_test 154D "verify the ll_decode_lov tool"
+
 test_154a() {
 	[ $PARALLEL == "yes" ] && skip "skip parallel run"
 	[ -n "$FILESET" ] && skip "SKIP due to FILESET set"
diff --git a/lustre/tests/test-framework.sh b/lustre/tests/test-framework.sh
index 91fa67f589..fccf5155f8 100755
--- a/lustre/tests/test-framework.sh
+++ b/lustre/tests/test-framework.sh
@@ -577,6 +577,9 @@ init_test_env() {
 	export LL_DECODE_LINKEA=${LL_DECODE_LINKEA:-"$LUSTRE/utils/ll_decode_linkea"}
 	[ ! -f "$LL_DECODE_LINKEA" ] &&
 		export LL_DECODE_LINKEA="ll_decode_linkea"
+	export LL_DECODE_LOV=${LL_DECODE_LOV:-"$LUSTRE/utils/ll_decode_lov"}
+	[ ! -f "$LL_DECODE_LOV" ] &&
+		export LL_DECODE_LOV="ll_decode_lov"
 	export MKFS=${MKFS:-"$LUSTRE/utils/mkfs.lustre"}
 	[ ! -f "$MKFS" ] && export MKFS="mkfs.lustre"
 	export TUNEFS=${TUNEFS:-"$LUSTRE/utils/tunefs.lustre"}
diff --git a/lustre/utils/Makefile.am b/lustre/utils/Makefile.am
index 0c9a3e0ee7..da881a6a98 100644
--- a/lustre/utils/Makefile.am
+++ b/lustre/utils/Makefile.am
@@ -28,7 +28,7 @@ bin_SCRIPTS   = llstat llobdstat lljobstat plot-llstat
 bin_PROGRAMS  = lfs
 sbin_SCRIPTS  = ldlm_debug_upcall
 sbin_PROGRAMS = lctl l_getidentity llverdev llverfs lustre_rsync \
-		ll_decode_linkea llsom_sync l_foreign_symlink
+		ll_decode_linkea llsom_sync l_foreign_symlink ll_decode_lov
 
 if TESTS
 sbin_PROGRAMS += wirecheck wiretest
@@ -79,6 +79,10 @@ lustre_rsync_SOURCES = lustre_rsync.c lustre_rsync.h callvpe.c callvpe.h
 lustre_rsync_LDADD :=  liblustreapi.la $(PTHREAD_LIBS)
 lustre_rsync_DEPENDENCIES := liblustreapi.la
 
+ll_decode_lov_SOURCES = ll_decode_lov.c
+ll_decode_lov_LDADD := liblustreapi.la
+ll_decode_lov_DEPENDENCIES := liblustreapi.la
+
 llsom_sync_LDADD := liblustreapi.la
 llsom_sync_DEPENDENCIES := liblustreapi.la
 
diff --git a/lustre/utils/liblustreapi.c b/lustre/utils/liblustreapi.c
index 0fc026a296..7676de8c9d 100644
--- a/lustre/utils/liblustreapi.c
+++ b/lustre/utils/liblustreapi.c
@@ -2566,16 +2566,6 @@ int sattr_cache_get_defaults(const char *const fsname,
 	return 0;
 }
 
-enum lov_dump_flags {
-	LDF_IS_DIR	= 0x0001,
-	LDF_IS_RAW	= 0x0002,
-	LDF_INDENT	= 0x0004,
-	LDF_SKIP_OBJS	= 0x0008,
-	LDF_YAML	= 0x0010,
-	LDF_EXTENSION	= 0x0020,
-	LDF_HEX_IDX	= 0x0040,
-};
-
 static void lov_dump_user_lmm_header(struct lov_user_md *lum, char *path,
 				     struct lov_user_ost_data_v1 *objects,
 				     enum llapi_layout_verbose verbose,
@@ -7204,3 +7194,56 @@ int llapi_fsync(int fd)
 
 	return llapi_get_data_version(fd, &dv, LL_DV_RD_FLUSH);
 }
+
+#define DECODE_BUFFER_SIZE 65536
+
+int llapi_decode_lov(char *path,
+	enum llapi_layout_verbose verbose, enum lov_dump_flags flags)
+{
+	char buf[DECODE_BUFFER_SIZE];
+	struct lov_user_md *lum = NULL;
+	ssize_t size;
+	struct lov_user_ost_data_v1 *objects = NULL;
+	char pool_name[LOV_MAXPOOLNAME + 1];
+	int obdindex = OBD_NOT_FOUND;
+	bool is_dir = flags & LDF_IS_DIR;
+	bool skip_objs = flags & LDF_SKIP_OBJS;
+
+	size = getxattr(path, "trusted.lov", buf, DECODE_BUFFER_SIZE);
+	if (size < 0) {
+		if (errno == ERANGE) {
+			llapi_error(LLAPI_MSG_ERROR, errno,
+				"%s: the buffer size %u might be too small\n",
+				path, DECODE_BUFFER_SIZE);
+		} else {
+			llapi_error(LLAPI_MSG_ERROR, errno,
+				"%s: failed to read trusted.lov xattr: %s\n",
+				path, strerror(errno));
+		}
+		return -1;
+	}
+
+	lum = (struct lov_user_md *)buf;
+
+	if (lum->lmm_magic == __swab32(LOV_MAGIC_V1))
+		lum->lmm_magic = LOV_MAGIC_V1;
+	if (lum->lmm_magic == __swab32(LOV_MAGIC_V3))
+		lum->lmm_magic = LOV_MAGIC_V3;
+	if (lum->lmm_magic != LOV_MAGIC_V1 &&
+	    lum->lmm_magic != LOV_MAGIC_V3) {
+		llapi_error(LLAPI_MSG_ERROR, EINVAL,
+			"%s: magic mismatch, expected 0x%x or 0x%x, got 0x%x\n",
+			path, LOV_MAGIC_V1, LOV_MAGIC_V3,
+			lum->lmm_magic);
+		return -1;
+	}
+
+	if (!is_dir && !skip_objs)
+		objects = lov_v1v3_objects(lum);
+	lov_v1v3_pool_name(lum, pool_name);
+
+	lov_dump_user_lmm_v1v3(lum, pool_name, objects, path,
+		obdindex, 0, verbose, flags);
+
+	return 0;
+}
diff --git a/lustre/utils/ll_decode_lov.c b/lustre/utils/ll_decode_lov.c
new file mode 100644
index 0000000000..8d2076a915
--- /dev/null
+++ b/lustre/utils/ll_decode_lov.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * Copyright (c) 2025, DataDirect Networks.
+ *
+ * Tool for printing the LOV structure on the objects
+ * in human readable form.
+ *
+ * Author: Sohei Koyama <skoyama@ddn.com>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+
+#include "lustreapi_internal.h"
+
+void print_help(const char *prog_name)
+{
+	printf("Usage: %s [OPTIONS]\n", prog_name);
+	printf("  --yaml       Output in YAML format\n");
+	printf("  --hex        Use hexadecimal index\n");
+	printf("  --help       Show this help message\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int rc = 0;
+	int rc2;
+	enum llapi_layout_verbose verbose = VERBOSE_DEFAULT;
+	enum lov_dump_flags flags = LDF_IS_RAW, flags2;
+	int opt;
+	struct stat st;
+	int i;
+
+	struct option long_options[] = {
+		{"yaml", no_argument, 0, 'y'},
+		{"hex", no_argument, 0, 'x'},
+		{"help", no_argument, 0, 'h'},
+		{0, 0, 0, 0}};
+
+	while ((opt = getopt_long(argc, argv, "", long_options, NULL)) != -1) {
+		switch (opt) {
+		case 'y':
+			flags |= LDF_YAML;
+			break;
+		case 'x':
+			flags |= LDF_HEX_IDX;
+			break;
+		case 'h':
+			print_help(argv[0]);
+			return 0;
+		default:
+			fprintf(stderr, "Unknown option. Use --help for usage information.\n");
+			return 1;
+		}
+	}
+
+	if (optind >= argc) {
+		fprintf(stderr, "No input files specified. Use -h or --help for usage information.\n");
+		return 1;
+	}
+
+	for (i = optind; i < argc; i++) {
+		flags2 = flags;
+		rc2 = stat(argv[i], &st);
+		if (rc2 != 0) {
+			fprintf(stderr, "%s: Stat failed: %s",
+			        argv[i], strerror(errno));
+			continue;
+		}
+		if (S_ISDIR(st.st_mode))
+			flags2 |= LDF_IS_DIR;
+		rc2 = llapi_decode_lov(argv[i], verbose, flags2);
+		if (rc2 != 0)
+			rc = rc2;
+	}
+
+	return rc;
+}
diff --git a/lustre/utils/lustreapi_internal.h b/lustre/utils/lustreapi_internal.h
index a00ad7538c..db5a518b4e 100644
--- a/lustre/utils/lustreapi_internal.h
+++ b/lustre/utils/lustreapi_internal.h
@@ -62,6 +62,19 @@ int sattr_cache_get_defaults(const char *const fsname,
 			     const char *const pathname, unsigned int *scount,
 			     unsigned int *ssize, unsigned int *soffset);
 
+enum lov_dump_flags {
+	LDF_IS_DIR	= 0x0001,
+	LDF_IS_RAW	= 0x0002,
+	LDF_INDENT	= 0x0004,
+	LDF_SKIP_OBJS	= 0x0008,
+	LDF_YAML	= 0x0010,
+	LDF_EXTENSION	= 0x0020,
+	LDF_HEX_IDX	= 0x0040,
+};
+
+int llapi_decode_lov(char *path, enum llapi_layout_verbose verbose,
+	enum lov_dump_flags flags);
+
 /**
  * Often when determining the parameter path in sysfs/procfs we
  * are often only interest set of data. This enum gives use the
