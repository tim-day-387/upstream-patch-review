<html lang="en">
<body>
<pre>
LU-18449 llite: handle kernel readahead for VM_HUGEPAGE vma

In Lustre, the kernel readahead is ususally disabled by setting
ra_pages with zero.
However, the new kernel will still trigger kernel readahead for
mmap() I/O as follow:
do_sync_mmap_readahead() {
	...
	/* Use the readahead code, even if readahead is disable */
	if (vm_flags & VM_HUGEPAGE) {
		...
		ra->size = HPAGE_PMD_NR;
		...
		page_cache_ra_order();
		return fpin;
	}
	...
}

When the vma for the reading page is flagged with VM_HUGEPAGE, it
will trigger the kernel readahead which is out the control of
Lustre.
This can happen when an application sets mmap()ed region with
VM_HUGEPAGE via MADV_HUGEPAGE madvise().

The main reason to avoid the kernel readahead is because that the
reading pages may be not covered by a DLM extent lock.

To solve the readahead problem caused by HUGEPAGE, in ->readpage()
we first do DLM lock match for readahead page. If found a matched
lock, perform I/O under this lock. Otherwise, return the error
code AOP_TRUNCATED_PAGE. And the kernel will redo the I/O again
under Lustre CLIO engine.

Signed-off-by: Qian Yingjin <qian@ddn.com>
Change-Id: I56fb83f4141d4fdad9f29fb21c43bc69352e1330

</pre>
</body>
</html>
