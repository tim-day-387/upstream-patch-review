<html lang="en">
<body>
<pre>
LU-19631 llite: fix EOF handling for EC parity mirrors

Parity components in EC layouts have independent sizes
on OST objects that differ from the file-level EOF.
This causes several issues:

1. File size incorrectly includes parity component
sizes
2. EOF checks prevent reading full parity components
3. Buffered reads are incorrectly constrained by EOF

This patch fixes these issues:

File size calculation:
Modify lov_attr_get_composite() to skip parity
components when calculating file size/kms. Parity
components don't represent user data and shouldn't
contribute to file size.
Blocks and timestamps are still included from all
components.

EOF checks for parity IO:
Add ci_parity_io flag to cl_io to track when IO
targets a parity mirror. This flag is set in
lov_io_mirror_init() when a parity mirror is selected
and inherited by sub-IOs.

Use ci_parity_io to bypass EOF checks in:
- vvp_prep_size(): Skip page index EOF check
- ll_direct_IO_impl(): Skip direct IO EOF checks

We must skip file_read_confine_iter() for all
designated mirror IO - this is not ideal, but it's not
possible to check if it's a parity mirror here as we
don't have the layout yet.  But this code is being
removed soon, so we'll just rebase to get that and all
will be well.

This allows reading the full parity component sizes
regardless of file-level EOF.

Testing:
Add test_parity_read.c program to perform designated
mirror reads and verify data. Add sanity-ec tests 22a
and 22b to verify:
- Mirror resync/verify don't change file EOF
- Reading past parity data returns zeros, not garbage
- Correct behavior with various data sizes

Signed-off-by: Patrick Farrell <pfarrell@whamcloud.com>
Change-Id: I1cf4e51b44f34b7f2b0a0b08ed17026b3ea766c0

</pre>
</body>
</html>
