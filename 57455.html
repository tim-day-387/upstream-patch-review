<html lang="en">
<body>
<pre>
From 07ab6fe2bae44568048421c798eebba895085289 Mon Sep 17 00:00:00 2001
From: Alexey Lyashkov <alexey.lyashkov@hpe.com>
Date: Wed, 20 Nov 2024 16:36:49 +0300
Subject: [PATCH 1/1] LU-18461 layout: join file implementation.

The "join file" feature in S3 is similar to the "merge" feature that was
available in previous versions of Lustre. This feature allows users to
combine multiple files into a single file, with the merged file being
placed at the end of the original files.

This functionality is useful for S3's multi-part upload process, as it
allows users to upload individual parts of a file (known as "chunks")
separately, and then merge them into a single, complete file without having
to copy the data multiple times. The "zero-offset" feature used in this
process allows each chunk to be stored as a separate, movable object, and
then merged together as components of the final file.

Signed-off-by: Alexey Lyashkov <alexey.lyashkov@hpe.com>
Change-Id: Ia2accfd843aa362edc4dc51a114ee3ef47282439
---
 lustre/include/lu_object.h                    |   1 +
 lustre/include/lustre/lustreapi.h             |   2 +
 lustre/include/lustre_req_layout.h            |   2 +
 lustre/include/lustre_swab.h                  |   1 +
 lustre/include/md_object.h                    |  16 ++
 lustre/include/obd_support.h                  |   1 +
 lustre/include/uapi/linux/lustre/lustre_idl.h |   5 +
 .../include/uapi/linux/lustre/lustre_user.h   |   9 +
 lustre/llite/file.c                           |  47 ++++
 lustre/lod/lod_object.c                       | 201 +++++++++++++++++-
 lustre/mdc/mdc_internal.h                     |   2 +
 lustre/mdc/mdc_lib.c                          |  11 +
 lustre/mdc/mdc_request.c                      |  40 +++-
 lustre/mdd/mdd_object.c                       | 130 +++++++++++
 lustre/mdt/mdt_handler.c                      |  49 ++++-
 lustre/ptlrpc/layout.c                        |  20 ++
 lustre/ptlrpc/lproc_ptlrpc.c                  |   1 +
 lustre/ptlrpc/nrs_tbf.c                       |   3 +
 lustre/ptlrpc/pack_generic.c                  |   5 +
 lustre/ptlrpc/wiretest.c                      | 109 +++++-----
 lustre/tests/sanity-zero.sh                   |  58 +++++
 lustre/utils/Makefile.am                      |   2 +
 lustre/utils/lfs.c                            |  11 +
 lustre/utils/liblustreapi_join.c              | 183 ++++++++++++++++
 lustre/utils/wirecheck.c                      |   1 +
 lustre/utils/wiretest.c                       |  83 ++++----
 26 files changed, 888 insertions(+), 105 deletions(-)
 create mode 100644 lustre/utils/liblustreapi_join.c

diff --git a/lustre/include/lu_object.h b/lustre/include/lu_object.h
index 511176fdd9..7aa81362c9 100644
--- a/lustre/include/lu_object.h
+++ b/lustre/include/lu_object.h
@@ -887,6 +887,7 @@ enum lu_xattr_flags {
 	LU_XATTR_MERGE   = BIT(2),
 	LU_XATTR_SPLIT   = BIT(3),
 	LU_XATTR_PURGE   = BIT(4),
+	LU_XATTR_JOIN    = BIT(5),
 };
 
 /* For lu_context health-checks */
diff --git a/lustre/include/lustre/lustreapi.h b/lustre/include/lustre/lustreapi.h
index c0a241bc9b..408fb0e700 100644
--- a/lustre/include/lustre/lustreapi.h
+++ b/lustre/include/lustre/lustreapi.h
@@ -662,6 +662,8 @@ int llapi_fswap_layouts(int fd1, int fd2, __u64 dv1, __u64 dv2, __u64 flags);
 int llapi_swap_layouts(const char *path1, const char *path2, __u64 dv1,
 		       __u64 dv2, __u64 flags);
 
+int llapi_join_layouts(const char *path1, const char *path2, __u64 flags);
+
 /* Changelog interface. priv is private connection state, managed internally */
 
 /* Records received are in extended format now, though most of them are still
diff --git a/lustre/include/lustre_req_layout.h b/lustre/include/lustre_req_layout.h
index c78c8acf2b..520ee576bd 100644
--- a/lustre/include/lustre_req_layout.h
+++ b/lustre/include/lustre_req_layout.h
@@ -228,6 +228,7 @@ extern struct req_format RQF_MDS_SWAP_LAYOUTS;
 extern struct req_format RQF_MDS_REINT_MIGRATE;
 extern struct req_format RQF_MDS_REINT_RESYNC;
 extern struct req_format RQF_MDS_RMFID;
+extern struct req_format RQF_MDS_JOIN_LAYOUTS;
 /* MDS hsm formats */
 extern struct req_format RQF_MDS_HSM_STATE_GET;
 extern struct req_format RQF_MDS_HSM_STATE_SET;
@@ -343,6 +344,7 @@ extern struct req_msg_field RMF_OBD_QUOTACTL_POOL;
 extern struct req_msg_field RMF_QUOTA_BODY;
 extern struct req_msg_field RMF_STRING;
 extern struct req_msg_field RMF_SWAP_LAYOUTS;
+extern struct req_msg_field RMF_JOIN_LAYOUTS;
 extern struct req_msg_field RMF_MDS_HSM_PROGRESS;
 extern struct req_msg_field RMF_MDS_HSM_REQUEST;
 extern struct req_msg_field RMF_MDS_HSM_USER_ITEM;
diff --git a/lustre/include/lustre_swab.h b/lustre/include/lustre_swab.h
index 2b9cd20eb6..80572eaf3c 100644
--- a/lustre/include/lustre_swab.h
+++ b/lustre/include/lustre_swab.h
@@ -115,6 +115,7 @@ void lustre_swab_but_update_header(struct but_update_header *buh);
 void lustre_swab_but_update_buffer(struct but_update_buffer *bub);
 void lustre_swab_batch_update_reply(struct batch_update_reply *bur);
 void lustre_swab_swap_layouts(struct mdc_swap_layouts *msl);
+void lustre_swab_join_layouts(struct mdc_join_layouts *mjl);
 void lustre_swab_close_data(struct close_data *data);
 void lustre_swab_close_data_resync_done(struct close_data_resync_done *resync);
 void lustre_swab_close_data_special(struct close_data *cd, enum mds_op_bias b);
diff --git a/lustre/include/md_object.h b/lustre/include/md_object.h
index d3f582341a..ca88402d3a 100644
--- a/lustre/include/md_object.h
+++ b/lustre/include/md_object.h
@@ -223,6 +223,11 @@ struct md_object_operations {
 			       struct md_object *obj1, struct md_object *obj2,
 			       __u64 dv1, __u64 dv2, __u64 flags);
 
+	/** This method is used to move object2 as component for object 1 */
+	int (*moo_join_layouts)(const struct lu_env *env,
+				struct md_object *obj1, struct md_object *obj2,
+				struct md_attr *attr);
+
 	/** \retval number of bytes actually read upon success */
 	int (*moo_readpage)(const struct lu_env *env, struct md_object *obj,
 			    const struct lu_rdpg *rdpg);
@@ -511,6 +516,17 @@ static inline int mo_swap_layouts(const struct lu_env *env,
 	return o1->mo_ops->moo_swap_layouts(env, o1, o2, dv1, dv2, flags);
 }
 
+static inline int mo_join_layouts(const struct lu_env *env,
+				  struct md_object *o1, struct md_object *o2,
+				  struct md_attr *ma)
+{
+	LASSERT(o1->mo_ops->moo_join_layouts);
+	LASSERT(o2->mo_ops->moo_join_layouts);
+	if (o1->mo_ops->moo_join_layouts != o2->mo_ops->moo_join_layouts)
+		return -EPERM;
+	return o1->mo_ops->moo_join_layouts(env, o1, o2, ma);
+}
+
 static inline int mo_open(const struct lu_env *env, struct md_object *m,
 			  u64 open_flags, struct md_op_spec *spec)
 {
diff --git a/lustre/include/obd_support.h b/lustre/include/obd_support.h
index 47941f3434..b898d6444d 100644
--- a/lustre/include/obd_support.h
+++ b/lustre/include/obd_support.h
@@ -205,6 +205,7 @@ extern bool obd_enable_fname_encoding;
 #define OBD_FAIL_MDS_HSM_CT_REGISTER_NET	0x14d
 #define OBD_FAIL_MDS_HSM_CT_UNREGISTER_NET	0x14e
 #define OBD_FAIL_MDS_SWAP_LAYOUTS_NET		0x14f
+#define OBD_FAIL_MDS_JOIN_LAYOUTS_NET		0x14f
 #define OBD_FAIL_MDS_HSM_ACTION_NET		0x150
 #define OBD_FAIL_MDS_CHANGELOG_INIT		0x151
 #define OBD_FAIL_MDS_HSM_SWAP_LAYOUTS		0x152
diff --git a/lustre/include/uapi/linux/lustre/lustre_idl.h b/lustre/include/uapi/linux/lustre/lustre_idl.h
index 340ebe9820..740490d722 100644
--- a/lustre/include/uapi/linux/lustre/lustre_idl.h
+++ b/lustre/include/uapi/linux/lustre/lustre_idl.h
@@ -1794,6 +1794,7 @@ enum mds_cmd {
 	MDS_RMFID		= 62,
 	MDS_BATCH		= 63,
 	MDS_HSM_DATA_VERSION	= 64,
+	MDS_JOIN_LAYOUTS	= 65,
 	MDS_LAST_OPC
 };
 
@@ -3773,6 +3774,10 @@ struct mdc_swap_layouts {
 	__u64           msl_flags;
 } __attribute__((packed));
 
+struct mdc_join_layouts {
+	__u64           mjl_size;
+} __attribute__((packed));
+
 #define INLINE_RESYNC_ARRAY_SIZE	15
 struct close_data_resync_done {
 	__u32	resync_count;
diff --git a/lustre/include/uapi/linux/lustre/lustre_user.h b/lustre/include/uapi/linux/lustre/lustre_user.h
index 93e0663506..220e486abd 100644
--- a/lustre/include/uapi/linux/lustre/lustre_user.h
+++ b/lustre/include/uapi/linux/lustre/lustre_user.h
@@ -676,6 +676,8 @@ struct ll_ioc_lease_id {
 #define LL_IOC_HSM_ACTION		_IOR('f', 220, \
 						struct hsm_current_action)
 /*	lustre_ioctl.h			221-233 */
+#define LL_IOC_LOV_JOIN_LAYOUTS		_IOW('f', 239, \
+						struct lustre_join_layouts)
 #define LL_IOC_LMV_SETSTRIPE		_IOWR('f', 240, struct lmv_user_md)
 #define LL_IOC_LMV_GETSTRIPE		_IOWR('f', 241, struct lmv_user_md)
 #define LL_IOC_REMOVE_ENTRY		_IOWR('f', 242, __u64)
@@ -1701,6 +1703,13 @@ struct lustre_swap_layouts {
 	__u64	sl_dv2;
 };
 
+struct lustre_join_layouts {
+	__u64	sl_flags;
+	__u32	sl_fd;
+	__u32	sl_size;
+};
+
+
 /** Bit-mask of valid attributes */
 /* The LA_* flags are written to disk as part of the ChangeLog records
  * so they are part of the on-disk and network protocol, and cannot be changed.
diff --git a/lustre/llite/file.c b/lustre/llite/file.c
index 6cceaf2ab9..a04bed0a1b 100644
--- a/lustre/llite/file.c
+++ b/lustre/llite/file.c
@@ -3738,6 +3738,29 @@ free:
 	RETURN(rc);
 }
 
+static int ll_join_layouts(struct file *file1, struct file *file2,
+			   struct lustre_join_layouts *ljl)
+{
+	struct md_op_data	*op_data;
+	int			 rc;
+	struct mdc_join_layouts	 mjl;
+
+	mjl.mjl_size = ljl->sl_size;
+	rc = -ENOMEM;
+	op_data = ll_prep_md_op_data(NULL, file_inode(file1), file_inode(file2),
+				     NULL, 0, 0, LUSTRE_OPC_ANY, &mjl);
+	if (IS_ERR(op_data))
+		RETURN(PTR_ERR(op_data));
+
+	rc = obd_iocontrol(LL_IOC_LOV_JOIN_LAYOUTS,
+			   ll_i2mdexp(file_inode(file1)),
+			   sizeof(*op_data), op_data, NULL);
+	ll_finish_md_op_data(op_data);
+
+	RETURN(rc);
+}
+
+
 int ll_hsm_state_set(struct inode *inode, struct hsm_state_set *hss)
 {
 	struct obd_export *exp = ll_i2mdexp(inode);
@@ -4701,6 +4724,30 @@ out:
 		fput(file2);
 		RETURN(rc);
 	}
+	case LL_IOC_LOV_JOIN_LAYOUTS: {
+		struct file *file2;
+		struct lustre_join_layouts lsl;
+
+		if (copy_from_user(&lsl, (char __user *)arg,
+				   sizeof(struct lustre_join_layouts)))
+			RETURN(-EFAULT);
+
+		if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+			RETURN(-EPERM);
+
+		file2 = fget(lsl.sl_fd);
+		if (file2 == NULL)
+			RETURN(-EBADF);
+
+		/* O_WRONLY or O_RDWR */
+		if ((file2->f_flags & O_ACCMODE) == O_RDONLY)
+			GOTO(join_fput, rc = -EPERM);
+
+		rc = ll_join_layouts(file, file2, &lsl);
+join_fput:
+		fput(file2);
+		RETURN(rc);
+	}
 	case LL_IOC_LOV_GETSTRIPE:
 	case LL_IOC_LOV_GETSTRIPE_NEW:
 		RETURN(ll_file_getstripe(inode, uarg, 0));
diff --git a/lustre/lod/lod_object.c b/lustre/lod/lod_object.c
index a46ef8c52c..3ce2a385b2 100644
--- a/lustre/lod/lod_object.c
+++ b/lustre/lod/lod_object.c
@@ -3351,6 +3351,23 @@ out:
 		OBD_FREE_LARGE(lmm_save, blob_size);
 	return rc;
 }
+static int lod_layout_declare_refresh_ver(const struct lu_env *env,
+		struct lod_object *lo, struct thandle *th)
+{
+	struct lod_thread_info *info = lod_env_info(env);
+	struct lu_attr *layout_attr = &info->lti_layout_attr;
+	struct lod_obj_stripe_cb_data data = { {0} };
+	int rc;
+
+	layout_attr->la_valid = LA_LAYOUT_VERSION;
+	layout_attr->la_layout_version = 0;
+	data.locd_attr = layout_attr;
+	data.locd_declare = true;
+	data.locd_stripe_cb = lod_obj_stripe_attr_set_cb;
+	rc = lod_obj_for_each_stripe(env, lo, th, &data);
+
+	RETURN(rc);
+}
 
 /*
  * Merge layouts to form a mirrored file.
@@ -3517,7 +3534,182 @@ out:
 	RETURN(rc);
 }
 
-/*
+/* Join layouts into single file as difference to merge,
+ * it not create a mirror
+ */
+static int lod_declare_layout_join(const struct lu_env *env,
+		struct dt_object *dt, const struct lu_attr *attr,
+		const struct lu_buf *mbuf,
+		struct thandle *th)
+{
+	struct lod_thread_info *info = lod_env_info(env);
+	struct lu_buf *buf = &info->lti_buf;
+	struct lod_object *lo = lod_dt_obj(dt);
+	struct lov_comp_md_v1 *lcm;
+	struct lov_comp_md_v1 *cur_lcm;
+	struct lov_comp_md_v1 *merge_lcm;
+	struct lov_comp_md_entry_v1 *lcme;
+	size_t size = 0;
+	size_t offset;
+	__u16 cur_entry_count;
+	__u16 merge_entry_count;
+	__u32 id = 0;
+	int rc, i;
+
+	ENTRY;
+	if (mbuf->lb_len < sizeof(*merge_lcm))
+		RETURN(-EINVAL);
+
+	merge_lcm = mbuf->lb_buf;
+	switch (le32_to_cpu(merge_lcm->lcm_magic)) {
+	case LOV_MAGIC_V1:
+	case LOV_MAGIC_V3:
+		rc = lod_layout_convert((struct lu_buf *)mbuf);
+		break;
+	case LOV_MAGIC_COMP_V1:
+		rc = 0;
+		break;
+	default:
+		rc = -EINVAL;
+	}
+	if (rc)
+		RETURN(rc);
+
+	merge_lcm = mbuf->lb_buf;
+	if (le16_to_cpu(merge_lcm->lcm_mirror_count))
+		RETURN(-EBUSY);
+
+	merge_entry_count = le16_to_cpu(merge_lcm->lcm_entry_count);
+	for (i = 0; i < merge_entry_count; i++) {
+		struct lov_comp_md_entry_v1 *merge_lcme;
+		struct lov_mds_md_v1 *lmm;
+		u32 pattern;
+
+		merge_lcme = &merge_lcm->lcm_entries[i];
+		lmm = mbuf->lb_buf + le32_to_cpu(merge_lcme->lcme_offset);
+
+		pattern = lov_pattern(le32_to_cpu(lmm->lmm_pattern));
+		if (pattern != (LOV_PATTERN_RAID0 | LOV_PATTERN_ZEROSTART)) {
+			CDEBUG(D_LAYOUT, "invalid pattern: %x\n", pattern);
+			RETURN(-EINVAL);
+		}
+	}
+
+	/* verify the target buffer */
+	rc = lod_get_lov_ea(env, lo);
+	if (rc <= 0)
+		RETURN(rc ? : -ENODATA);
+
+	cur_lcm = info->lti_ea_buf.lb_buf;
+	switch (le32_to_cpu(cur_lcm->lcm_magic)) {
+	case LOV_MAGIC_V1:
+	case LOV_MAGIC_V3:
+		rc = lod_layout_convert(&info->lti_ea_buf);
+		break;
+	case LOV_MAGIC_COMP_V1:
+	case LOV_MAGIC_SEL:
+		rc = 0;
+		break;
+	default:
+		rc = -EINVAL;
+	}
+	if (rc)
+		RETURN(rc);
+
+	/* info->lti_ea_store could be reallocated in lod_layout_convert() */
+	cur_lcm = info->lti_ea_buf.lb_buf;
+	/* do not allow to merge mirrored files */
+	if (le16_to_cpu(cur_lcm->lcm_mirror_count))
+		RETURN(-EBUSY);
+
+	cur_entry_count = le16_to_cpu(cur_lcm->lcm_entry_count);
+
+	CDEBUG(D_INFO, "start merge %px %px\n", cur_lcm, merge_lcm);
+
+	/* size of new layout */
+	size = le32_to_cpu(cur_lcm->lcm_size) +
+	       le32_to_cpu(merge_lcm->lcm_size) - sizeof(*cur_lcm);
+
+	*buf = LU_BUF_NULL;
+	lu_buf_alloc(buf, size);
+	if (buf->lb_buf == NULL)
+		RETURN(-ENOMEM);
+
+	lcm = buf->lb_buf;
+	/* copy header + orig components*/
+	offset = sizeof(*lcm) + cur_entry_count * sizeof(*lcme);
+	memcpy(lcm, cur_lcm, offset);
+	/* join components */
+	memcpy((char *)lcm+offset, &merge_lcm->lcm_entries[0],
+		merge_entry_count * sizeof(*lcme));
+
+	/* copy objects and adjust offsets */
+	offset = sizeof(*lcm) +
+		 sizeof(*lcme) * (cur_entry_count + merge_entry_count);
+
+	lcme = &lcm->lcm_entries[0]; // just make gcc happy
+	for (i = 0; i < cur_entry_count; i++) {
+		struct lov_comp_md_entry_v1 *cur_lcme;
+
+		lcme = &lcm->lcm_entries[i];
+		cur_lcme = &cur_lcm->lcm_entries[i];
+
+		lcme->lcme_offset = cpu_to_le32(offset);
+		memcpy((char *)lcm + offset,
+		       (char *)cur_lcm + le32_to_cpu(cur_lcme->lcme_offset),
+		       le32_to_cpu(lcme->lcme_size));
+
+		offset += le32_to_cpu(lcme->lcme_size);
+
+		id = max(le32_to_cpu(lcme->lcme_id), id);
+	}
+	lcme->lcme_extent.e_end = attr->la_size;
+
+	for (i = 0; i < merge_entry_count; i++) {
+		struct lov_comp_md_entry_v1 *merge_lcme;
+
+		lcme = &lcm->lcm_entries[cur_entry_count + i];
+		lcme->lcme_offset = cpu_to_le32(offset);
+
+		id++;
+		lcme->lcme_id = cpu_to_le32(id);
+		lcme->lcme_extent.e_start += attr->la_size;
+		if (lcme->lcme_extent.e_end != LUSTRE_EOF)
+			lcme->lcme_extent.e_end += attr->la_size;
+		merge_lcme = &merge_lcm->lcm_entries[i];
+
+		memcpy((char *)lcm + offset,
+		       (char *)merge_lcm + le32_to_cpu(merge_lcme->lcme_offset),
+		       le32_to_cpu(merge_lcme->lcme_size));
+
+		offset += le32_to_cpu(lcme->lcme_size);
+	}
+
+	/* fixup layout information */
+	lcm->lcm_size = cpu_to_le32(size);
+	lcm->lcm_entry_count = cpu_to_le16(cur_entry_count + merge_entry_count);
+	if ((le16_to_cpu(lcm->lcm_flags) & LCM_FL_FLR_MASK) == LCM_FL_NONE)
+		lcm->lcm_flags = cpu_to_le32(LCM_FL_RDONLY);
+
+	rc = lod_striping_reload(env, lo, buf, 0);
+	if (rc)
+		GOTO(out, rc);
+
+	lod_obj_inc_layout_gen(lo);
+	lcm->lcm_layout_gen = cpu_to_le32(lo->ldo_layout_gen);
+
+	rc = lod_layout_declare_refresh_ver(env, lo, th);
+	if (rc)
+		GOTO(out, rc);
+
+	rc = lod_sub_declare_xattr_set(env, dt_object_child(dt), buf,
+					XATTR_NAME_LOV, LU_XATTR_REPLACE, th);
+out:
+	lu_buf_free(buf);
+	RETURN(rc);
+}
+
+/**
  * Split layouts, just set the LOVEA with the layout from mbuf.
  */
 static int lod_declare_layout_split(const struct lu_env *env,
@@ -3759,7 +3951,7 @@ static int lod_declare_xattr_set(const struct lu_env *env,
 	mode = dt->do_lu.lo_header->loh_attr & S_IFMT;
 	if ((S_ISREG(mode) || mode == 0) &&
 	    !(fl & (LU_XATTR_REPLACE | LU_XATTR_MERGE | LU_XATTR_SPLIT |
-		    LU_XATTR_PURGE)) &&
+		    LU_XATTR_PURGE | LU_XATTR_JOIN)) &&
 	    (strcmp(name, XATTR_NAME_LOV) == 0 ||
 	     strcmp(name, XATTR_LUSTRE_LOV) == 0)) {
 		struct lu_attr	 *lattr = &lod_env_info(env)->lti_attr;
@@ -3795,6 +3987,10 @@ static int lod_declare_xattr_set(const struct lu_env *env,
 		LASSERT(strcmp(name, XATTR_NAME_LOV) == 0 ||
 			strcmp(name, XATTR_LUSTRE_LOV) == 0);
 		rc = lod_declare_layout_purge(env, dt, buf, th);
+	} else if (fl & LU_XATTR_JOIN) {
+		LASSERT(strcmp(name, XATTR_NAME_LOV) == 0 ||
+			strcmp(name, XATTR_LUSTRE_LOV) == 0);
+		rc = lod_declare_layout_join(env, dt, attr, buf, th);
 	} else if (S_ISREG(mode) &&
 		   strlen(name) >= sizeof(XATTR_LUSTRE_LOV) + 3 &&
 		   allowed_lustre_lov(name)) {
@@ -3804,7 +4000,6 @@ static int lod_declare_xattr_set(const struct lu_env *env,
 		 */
 		if (!dt_object_exists(dt))
 			RETURN(-ENOENT);
-
 		rc = lod_declare_modify_layout(env, dt, name, buf, th);
 	} else if (S_ISDIR(mode)) {
 		rc = lod_dir_declare_xattr_set(env, dt, buf, name, fl, th);
diff --git a/lustre/mdc/mdc_internal.h b/lustre/mdc/mdc_internal.h
index caaa9892ff..ac7765104e 100644
--- a/lustre/mdc/mdc_internal.h
+++ b/lustre/mdc/mdc_internal.h
@@ -23,6 +23,8 @@ void mdc_pack_body(struct req_capsule *pill, const struct lu_fid *fid,
 		   u32 projid);
 void mdc_swap_layouts_pack(struct req_capsule *pill,
 			   struct md_op_data *op_data);
+void mdc_join_layouts_pack(struct req_capsule *pill,
+			   struct md_op_data *op_data);
 void mdc_readdir_pack(struct req_capsule *pill, __u64 pgoff, size_t size,
 		      const struct lu_fid *fid);
 void mdc_getattr_pack(struct req_capsule *pill, __u64 valid, __u32 flags,
diff --git a/lustre/mdc/mdc_lib.c b/lustre/mdc/mdc_lib.c
index c4e99fc089..54ea688da9 100644
--- a/lustre/mdc/mdc_lib.c
+++ b/lustre/mdc/mdc_lib.c
@@ -59,6 +59,17 @@ void mdc_swap_layouts_pack(struct req_capsule *pill,
 	b->mbo_valid |= OBD_MD_FLID;
 }
 
+void mdc_join_layouts_pack(struct req_capsule *pill,
+			   struct md_op_data *op_data)
+{
+	struct mdt_body *b = req_capsule_client_get(pill, &RMF_MDT_BODY);
+
+	__mdc_pack_body(b, op_data->op_suppgids[0]);
+	b->mbo_fid1 = op_data->op_fid1;
+	b->mbo_fid2 = op_data->op_fid2;
+	b->mbo_valid |= OBD_MD_FLID;
+}
+
 void mdc_pack_body(struct req_capsule *pill, const struct lu_fid *fid,
 		   u64 valid, size_t ea_size, u32 suppgid, u32 flags,
 		   u32 projid)
diff --git a/lustre/mdc/mdc_request.c b/lustre/mdc/mdc_request.c
index 4081f0b32f..c5c0bde7b6 100644
--- a/lustre/mdc/mdc_request.c
+++ b/lustre/mdc/mdc_request.c
@@ -2210,16 +2210,15 @@ out:
 	RETURN(rc);
 }
 
-static int mdc_ioc_swap_layouts(struct obd_export *exp,
-				struct md_op_data *op_data)
+static int mdc_ioc_layouts(struct obd_export *exp, struct md_op_data *op_data,
+			   enum mds_cmd cmd, struct req_format *fmt,
+			   struct req_msg_field *field, size_t data_sz)
 {
 	LIST_HEAD(cancels);
 	struct ptlrpc_request	*req;
 	int			 rc, count;
-	struct mdc_swap_layouts *msl, *payload;
-
+	void *payload;
 	ENTRY;
-	msl = op_data->op_data;
 
 	/* When the MDT will get the MDS_SWAP_LAYOUTS RPC the
 	 * first thing it will do is to cancel the 2 layout
@@ -2234,14 +2233,13 @@ static int mdc_ioc_swap_layouts(struct obd_export *exp,
 					    LCK_EX, MDS_INODELOCK_LAYOUT |
 					    MDS_INODELOCK_XATTR);
 
-	req = ptlrpc_request_alloc(class_exp2cliimp(exp),
-				   &RQF_MDS_SWAP_LAYOUTS);
+	req = ptlrpc_request_alloc(class_exp2cliimp(exp), fmt);
 	if (req == NULL) {
 		ldlm_lock_list_put(&cancels, l_bl_ast, count);
 		RETURN(-ENOMEM);
 	}
 
-	rc = mdc_prep_elc_req(exp, req, MDS_SWAP_LAYOUTS, &cancels, count);
+	rc = mdc_prep_elc_req(exp, req, cmd, &cancels, count);
 	if (rc) {
 		ptlrpc_request_free(req);
 		RETURN(rc);
@@ -2249,10 +2247,11 @@ static int mdc_ioc_swap_layouts(struct obd_export *exp,
 
 	mdc_swap_layouts_pack(&req->rq_pill, op_data);
 
-	payload = req_capsule_client_get(&req->rq_pill, &RMF_SWAP_LAYOUTS);
+	payload = req_capsule_client_get(&req->rq_pill, field);
 	LASSERT(payload);
 
-	*payload = *msl;
+	if (op_data->op_data)
+		memcpy(payload, op_data->op_data, data_sz);
 
 	ptlrpc_request_set_replen(req);
 
@@ -2266,6 +2265,24 @@ out:
 	return rc;
 }
 
+static int mdc_ioc_swap_layouts(struct obd_export *exp,
+				struct md_op_data *op_data)
+{
+	return mdc_ioc_layouts(exp, op_data, MDS_SWAP_LAYOUTS,
+			       &RQF_MDS_SWAP_LAYOUTS,
+			       &RMF_SWAP_LAYOUTS,
+			       sizeof(struct mdc_swap_layouts));
+}
+
+static int mdc_ioc_join_layouts(struct obd_export *exp,
+				struct md_op_data *op_data)
+{
+	return mdc_ioc_layouts(exp, op_data, MDS_JOIN_LAYOUTS,
+			       &RQF_MDS_JOIN_LAYOUTS,
+			       &RMF_JOIN_LAYOUTS,
+			       sizeof(struct mdc_join_layouts));
+}
+
 static int mdc_iocontrol(unsigned int cmd, struct obd_export *exp, int len,
 			 void *karg, void __user *uarg)
 {
@@ -2389,6 +2406,9 @@ static int mdc_iocontrol(unsigned int cmd, struct obd_export *exp, int len,
 	case LL_IOC_LOV_SWAP_LAYOUTS:
 		rc = mdc_ioc_swap_layouts(exp, karg);
 		GOTO(out, rc);
+	case LL_IOC_LOV_JOIN_LAYOUTS:
+		rc = mdc_ioc_join_layouts(exp, karg);
+		GOTO(out, rc);
 	default:
 		rc = OBD_IOC_ERROR(obd->obd_name, cmd, "unrecognized", -ENOTTY);
 		break;
diff --git a/lustre/mdd/mdd_object.c b/lustre/mdd/mdd_object.c
index eab3e25ae6..040511145e 100644
--- a/lustre/mdd/mdd_object.c
+++ b/lustre/mdd/mdd_object.c
@@ -3090,6 +3090,135 @@ stop:
 	RETURN(rc);
 }
 
+static int mdd_layout_join_allowed(const struct lu_env *env,
+				   struct mdd_object *o1,
+				   struct mdd_object *o2)
+{
+	const struct lu_fid *fid1, *fid2;
+
+	ENTRY;
+
+	fid1 = mdd_object_fid(o1);
+	fid2 = mdd_object_fid(o2);
+
+	if (!fid_is_norm(fid1) &&
+	    (!fid_is_igif(fid1) || IS_ERR(mdd_links_get(env, o1))))
+		RETURN(-EBADF);
+
+	if (!fid_is_norm(fid2) &&
+	    (!fid_is_igif(fid2) || IS_ERR(mdd_links_get(env, o2))))
+		RETURN(-EBADF);
+
+	if (S_ISDIR(mdd_object_type(o1)))
+		RETURN(-ENOTDIR);
+
+	if (S_ISDIR(mdd_object_type(o2)))
+		RETURN(-ENOTDIR);
+
+	RETURN(0);
+}
+
+static int mdd_join_layouts(const struct lu_env *env, struct md_object *md_obj,
+			    struct md_object *md_vic, struct md_attr *ma)
+{
+	struct mdd_device *mdd = mdo2mdd(md_obj);
+	struct mdd_object *obj = md2mdd_obj(md_obj);
+	struct dt_object *next = mdd_object_child(obj);
+	struct mdd_object *vic = md2mdd_obj(md_vic);
+	struct lu_buf *buf = &mdd_env_info(env)->mdi_buf[0];
+	struct lu_buf *buf_vic = &mdd_env_info(env)->mdi_buf[1];
+	struct thandle *handle;
+	int rc, lock_order;
+
+	ENTRY;
+
+	lock_order = lu_fid_cmp(mdd_object_fid(obj), mdd_object_fid(vic));
+	if (lock_order == 0) /* same fid */
+		RETURN(-EPERM);
+
+	rc = mdd_layout_join_allowed(env, obj, vic);
+	if (rc)
+		RETURN(rc);
+
+	handle = mdd_trans_create(env, mdd);
+	if (IS_ERR(handle))
+		RETURN(PTR_ERR(handle));
+
+	/* get EA of victim file */
+	memset(buf_vic, 0, sizeof(*buf_vic));
+	rc = mdd_stripe_get(env, vic, buf_vic, XATTR_NAME_LOV);
+	if (rc < 0) {
+		if (rc == -ENODATA)
+			rc = 0;
+		GOTO(stop, rc);
+	}
+
+	/* save EA of target file for restore */
+	memset(buf, 0, sizeof(*buf));
+	rc = mdd_stripe_get(env, obj, buf, XATTR_NAME_LOV);
+	if (rc < 0)
+		GOTO(stop, rc);
+
+	/* sanity check will done on the LOD layer in prep phase */
+	rc = dt_declare_xattr_set(env, next, &ma->ma_attr, buf_vic,
+				  XATTR_NAME_LOV, LU_XATTR_JOIN, handle);
+	if (rc)
+		GOTO(stop, rc);
+
+	/* Get rid of the layout from victim object */
+	rc = mdd_declare_xattr_del(env, mdd, vic, XATTR_NAME_LOV, handle);
+	if (rc)
+		GOTO(stop, rc);
+
+	rc = mdd_trans_start(env, mdd, handle);
+	if (rc != 0)
+		GOTO(stop, rc);
+
+	if (lock_order > 0) {
+		mdd_write_lock(env, obj, DT_TGT_CHILD);
+		mdd_write_lock(env, vic, DT_TGT_CHILD);
+	} else {
+		mdd_write_lock(env, vic, DT_TGT_CHILD);
+		mdd_write_lock(env, obj, DT_TGT_CHILD);
+	}
+
+	rc = mdo_xattr_set(env, obj, buf_vic, XATTR_NAME_LOV, LU_XATTR_JOIN,
+			   handle);
+	if (rc)
+		GOTO(out, rc);
+
+	rc = mdo_xattr_del(env, vic, XATTR_NAME_LOV, handle);
+	if (rc) /* wtf? */
+		GOTO(out_restore, rc);
+
+	(void)mdd_changelog_data_store(env, mdd, CL_LAYOUT, 0, obj, handle,
+				       ma && (ma->ma_valid & MA_PFID) ?
+				       &ma->ma_pfid : NULL);
+	(void)mdd_changelog_data_store(env, mdd, CL_LAYOUT, 0, vic, handle,
+				       NULL);
+	EXIT;
+
+out_restore:
+	if (rc) {
+		int rc2 = mdo_xattr_set(env, obj, buf, XATTR_NAME_LOV,
+					LU_XATTR_REPLACE, handle);
+		if (rc2)
+			CERROR("%s: failed rollback of "DFID" layout: file state unknown: rc = %d\n",
+			       mdd_obj_dev_name(obj),
+			       PFID(mdd_object_fid(obj)), rc2);
+	}
+
+out:
+	mdd_write_unlock(env, obj);
+	mdd_write_unlock(env, vic);
+stop:
+	mdd_trans_stop(env, mdd, rc, handle);
+	lu_buf_free(buf);
+	lu_buf_free(buf_vic);
+
+	return rc;
+}
+
 static int mdd_declare_layout_change(const struct lu_env *env,
 				     struct mdd_device *mdd,
 				     struct mdd_object *obj,
@@ -4234,6 +4363,7 @@ const struct md_object_operations mdd_obj_ops = {
 	.moo_invalidate		= mdd_invalidate,
 	.moo_xattr_del		= mdd_xattr_del,
 	.moo_swap_layouts	= mdd_swap_layouts,
+	.moo_join_layouts	= mdd_join_layouts,
 	.moo_open		= mdd_open,
 	.moo_close		= mdd_close,
 	.moo_readpage		= mdd_readpage,
diff --git a/lustre/mdt/mdt_handler.c b/lustre/mdt/mdt_handler.c
index 5eef04015b..459704a4fd 100644
--- a/lustre/mdt/mdt_handler.c
+++ b/lustre/mdt/mdt_handler.c
@@ -1839,14 +1839,21 @@ static void mdt_swap_lov_flag(struct mdt_object *o1, struct mdt_object *o2)
 	mutex_unlock(&o1->mot_lov_mutex);
 }
 
-static int mdt_swap_layouts(struct tgt_session_info *tsi)
+enum mdt_layout_op {
+	MDT_SWAP_LAYOUT_OP,
+	MDT_JOIN_LAYOUT_OP,
+	MDT_LAYOUT_OP_MAX
+};
+
+static int mdt_layouts(struct tgt_session_info *tsi, enum mdt_layout_op op,
+		       struct req_msg_field *field)
 {
 	struct mdt_thread_info	*info;
 	struct ptlrpc_request	*req = tgt_ses_req(tsi);
 	struct obd_export	*exp = req->rq_export;
 	struct mdt_object	*o1, *o2, *o;
 	struct mdt_lock_handle	*lh1, *lh2;
-	struct mdc_swap_layouts *msl;
+	void			*payload;
 	int rc;
 
 	ENTRY;
@@ -1882,7 +1889,7 @@ static int mdt_swap_layouts(struct tgt_session_info *tsi)
 	if (unlikely(rc == 0)) /* same file, you kidding me? no-op. */
 		GOTO(put, rc);
 
-	if (rc < 0)
+	if (op == MDT_SWAP_LAYOUT_OP && rc < 0)
 		swap(o1, o2);
 
 	/* permission check. Make sure the calling process having permission
@@ -1898,8 +1905,8 @@ static int mdt_swap_layouts(struct tgt_session_info *tsi)
 	if (rc < 0)
 		GOTO(put, rc);
 
-	msl = req_capsule_client_get(info->mti_pill, &RMF_SWAP_LAYOUTS);
-	if (msl == NULL)
+	payload = req_capsule_client_get(info->mti_pill, field);
+	if (payload == NULL)
 		GOTO(put, rc = -EPROTO);
 
 	lh1 = &info->mti_lh[MDT_LH_NEW];
@@ -1914,12 +1921,26 @@ static int mdt_swap_layouts(struct tgt_session_info *tsi)
 	if (rc < 0)
 		GOTO(unlock1, rc);
 
-	rc = mo_swap_layouts(info->mti_env, mdt_object_child(o1),
+	if (op == MDT_SWAP_LAYOUT_OP) {
+		struct mdc_swap_layouts *msl = payload;
+
+		rc = mo_swap_layouts(info->mti_env, mdt_object_child(o1),
 			     mdt_object_child(o2), 0, 0, msl->msl_flags);
+	} else if (op == MDT_JOIN_LAYOUT_OP) {
+		struct mdc_join_layouts *mjl = payload;
+		struct md_attr          *ma = &info->mti_attr;
+
+		ma->ma_attr.la_size = mjl->mjl_size;
+		rc = mo_join_layouts(info->mti_env, mdt_object_child(o1),
+			     mdt_object_child(o2), ma);
+	} else
+		rc = -EPROTO;
+
 	if (rc < 0)
 		GOTO(unlock2, rc);
 
-	mdt_swap_lov_flag(o1, o2);
+	if (op == MDT_SWAP_LAYOUT_OP)
+		mdt_swap_lov_flag(o1, o2);
 
 unlock2:
 	mdt_object_unlock(info, o2, lh2, rc);
@@ -1932,6 +1953,17 @@ out:
 	RETURN(rc);
 }
 
+static int mdt_swap_layouts(struct tgt_session_info *tsi)
+{
+	return mdt_layouts(tsi, MDT_SWAP_LAYOUT_OP, &RMF_SWAP_LAYOUTS);
+}
+
+static int mdt_join_layouts(struct tgt_session_info *tsi)
+{
+	return mdt_layouts(tsi, MDT_JOIN_LAYOUT_OP, &RMF_JOIN_LAYOUTS);
+}
+
+
 static int mdt_raw_lookup(struct mdt_thread_info *info,
 			  struct mdt_object *parent,
 			  const struct lu_name *lname)
@@ -6295,6 +6327,9 @@ TGT_MDT_HDL(HAS_BODY | HAS_REPLY | IS_MUTABLE, MDS_HSM_DATA_VERSION,
 	    mdt_hsm_data_version),
 TGT_MDT_HDL(IS_MUTABLE,		MDS_RMFID,	mdt_rmfid),
 TGT_MDT_HDL(IS_MUTABLE,		MDS_BATCH,	mdt_batch),
+TGT_MDT_HDL(HAS_KEY | HAS_BODY | HAS_REPLY | IS_MUTABLE,
+	    MDS_JOIN_LAYOUTS,
+	    mdt_join_layouts),
 };
 
 static struct tgt_handler mdt_io_ops[] = {
diff --git a/lustre/ptlrpc/layout.c b/lustre/ptlrpc/layout.c
index aefad2fbdc..1dd5dd2a3f 100644
--- a/lustre/ptlrpc/layout.c
+++ b/lustre/ptlrpc/layout.c
@@ -340,6 +340,15 @@ static const struct req_msg_field *mdt_swap_layouts[] = {
 	&RMF_DLM_REQ
 };
 
+static const struct req_msg_field *mdt_join_layouts[] = {
+	&RMF_PTLRPC_BODY,
+	&RMF_MDT_BODY,
+	&RMF_JOIN_LAYOUTS,
+	&RMF_CAPA1,
+	&RMF_CAPA2,
+	&RMF_DLM_REQ
+};
+
 static const struct req_msg_field *mds_rmfid_client[] = {
 	&RMF_PTLRPC_BODY,
 	&RMF_MDT_BODY,
@@ -851,6 +860,7 @@ static struct req_format *req_formats[] = {
 	&RQF_MDS_HSM_DATA_VERSION,
 	&RQF_MDS_SWAP_LAYOUTS,
 	&RQF_MDS_RMFID,
+	&RQF_MDS_JOIN_LAYOUTS,
 #ifdef HAVE_SERVER_SUPPORT
 	&RQF_OUT_UPDATE,
 #endif
@@ -1329,6 +1339,11 @@ struct req_msg_field RMF_SWAP_LAYOUTS =
 		    lustre_swab_swap_layouts, NULL);
 EXPORT_SYMBOL(RMF_SWAP_LAYOUTS);
 
+struct req_msg_field RMF_JOIN_LAYOUTS =
+	DEFINE_MSGF("join_layouts", 0, sizeof(struct  mdc_join_layouts),
+		    lustre_swab_join_layouts, NULL);
+EXPORT_SYMBOL(RMF_JOIN_LAYOUTS);
+
 struct req_msg_field RMF_LFSCK_REQUEST =
 	DEFINE_MSGF("lfsck_request", 0, sizeof(struct lfsck_request),
 		    lustre_swab_lfsck_request, NULL);
@@ -1732,6 +1747,11 @@ struct req_format RQF_MDS_SWAP_LAYOUTS =
 			mdt_swap_layouts, empty);
 EXPORT_SYMBOL(RQF_MDS_SWAP_LAYOUTS);
 
+struct req_format RQF_MDS_JOIN_LAYOUTS =
+	DEFINE_REQ_FMT0("MDS_JOIN_LAYOUTS",
+			mdt_join_layouts, empty);
+EXPORT_SYMBOL(RQF_MDS_JOIN_LAYOUTS);
+
 struct req_format RQF_MDS_RMFID =
 	DEFINE_REQ_FMT0("MDS_RMFID", mds_rmfid_client,
 			mds_rmfid_server);
diff --git a/lustre/ptlrpc/lproc_ptlrpc.c b/lustre/ptlrpc/lproc_ptlrpc.c
index 5668c48752..bc275ac987 100644
--- a/lustre/ptlrpc/lproc_ptlrpc.c
+++ b/lustre/ptlrpc/lproc_ptlrpc.c
@@ -82,6 +82,7 @@ static struct ll_rpc_opcode {
 	{ MDS_RMFID,        "mds_rmfid" },
 	{ MDS_BATCH,        "mds_batch" },
 	{ MDS_HSM_DATA_VERSION, "mds_hsm_data_version" },
+	{ MDS_JOIN_LAYOUTS,	"mds_join_layouts" },
 	{ LDLM_ENQUEUE,     "ldlm_enqueue" },
 	{ LDLM_CONVERT,     "ldlm_convert" },
 	{ LDLM_CANCEL,      "ldlm_cancel" },
diff --git a/lustre/ptlrpc/nrs_tbf.c b/lustre/ptlrpc/nrs_tbf.c
index 8c042ed8dd..a43412d2a0 100644
--- a/lustre/ptlrpc/nrs_tbf.c
+++ b/lustre/ptlrpc/nrs_tbf.c
@@ -1505,6 +1505,8 @@ static struct req_format *req_fmt(__u32 opcode)
 #endif
 	case MDS_SWAP_LAYOUTS:
 		return &RQF_MDS_SWAP_LAYOUTS;
+	case MDS_JOIN_LAYOUTS:
+		return &RQF_MDS_JOIN_LAYOUTS;
 	case LDLM_ENQUEUE:
 		return &RQF_LDLM_ENQUEUE;
 	default:
@@ -1582,6 +1584,7 @@ static int mdt_tbf_id_cli_set(struct ptlrpc_request *req,
 	case MDS_SYNC:
 	case MDS_GETXATTR:
 	case MDS_HSM_STATE_GET ... MDS_SWAP_LAYOUTS:
+	case MDS_JOIN_LAYOUTS:
 		unpack_ugid_from_mdt_body(req, id);
 		break;
 	case MDS_CLOSE:
diff --git a/lustre/ptlrpc/pack_generic.c b/lustre/ptlrpc/pack_generic.c
index 07d8693f77..7b21eebea3 100644
--- a/lustre/ptlrpc/pack_generic.c
+++ b/lustre/ptlrpc/pack_generic.c
@@ -3069,6 +3069,11 @@ void lustre_swab_swap_layouts(struct mdc_swap_layouts *msl)
 	__swab64s(&msl->msl_flags);
 }
 
+void lustre_swab_join_layouts(struct mdc_join_layouts *mjl)
+{
+	__swab64s(&mjl->mjl_size);
+}
+
 void lustre_swab_close_data(struct close_data *cd)
 {
 
diff --git a/lustre/ptlrpc/wiretest.c b/lustre/ptlrpc/wiretest.c
index 8b127dcffa..576795fa4f 100644
--- a/lustre/ptlrpc/wiretest.c
+++ b/lustre/ptlrpc/wiretest.c
@@ -169,7 +169,9 @@ void lustre_assert_wire_constants(void)
 		 (long long)MDS_BATCH);
 	LASSERTF(MDS_HSM_DATA_VERSION == 64, "found %lld\n",
 		 (long long)MDS_HSM_DATA_VERSION);
-	LASSERTF(MDS_LAST_OPC == 65, "found %lld\n",
+	LASSERTF(MDS_JOIN_LAYOUTS == 65, "found %lld\n",
+		 (long long)MDS_JOIN_LAYOUTS);
+	LASSERTF(MDS_LAST_OPC == 66, "found %lld\n",
 		 (long long)MDS_LAST_OPC);
 	LASSERTF(REINT_SETATTR == 1, "found %lld\n",
 		 (long long)REINT_SETATTR);
@@ -800,6 +802,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct ladvise_hdr, lah_advise));
 	LASSERTF((int)sizeof(*((struct ladvise_hdr *)0)->lah_advise) == 32, "found %lld\n",
 		 (long long)(int)sizeof(*((struct ladvise_hdr *)0)->lah_advise));
+	BUILD_BUG_ON(offsetof(struct ladvise_hdr, lah_advise) != sizeof(struct ladvise_hdr));
 	BUILD_BUG_ON(LF_ASYNC != 0x00000001);
 	BUILD_BUG_ON(LF_UNSET != 0x00000002);
 	BUILD_BUG_ON(LADVISE_MAGIC != 0x1adf1ce0);
@@ -1821,6 +1824,8 @@ void lustre_assert_wire_constants(void)
 		(unsigned)LOV_PATTERN_MDT);
 	LASSERTF(LOV_PATTERN_OVERSTRIPING == 0x00000200UL, "found 0x%.8xUL\n",
 		(unsigned)LOV_PATTERN_OVERSTRIPING);
+	LASSERTF(LOV_PATTERN_ZEROSTART == 0x00001000UL, "found 0x%.8xUL\n",
+		(unsigned)LOV_PATTERN_ZEROSTART);
 
 	/* Checks for struct lov_foreign_md */
 	LASSERTF((int)sizeof(struct lov_foreign_md) == 16, "found %lld\n",
@@ -2711,50 +2716,50 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct mdt_body, mbo_padding_10));
 	LASSERTF((int)sizeof(((struct mdt_body *)0)->mbo_padding_10) == 8, "found %lld\n",
 		 (long long)(int)sizeof(((struct mdt_body *)0)->mbo_padding_10));
-	LASSERTF(MDS_FMODE_CLOSED == 0000000000000000000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_FMODE_CLOSED);
-	LASSERTF(MDS_FMODE_EXEC == 0000000000000000000000004UL,
-		 "found 0%.22lloUL\n", (long long)MDS_FMODE_EXEC);
-	LASSERTF(MDS_OPEN_CREATED == 0000000000000000000000010UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_CREATED);
-	LASSERTF(MDS_OPEN_CREAT == 0000000000000000000000100UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_CREAT);
-	LASSERTF(MDS_OPEN_EXCL == 0000000000000000000000200UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_EXCL);
-	LASSERTF(MDS_OPEN_TRUNC == 0000000000000000000001000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_TRUNC);
-	LASSERTF(MDS_OPEN_APPEND == 0000000000000000000002000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_APPEND);
-	LASSERTF(MDS_OPEN_SYNC == 0000000000000000000010000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_SYNC);
-	LASSERTF(MDS_OPEN_DIRECTORY == 0000000000000000000200000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_DIRECTORY);
-	LASSERTF(MDS_OPEN_BY_FID == 0000000000000000040000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_BY_FID);
-	LASSERTF(MDS_OPEN_DELAY_CREATE == 0000000000000000100000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_DELAY_CREATE);
-	LASSERTF(MDS_OPEN_OWNEROVERRIDE == 0000000000000000200000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_OWNEROVERRIDE);
-	LASSERTF(MDS_OPEN_LOCK == 0000000000000004000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_LOCK);
-	LASSERTF(MDS_OPEN_HAS_EA == 0000000000000010000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_HAS_EA);
-	LASSERTF(MDS_OPEN_HAS_OBJS == 0000000000000020000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_HAS_OBJS);
-	LASSERTF(MDS_OPEN_NORESTORE == 00000000000100000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_NORESTORE);
-	LASSERTF(MDS_OPEN_NEWSTRIPE == 00000000000200000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_NEWSTRIPE);
-	LASSERTF(MDS_OPEN_VOLATILE == 00000000000400000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_VOLATILE);
-	LASSERTF(MDS_OPEN_LEASE == 00000000001000000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_LEASE);
-	LASSERTF(MDS_OPEN_RESYNC == 00000000004000000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_RESYNC);
-	LASSERTF(MDS_OPEN_PCC == 00000000010000000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_PCC);
-	LASSERTF(MDS_OPEN_DEFAULT_LMV == 00000000040000000000000ULL,
-		 "found 0%.22lloULL\n", (long long)MDS_OPEN_DEFAULT_LMV);
+	LASSERTF(MDS_FMODE_CLOSED == 00000000000000000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_FMODE_CLOSED);
+	LASSERTF(MDS_FMODE_EXEC == 00000000000000000000004ULL, "found 0%.22lloULL\n",
+			(long long)MDS_FMODE_EXEC);
+	LASSERTF(MDS_OPEN_CREATED == 00000000000000000000010ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_CREATED);
+	LASSERTF(MDS_OPEN_CREAT == 00000000000000000000100ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_CREAT);
+	LASSERTF(MDS_OPEN_EXCL == 00000000000000000000200ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_EXCL);
+	LASSERTF(MDS_OPEN_TRUNC == 00000000000000000001000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_TRUNC);
+	LASSERTF(MDS_OPEN_APPEND == 00000000000000000002000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_APPEND);
+	LASSERTF(MDS_OPEN_SYNC == 00000000000000000010000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_SYNC);
+	LASSERTF(MDS_OPEN_DIRECTORY == 00000000000000000200000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_DIRECTORY);
+	LASSERTF(MDS_OPEN_BY_FID == 00000000000000040000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_BY_FID);
+	LASSERTF(MDS_OPEN_DELAY_CREATE == 00000000000000100000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_DELAY_CREATE);
+	LASSERTF(MDS_OPEN_OWNEROVERRIDE == 00000000000000200000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_OWNEROVERRIDE);
+	LASSERTF(MDS_OPEN_LOCK == 00000000000004000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_LOCK);
+	LASSERTF(MDS_OPEN_HAS_EA == 00000000000010000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_HAS_EA);
+	LASSERTF(MDS_OPEN_HAS_OBJS == 00000000000020000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_HAS_OBJS);
+	LASSERTF(MDS_OPEN_NORESTORE == 00000000000100000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_NORESTORE);
+	LASSERTF(MDS_OPEN_NEWSTRIPE == 00000000000200000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_NEWSTRIPE);
+	LASSERTF(MDS_OPEN_VOLATILE == 00000000000400000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_VOLATILE);
+	LASSERTF(MDS_OPEN_LEASE == 00000000001000000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_LEASE);
+	LASSERTF(MDS_OPEN_RESYNC == 00000000004000000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_RESYNC);
+	LASSERTF(MDS_OPEN_PCC == 00000000010000000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_PCC);
+	LASSERTF(MDS_OPEN_DEFAULT_LMV == 00000000040000000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_DEFAULT_LMV);
 	LASSERTF(LUSTRE_SYNC_FL == 0x00000008UL, "found 0x%.8xUL\n",
 		(unsigned)LUSTRE_SYNC_FL);
 	LASSERTF(LUSTRE_IMMUTABLE_FL == 0x00000010UL, "found 0x%.8xUL\n",
@@ -4523,6 +4528,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct rsi_downcall_data, sid_val));
 	LASSERTF((int)sizeof(*((struct rsi_downcall_data *)0)->sid_val) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct rsi_downcall_data *)0)->sid_val));
+	BUILD_BUG_ON(offsetof(struct rsi_downcall_data, sid_val) != sizeof(struct rsi_downcall_data));
 
 	/* Checks for struct rsc_downcall_data */
 	LASSERTF((int)sizeof(struct rsc_downcall_data) == 48, "found %lld\n",
@@ -4571,6 +4577,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct rsc_downcall_data, scd_val));
 	LASSERTF((int)sizeof(*((struct rsc_downcall_data *)0)->scd_val) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct rsc_downcall_data *)0)->scd_val));
+	BUILD_BUG_ON(offsetof(struct rsc_downcall_data, scd_val) != sizeof(struct rsc_downcall_data));
 	LASSERTF(RSC_DATA_FLAG_REMOTE == 0x00000001UL, "found 0x%.8xUL\n",
 		(unsigned)RSC_DATA_FLAG_REMOTE);
 	LASSERTF(RSC_DATA_FLAG_ROOT == 0x00000002UL, "found 0x%.8xUL\n",
@@ -5085,8 +5092,8 @@ void lustre_assert_wire_constants(void)
 #ifndef HAVE_STRUCT_POSIX_ACL_XATTR
 	LASSERTF((int)offsetof(posix_acl_xattr_header, a_entries) == 4, "found %lld\n",
 		 (long long)(int)offsetof(posix_acl_xattr_header, a_entries));
-	LASSERTF((int)sizeof(((posix_acl_xattr_header *)0)->a_entries) == 0, "found %lld\n",
-		 (long long)(int)sizeof(((posix_acl_xattr_header *)0)->a_entries));
+	LASSERTF((int)sizeof(*((posix_acl_xattr_header *)0)->a_entries) == 8, "found %lld\n",
+		 (long long)(int)sizeof(*((posix_acl_xattr_header *)0)->a_entries));
 #endif /* HAVE_STRUCT_POSIX_ACL_XATTR */
 #endif /* CONFIG_FS_POSIX_ACL */
 
@@ -5130,6 +5137,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct link_ea_entry, lee_name));
 	LASSERTF((int)sizeof(*((struct link_ea_entry *)0)->lee_name) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct link_ea_entry *)0)->lee_name));
+	BUILD_BUG_ON(offsetof(struct link_ea_entry, lee_name) != sizeof(struct link_ea_entry));
 
 	/* Checks for struct layout_intent */
 	LASSERTF((int)sizeof(struct layout_intent) == 24, "found %lld\n",
@@ -5204,6 +5212,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct hsm_action_item, hai_data));
 	LASSERTF((int)sizeof(*((struct hsm_action_item *)0)->hai_data) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct hsm_action_item *)0)->hai_data));
+	BUILD_BUG_ON(offsetof(struct hsm_action_item, hai_data) != sizeof(struct hsm_action_item));
 
 	/* Checks for struct hsm_action_list */
 	LASSERTF((int)sizeof(struct hsm_action_list) == 32, "found %lld\n",
@@ -5497,6 +5506,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct hsm_user_request, hur_user_item));
 	LASSERTF((int)sizeof(*((struct hsm_user_request *)0)->hur_user_item) == 32, "found %lld\n",
 		 (long long)(int)sizeof(*((struct hsm_user_request *)0)->hur_user_item));
+	BUILD_BUG_ON(offsetof(struct hsm_user_request, hur_user_item) != sizeof(struct hsm_user_request));
 
 	/* Checks for struct hsm_user_import */
 	LASSERTF((int)sizeof(struct hsm_user_import) == 48, "found %lld\n",
@@ -5551,6 +5561,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct netobj_s, data));
 	LASSERTF((int)sizeof(*((struct netobj_s *)0)->data) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct netobj_s *)0)->data));
+	BUILD_BUG_ON(offsetof(struct netobj_s, data) != sizeof(struct netobj_s));
 
 	/* Checks for struct rawobj_s */
 	LASSERTF((int)sizeof(struct rawobj_s) == 16, "found %lld\n",
@@ -7020,6 +7031,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct update_params, up_params));
 	LASSERTF((int)sizeof(*((struct update_params *)0)->up_params) == 8, "found %lld\n",
 		 (long long)(int)sizeof(*((struct update_params *)0)->up_params));
+	BUILD_BUG_ON(offsetof(struct update_params, up_params) != sizeof(struct update_params));
 
 	/* Checks for struct update_op */
 	LASSERTF((int)sizeof(struct update_op) == 20, "found %lld\n",
@@ -7038,8 +7050,6 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)sizeof(((struct update_op *)0)->uop_param_count));
 	LASSERTF((int)offsetof(struct update_op, uop_params_off) == 20, "found %lld\n",
 		 (long long)(int)offsetof(struct update_op, uop_params_off));
-	LASSERTF((int)sizeof(*((struct update_op *)0)->uop_params_off) == 2, "found %lld\n",
-		 (long long)(int)sizeof(*((struct update_op *)0)->uop_params_off));
 
 	/* Checks for struct update_ops */
 	LASSERTF((int)sizeof(struct update_ops) == 0, "found %lld\n",
@@ -7048,6 +7058,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct update_ops, uops_op));
 	LASSERTF((int)sizeof(*((struct update_ops *)0)->uops_op) == 20, "found %lld\n",
 		 (long long)(int)sizeof(*((struct update_ops *)0)->uops_op));
+	BUILD_BUG_ON(offsetof(struct update_ops, uops_op) != sizeof(struct update_ops));
 
 	/* Checks for struct update_records */
 	LASSERTF((int)sizeof(struct update_records) == 32, "found %lld\n",
diff --git a/lustre/tests/sanity-zero.sh b/lustre/tests/sanity-zero.sh
index 543aec5521..7112ae77ac 100644
--- a/lustre/tests/sanity-zero.sh
+++ b/lustre/tests/sanity-zero.sh
@@ -297,6 +297,64 @@ test_3f() {
 }
 run_test 3f "DoM migration: OST-striped file to DOM file"
 
+test_10()
+{
+	stack_trap "rm -f $TMP/testfile $DIR/$tfile*" EXIT
+
+	dd if=/dev/urandom of=$TMP/testfile bs=1M count=3
+	$LFS setstripe -Z -c 2 $DIR/$tfile-1
+	$LFS setstripe -Z -c 2 $DIR/$tfile-2
+	dd if=/tmp/testfile of=$DIR/$tfile-1 bs=1M count=1 oflag=sync
+	dd if=/tmp/testfile of=$DIR/$tfile-2 bs=1M count=2 skip=1 oflag=sync
+	$LFS join $DIR/$tfile-1 $DIR/$tfile-2
+	cmp -b $TMP/testfile $DIR/$tfile-1 || error "data missmuch"
+
+}
+run_test 10 "join file simple layout"
+
+test_11()
+{
+	stack_trap "rm -f $TMP/testfile $DIR/$tfile*" EXIT
+	$LFS setstripe -Z -c 2 $DIR/$tfile-1
+	$LFS setstripe -Z -c 2 $DIR/$tfile-2
+
+	dd if=/dev/urandom of=$TMP/testfile bs=1M count=3
+	dd if=/tmp/testfile of=$DIR/$tfile-1 bs=1M count=1 oflag=sync
+	dd if=/tmp/testfile of=$DIR/$tfile-2 bs=1M count=2 skip=1 oflag=sync
+	$LFS join $DIR/$tfile-1 $DIR/$tfile-2
+	$LFS getstripe $DIR/$tfile-1
+	cmp -b $TMP/testfile $DIR/$tfile-1 || error "data missmuch"
+}
+run_test 11 "join file with extra component"
+
+test_12()
+{
+	stack_trap "rm -f $TMP/testfile $DIR/$tfile*" EXIT
+
+	dd if=/dev/urandom of=$TMP/testfile bs=1M count=3
+	$LFS setstripe -c 2 $DIR/$tfile-1
+	$LFS setstripe -Z -c 2 $DIR/$tfile-2
+	dd if=/tmp/testfile of=$DIR/$tfile-1 bs=1M count=1 oflag=sync
+	dd if=/tmp/testfile of=$DIR/$tfile-2 bs=1M count=2 skip=1 oflag=sync
+	$LFS join $DIR/$tfile-1 $DIR/$tfile-2
+	cmp -b $TMP/testfile $DIR/$tfile-1 || error "data missmuch"
+}
+run_test 12 "join file works with normal file first"
+
+test_13()
+{
+	stack_trap "rm -f $DIR/$tfile*" EXIT
+
+	$LFS setstripe -c 2 $DIR/$tfile-1
+	$LFS setstripe -c 2 $DIR/$tfile-2
+	$LFS join $DIR/$tfile-1 $DIR/$tfile-2
+	rc=$?
+	if [ $rc -eq 0 ]; then
+		error "join should failed with normal files"
+	fi
+}
+run_test 13 "join file works with normal file first"
+
 test_fsx() {
 	local file1=$DIR1/$tfile
 	local file2=$DIR2/$tfile
diff --git a/lustre/utils/Makefile.am b/lustre/utils/Makefile.am
index 0c9a3e0ee7..e152a194eb 100644
--- a/lustre/utils/Makefile.am
+++ b/lustre/utils/Makefile.am
@@ -118,7 +118,9 @@ liblustreapi_la_SOURCES = libhsm_scanner.c \
 			  liblustreapi_root.c \
 			  liblustreapi_swap.c \
 			  liblustreapi_util.c \
+			  liblustreapi_join.c \
 			  lustreapi_internal.h
+
 liblustreapi_la_CFLAGS = -fPIC -D_GNU_SOURCE $(LIBNL3_CFLAGS) \
 			 -I $(top_builddir)/lnet/utils \
 			 -D_LARGEFILE64_SOURCE=1 -D_FILE_OFFSET_BITS=64 \
diff --git a/lustre/utils/lfs.c b/lustre/utils/lfs.c
index aa4fc7dd3b..2db9c161f2 100644
--- a/lustre/utils/lfs.c
+++ b/lustre/utils/lfs.c
@@ -132,6 +132,7 @@ static int lfs_pcc_unpin(int argc, char **argv);
 static int lfs_pcc_state(int argc, char **argv);
 static int lfs_pcc_delete(int argc, char **argv);
 static int lfs_pcc(int argc, char **argv);
+static int lfs_join(int argc, char **argv);
 
 static int lfs_migrate_to_dom(int fd_src, int fd_dst, char *name,
 			      enum llapi_migration_flags migration_flags,
@@ -672,6 +673,7 @@ command_t cmdlist[] = {
 	 "lfs pcc delete - delete the PCC layout componenet for given files\n"
 	 "lfs pcc pin - pin give files for PCC\n"
 	 "lfs pcc unpin - unpin given files for PCC\n"},
+	{"join", lfs_join, 0, "join file as component\n" },
 	{ 0, 0, 0, NULL }
 };
 
@@ -15306,6 +15308,15 @@ static int lfs_pcc_unpin(int argc, char **argv)
 	return rc;
 }
 
+static int lfs_join(int argc, char **argv)
+{
+	if (argc != 3) {
+		fprintf(stderr, "not enough arguments\n");
+		return CMD_HELP;
+	}
+
+	return llapi_join_layouts(argv[1], argv[2], 0);
+}
 
 int main(int argc, char **argv)
 {
diff --git a/lustre/utils/liblustreapi_join.c b/lustre/utils/liblustreapi_join.c
new file mode 100644
index 0000000000..82f344072f
--- /dev/null
+++ b/lustre/utils/liblustreapi_join.c
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * LGPL HEADER START
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the GNU Lesser General Public License
+ * (LGPL) version 2.1 or (at your discretion) any later version.
+ * (LGPL) version 2.1 accompanies this distribution, and is available at
+ * http://www.gnu.org/licenses/lgpl-2.1.html
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * LGPL HEADER END
+ */
+/*
+ * Copyright (c) 2024 HP Enterprise
+ */
+/*
+ * This file is part of Lustre, http://www.lustre.org/
+ */
+/*
+ * lustreapi library for file layout join.
+ */
+
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <lustre/lustreapi.h>
+
+static int llapi_join_sanity_cb(struct llapi_layout *layout, void *cbdata)
+{
+	uint64_t pattern;
+	int rc;
+
+	rc = llapi_layout_pattern_get(layout, &pattern);
+	if (rc)
+		goto out_err;
+
+	/* only zero start may joined */
+	if (pattern != LLAPI_LAYOUT_ZEROSTART)
+		goto out_err;
+
+	return LLAPI_LAYOUT_ITER_CONT;
+
+out_err:
+	return -EINVAL;
+}
+
+/**
+ * move a second file as component for first one.
+ */
+int llapi_join_layouts(const char *path1, const char *path2, __u64 flags)
+{
+	int	dst_fd, comp_fd;
+	int	rc, rc1;
+	struct llapi_layout *dst_layout = NULL;
+	struct llapi_layout *comp_layout = NULL;
+	struct lustre_join_layouts ljl;
+	struct stat stbuf;
+	int	gid;
+	__u64 dv1;
+
+	dst_fd = open(path1, O_WRONLY | O_LOV_DELAY_CREATE);
+	if (dst_fd < 0) {
+		rc = -errno;
+		llapi_error(LLAPI_MSG_ERROR, rc,
+			    "error: cannot open '%s' for write", path1);
+		goto out;
+	}
+
+	comp_fd = open(path2, O_WRONLY | O_LOV_DELAY_CREATE);
+	if (comp_fd < 0) {
+		rc = -errno;
+		llapi_error(LLAPI_MSG_ERROR, rc,
+			    "error: cannot open '%s' for write", path2);
+		goto out_close;
+	}
+
+	/* storage component */
+	dst_layout = llapi_layout_get_by_fd(dst_fd, 0);
+	if (!dst_layout) {
+		rc = -errno;
+		llapi_error(LLAPI_MSG_ERROR, rc,
+			    "error: cannot get layout for '%s'", path1);
+		goto error_layout;
+	}
+
+
+	/* new component */
+	comp_layout = llapi_layout_get_by_fd(comp_fd, 0);
+	if (!comp_layout) {
+		rc = -errno;
+		llapi_error(LLAPI_MSG_ERROR, rc,
+			    "error: cannot get layout for '%s'", path2);
+		goto error_layout;
+	}
+
+	/* check all compoents has zero offset flag set */
+	errno = 0;
+	rc = llapi_layout_comp_iterate(comp_layout,
+				       llapi_join_sanity_cb,
+				       NULL);
+	if (rc)
+		goto error_layout;
+
+	/* ask to flush a data */
+	rc = llapi_get_data_version(dst_fd, &dv1, LL_DV_RD_FLUSH);
+	if (rc < 0) {
+		llapi_error(LLAPI_MSG_ERROR, rc, "cannot get dataversion");
+		goto error_layout;
+	}
+
+	do
+		gid = random();
+	while (gid == 0);
+
+	/* lets obtain a group locks to have a good stat. group lock for second
+	 * file don't needs once first EOF should be changed.
+	 */
+
+	/*
+	 * The grouplock blocks all concurrent accesses to the file.
+	 * It has to be taken after llapi_get_data_version as it would
+	 * block it too.
+	 */
+	rc = llapi_group_lock(dst_fd, gid);
+	if (rc < 0) {
+		llapi_error(LLAPI_MSG_ERROR, rc, "cannot get group lock %s\n",
+			    path1);
+		goto error_layout;
+	}
+
+	rc = fstat(dst_fd, &stbuf);
+	if (rc < 0) {
+		llapi_error(LLAPI_MSG_ERROR, rc, "cannot get stat for %s\n",
+			    path1);
+		goto error_lock;
+	}
+
+
+	ljl.sl_fd = comp_fd;
+	ljl.sl_flags = flags;
+	ljl.sl_size = stbuf.st_size;
+	rc = ioctl(dst_fd, LL_IOC_LOV_JOIN_LAYOUTS, &ljl);
+	if (rc < 0)
+		return -errno;
+
+error_lock:
+	/* give back group lock lets do it before unlink to avoid blocks on
+	 * group lock
+	 */
+	rc1 = llapi_group_unlock(dst_fd, gid);
+	if (rc1 < 0)
+		llapi_error(LLAPI_MSG_ERROR, rc1,
+			    "cannot put group lock on source %s", path1);
+
+	if (rc == 0) {
+		rc = unlink(path2);
+		if (rc)
+			llapi_error(LLAPI_MSG_ERROR, rc,
+				    "Unlink failed on %s\n", path2);
+	}
+
+error_layout:
+	if (comp_layout)
+		llapi_layout_free(comp_layout);
+	if (dst_layout)
+		llapi_layout_free(dst_layout);
+	close(comp_fd);
+out_close:
+	close(dst_fd);
+out:
+	return rc;
+}
diff --git a/lustre/utils/wirecheck.c b/lustre/utils/wirecheck.c
index 6132af25e1..55a8bd8bd7 100644
--- a/lustre/utils/wirecheck.c
+++ b/lustre/utils/wirecheck.c
@@ -3542,6 +3542,7 @@ main(int argc, char **argv)
 	CHECK_VALUE(MDS_RMFID);
 	CHECK_VALUE(MDS_BATCH);
 	CHECK_VALUE(MDS_HSM_DATA_VERSION);
+	CHECK_VALUE(MDS_JOIN_LAYOUTS);
 	CHECK_VALUE(MDS_LAST_OPC);
 
 	CHECK_VALUE(REINT_SETATTR);
diff --git a/lustre/utils/wiretest.c b/lustre/utils/wiretest.c
index ca7b5c497f..2a2a6d8cbc 100644
--- a/lustre/utils/wiretest.c
+++ b/lustre/utils/wiretest.c
@@ -191,8 +191,10 @@ void lustre_assert_wire_constants(void)
 	LASSERTF(MDS_BATCH == 63, "found %lld\n",
 		 (long long)MDS_BATCH);
 	LASSERTF(MDS_HSM_DATA_VERSION == 64, "found %lld\n",
-		 (long long)MDS_BATCH);
-	LASSERTF(MDS_LAST_OPC == 65, "found %lld\n",
+		 (long long)MDS_HSM_DATA_VERSION);
+	LASSERTF(MDS_JOIN_LAYOUTS == 65, "found %lld\n",
+		 (long long)MDS_JOIN_LAYOUTS);
+	LASSERTF(MDS_LAST_OPC == 66, "found %lld\n",
 		 (long long)MDS_LAST_OPC);
 	LASSERTF(REINT_SETATTR == 1, "found %lld\n",
 		 (long long)REINT_SETATTR);
@@ -823,6 +825,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct ladvise_hdr, lah_advise));
 	LASSERTF((int)sizeof(*((struct ladvise_hdr *)0)->lah_advise) == 32, "found %lld\n",
 		 (long long)(int)sizeof(*((struct ladvise_hdr *)0)->lah_advise));
+	BUILD_BUG_ON(offsetof(struct ladvise_hdr, lah_advise) != sizeof(struct ladvise_hdr));
 	BUILD_BUG_ON(LF_ASYNC != 0x00000001);
 	BUILD_BUG_ON(LF_UNSET != 0x00000002);
 	BUILD_BUG_ON(LADVISE_MAGIC != 0x1adf1ce0);
@@ -1846,6 +1849,8 @@ void lustre_assert_wire_constants(void)
 		(unsigned)LOV_PATTERN_MDT);
 	LASSERTF(LOV_PATTERN_OVERSTRIPING == 0x00000200UL, "found 0x%.8xUL\n",
 		(unsigned)LOV_PATTERN_OVERSTRIPING);
+	LASSERTF(LOV_PATTERN_ZEROSTART == 0x00001000UL, "found 0x%.8xUL\n",
+		(unsigned)LOV_PATTERN_ZEROSTART);
 
 	/* Checks for struct lov_foreign_md */
 	LASSERTF((int)sizeof(struct lov_foreign_md) == 16, "found %lld\n",
@@ -2736,36 +2741,36 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct mdt_body, mbo_padding_10));
 	LASSERTF((int)sizeof(((struct mdt_body *)0)->mbo_padding_10) == 8, "found %lld\n",
 		 (long long)(int)sizeof(((struct mdt_body *)0)->mbo_padding_10));
-	LASSERTF(MDS_FMODE_CLOSED  == 0000000000000000000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_FMODE_CLOSED);
-	LASSERTF(MDS_FMODE_EXEC == 0000000000000000000000004UL,
-		 "found 0%.22lloUL\n", (long long)MDS_FMODE_EXEC);
-	LASSERTF(MDS_OPEN_CREATED == 0000000000000000000000010UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_CREATED);
-	LASSERTF(MDS_OPEN_CREAT == 0000000000000000000000100UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_CREAT);
-	LASSERTF(MDS_OPEN_EXCL == 0000000000000000000000200UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_EXCL);
-	LASSERTF(MDS_OPEN_TRUNC == 0000000000000000000001000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_TRUNC);
-	LASSERTF(MDS_OPEN_APPEND == 0000000000000000000002000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_APPEND);
-	LASSERTF(MDS_OPEN_SYNC == 0000000000000000000010000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_SYNC);
-	LASSERTF(MDS_OPEN_DIRECTORY == 0000000000000000000200000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_DIRECTORY);
-	LASSERTF(MDS_OPEN_BY_FID == 0000000000000000040000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_BY_FID);
-	LASSERTF(MDS_OPEN_DELAY_CREATE == 0000000000000000100000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_DELAY_CREATE);
-	LASSERTF(MDS_OPEN_OWNEROVERRIDE == 0000000000000000200000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_OWNEROVERRIDE);
-	LASSERTF(MDS_OPEN_LOCK == 0000000000000004000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_LOCK);
-	LASSERTF(MDS_OPEN_HAS_EA == 0000000000000010000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_HAS_EA);
-	LASSERTF(MDS_OPEN_HAS_OBJS == 0000000000000020000000000UL,
-		 "found 0%.22lloUL\n", (long long)MDS_OPEN_HAS_OBJS);
+	LASSERTF(MDS_FMODE_CLOSED == 00000000000000000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_FMODE_CLOSED);
+	LASSERTF(MDS_FMODE_EXEC == 00000000000000000000004ULL, "found 0%.22lloULL\n",
+			(long long)MDS_FMODE_EXEC);
+	LASSERTF(MDS_OPEN_CREATED == 00000000000000000000010ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_CREATED);
+	LASSERTF(MDS_OPEN_CREAT == 00000000000000000000100ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_CREAT);
+	LASSERTF(MDS_OPEN_EXCL == 00000000000000000000200ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_EXCL);
+	LASSERTF(MDS_OPEN_TRUNC == 00000000000000000001000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_TRUNC);
+	LASSERTF(MDS_OPEN_APPEND == 00000000000000000002000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_APPEND);
+	LASSERTF(MDS_OPEN_SYNC == 00000000000000000010000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_SYNC);
+	LASSERTF(MDS_OPEN_DIRECTORY == 00000000000000000200000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_DIRECTORY);
+	LASSERTF(MDS_OPEN_BY_FID == 00000000000000040000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_BY_FID);
+	LASSERTF(MDS_OPEN_DELAY_CREATE == 00000000000000100000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_DELAY_CREATE);
+	LASSERTF(MDS_OPEN_OWNEROVERRIDE == 00000000000000200000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_OWNEROVERRIDE);
+	LASSERTF(MDS_OPEN_LOCK == 00000000000004000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_LOCK);
+	LASSERTF(MDS_OPEN_HAS_EA == 00000000000010000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_HAS_EA);
+	LASSERTF(MDS_OPEN_HAS_OBJS == 00000000000020000000000ULL, "found 0%.22lloULL\n",
+			(long long)MDS_OPEN_HAS_OBJS);
 	LASSERTF(MDS_OPEN_NORESTORE == 00000000000100000000000ULL, "found 0%.22lloULL\n",
 			(long long)MDS_OPEN_NORESTORE);
 	LASSERTF(MDS_OPEN_NEWSTRIPE == 00000000000200000000000ULL, "found 0%.22lloULL\n",
@@ -4548,6 +4553,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct rsi_downcall_data, sid_val));
 	LASSERTF((int)sizeof(*((struct rsi_downcall_data *)0)->sid_val) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct rsi_downcall_data *)0)->sid_val));
+	BUILD_BUG_ON(offsetof(struct rsi_downcall_data, sid_val) != sizeof(struct rsi_downcall_data));
 
 	/* Checks for struct rsc_downcall_data */
 	LASSERTF((int)sizeof(struct rsc_downcall_data) == 48, "found %lld\n",
@@ -4596,6 +4602,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct rsc_downcall_data, scd_val));
 	LASSERTF((int)sizeof(*((struct rsc_downcall_data *)0)->scd_val) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct rsc_downcall_data *)0)->scd_val));
+	BUILD_BUG_ON(offsetof(struct rsc_downcall_data, scd_val) != sizeof(struct rsc_downcall_data));
 	LASSERTF(RSC_DATA_FLAG_REMOTE == 0x00000001UL, "found 0x%.8xUL\n",
 		(unsigned)RSC_DATA_FLAG_REMOTE);
 	LASSERTF(RSC_DATA_FLAG_ROOT == 0x00000002UL, "found 0x%.8xUL\n",
@@ -5110,8 +5117,8 @@ void lustre_assert_wire_constants(void)
 #ifndef HAVE_STRUCT_POSIX_ACL_XATTR
 	LASSERTF((int)offsetof(posix_acl_xattr_header, a_entries) == 4, "found %lld\n",
 		 (long long)(int)offsetof(posix_acl_xattr_header, a_entries));
-	LASSERTF((int)sizeof(((posix_acl_xattr_header *)0)->a_entries) == 0, "found %lld\n",
-		 (long long)(int)sizeof(((posix_acl_xattr_header *)0)->a_entries));
+	LASSERTF((int)sizeof(*((posix_acl_xattr_header *)0)->a_entries) == 8, "found %lld\n",
+		 (long long)(int)sizeof(*((posix_acl_xattr_header *)0)->a_entries));
 #endif /* HAVE_STRUCT_POSIX_ACL_XATTR */
 #endif /* CONFIG_FS_POSIX_ACL */
 
@@ -5155,6 +5162,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct link_ea_entry, lee_name));
 	LASSERTF((int)sizeof(*((struct link_ea_entry *)0)->lee_name) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct link_ea_entry *)0)->lee_name));
+	BUILD_BUG_ON(offsetof(struct link_ea_entry, lee_name) != sizeof(struct link_ea_entry));
 
 	/* Checks for struct layout_intent */
 	LASSERTF((int)sizeof(struct layout_intent) == 24, "found %lld\n",
@@ -5229,6 +5237,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct hsm_action_item, hai_data));
 	LASSERTF((int)sizeof(*((struct hsm_action_item *)0)->hai_data) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct hsm_action_item *)0)->hai_data));
+	BUILD_BUG_ON(offsetof(struct hsm_action_item, hai_data) != sizeof(struct hsm_action_item));
 
 	/* Checks for struct hsm_action_list */
 	LASSERTF((int)sizeof(struct hsm_action_list) == 32, "found %lld\n",
@@ -5522,6 +5531,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct hsm_user_request, hur_user_item));
 	LASSERTF((int)sizeof(*((struct hsm_user_request *)0)->hur_user_item) == 32, "found %lld\n",
 		 (long long)(int)sizeof(*((struct hsm_user_request *)0)->hur_user_item));
+	BUILD_BUG_ON(offsetof(struct hsm_user_request, hur_user_item) != sizeof(struct hsm_user_request));
 
 	/* Checks for struct hsm_user_import */
 	LASSERTF((int)sizeof(struct hsm_user_import) == 48, "found %lld\n",
@@ -5576,6 +5586,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct netobj_s, data));
 	LASSERTF((int)sizeof(*((struct netobj_s *)0)->data) == 1, "found %lld\n",
 		 (long long)(int)sizeof(*((struct netobj_s *)0)->data));
+	BUILD_BUG_ON(offsetof(struct netobj_s, data) != sizeof(struct netobj_s));
 
 	/* Checks for struct rawobj_s */
 	LASSERTF((int)sizeof(struct rawobj_s) == 16, "found %lld\n",
@@ -7045,6 +7056,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct update_params, up_params));
 	LASSERTF((int)sizeof(*((struct update_params *)0)->up_params) == 8, "found %lld\n",
 		 (long long)(int)sizeof(*((struct update_params *)0)->up_params));
+	BUILD_BUG_ON(offsetof(struct update_params, up_params) != sizeof(struct update_params));
 
 	/* Checks for struct update_op */
 	LASSERTF((int)sizeof(struct update_op) == 20, "found %lld\n",
@@ -7063,8 +7075,6 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)sizeof(((struct update_op *)0)->uop_param_count));
 	LASSERTF((int)offsetof(struct update_op, uop_params_off) == 20, "found %lld\n",
 		 (long long)(int)offsetof(struct update_op, uop_params_off));
-	LASSERTF((int)sizeof(*((struct update_op *)0)->uop_params_off) == 2, "found %lld\n",
-		 (long long)(int)sizeof(*((struct update_op *)0)->uop_params_off));
 
 	/* Checks for struct update_ops */
 	LASSERTF((int)sizeof(struct update_ops) == 0, "found %lld\n",
@@ -7073,6 +7083,7 @@ void lustre_assert_wire_constants(void)
 		 (long long)(int)offsetof(struct update_ops, uops_op));
 	LASSERTF((int)sizeof(*((struct update_ops *)0)->uops_op) == 20, "found %lld\n",
 		 (long long)(int)sizeof(*((struct update_ops *)0)->uops_op));
+	BUILD_BUG_ON(offsetof(struct update_ops, uops_op) != sizeof(struct update_ops));
 
 	/* Checks for struct update_records */
 	LASSERTF((int)sizeof(struct update_records) == 32, "found %lld\n",

</pre>
</body>
</html>
