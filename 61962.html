<html lang="en">
<body>
<pre>
From b3b80f80f0dae4878985e2c09f2e4b06abbf165c Mon Sep 17 00:00:00 2001
From: Patrick Farrell <pfarrell@whamcloud.com>
Date: Fri, 1 Aug 2025 15:50:03 -0400
Subject: [PATCH 1/1] LU-12187 llapi: EC layout creation support

Client changes to allow validation of ECed layouts in llapi.  This is
purely for the llapi support and we cannot create ECed layout files
yet.

Signed-off-by: Patrick Farrell <pfarrell@whamcloud.com>
Signed-off-by: Bobi Jam <bobijam@whamcloud.com>
Change-Id: I65ec3246642058b5adb0791eff6940626950b076
---
 lustre/include/lustre/lustreapi.h             |   11 +
 .../include/uapi/linux/lustre/lustre_user.h   |   33 +-
 lustre/lod/lod_lov.c                          |    4 +-
 lustre/lod/lod_object.c                       |    2 +-
 lustre/lod/lod_qos.c                          |    2 +-
 lustre/lov/lov_ea.c                           |    8 +-
 lustre/lov/lov_internal.h                     |   14 +
 lustre/ptlrpc/pack_generic.c                  |    6 +
 lustre/tests/llapi_layout_test.c              | 1124 ++++++++++++++++-
 lustre/tests/llapi_test_utils.c               |    5 +-
 lustre/utils/liblustreapi.c                   |    2 +-
 lustre/utils/liblustreapi_layout.c            |  287 ++++-
 12 files changed, 1458 insertions(+), 40 deletions(-)

diff --git a/lustre/include/lustre/lustreapi.h b/lustre/include/lustre/lustreapi.h
index 84329259af..9a0f940b5b 100644
--- a/lustre/include/lustre/lustreapi.h
+++ b/lustre/include/lustre/lustreapi.h
@@ -1375,6 +1375,17 @@ int llapi_layout_mirror_id_get(const struct llapi_layout *layout, uint32_t *id);
  * Adds one component to the existing composite or plain layout.
  */
 int llapi_layout_comp_add(struct llapi_layout *layout);
+/**
+ * Adds one component to the existing composite or plain layout with extent.
+ */
+int llapi_layout_comp_add_extent(struct llapi_layout *layout,
+				 uint64_t start, uint64_t end);
+/**
+ * Adds one EC component to the existing composite or plain layout.
+ */
+int llapi_layout_comp_add_ec(struct llapi_layout *layout,
+			     uint64_t start, uint64_t end,
+			     uint8_t dstripe_count, uint8_t cstripe_count);
 /**
  * Adds a first component of a mirror to the existing composite layout.
  */
diff --git a/lustre/include/uapi/linux/lustre/lustre_user.h b/lustre/include/uapi/linux/lustre/lustre_user.h
index ced4b58b5e..506e98c3ad 100644
--- a/lustre/include/uapi/linux/lustre/lustre_user.h
+++ b/lustre/include/uapi/linux/lustre/lustre_user.h
@@ -801,6 +801,7 @@ enum lov_pattern {
 #define LOV_OFFSET_DEFAULT      ((__u16)-1)
 #define LMV_OFFSET_DEFAULT      ((__u32)-1)
 
+/* current client IO only understand these patterns */
 static inline bool lov_pattern_supported(enum lov_pattern pattern)
 {
 	enum lov_pattern pattern_base = pattern & ~LOV_PATTERN_F_RELEASED;
@@ -810,6 +811,17 @@ static inline bool lov_pattern_supported(enum lov_pattern pattern)
 	       pattern_base == LOV_PATTERN_MDT;
 }
 
+/* but we can set and server allows for these patterns */
+static inline bool layout_pattern_supported(enum lov_pattern pattern)
+{
+	enum lov_pattern pattern_base = pattern & ~LOV_PATTERN_F_RELEASED;
+
+	return pattern_base == LOV_PATTERN_RAID0 ||
+	       pattern_base == (LOV_PATTERN_RAID0 | LOV_PATTERN_OVERSTRIPING) ||
+	       pattern_base == (LOV_PATTERN_RAID0 | LOV_PATTERN_PARITY) ||
+	       pattern_base == LOV_PATTERN_MDT;
+}
+
 /* RELEASED and MDT patterns are not valid in many places, so rather than
  * having many extra checks on lov_pattern_supported, we have this separate
  * check for non-released, non-readonly, non-DOM components
@@ -1009,7 +1021,7 @@ enum lov_comp_md_entry_flags {
  * from the default/template layout set on a directory.
  */
 #define LCME_TEMPLATE_FLAGS	(LCME_FL_PREF_RW | LCME_FL_NOSYNC | \
-				 LCME_FL_EXTENSION)
+				 LCME_FL_EXTENSION | LCME_FL_PARITY)
 
 /* lcme_id can be specified as certain flags, and the first
  * bit of lcme_id is used to indicate that the ID is representing
@@ -1080,6 +1092,25 @@ static inline __u16 mirror_id_of(__u32 id)
 	return (id & MIRROR_ID_MASK) >> MIRROR_ID_SHIFT;
 }
 
+static inline int layout_ec_verify_stripes(__u8 dstripe_count,
+					   __u8 cstripe_count)
+{
+	/* Validate stripe counts */
+	if (cstripe_count == 0 || dstripe_count == 0)
+		return -EINVAL;
+
+	/* Validate EC parameter constraints */
+	if (cstripe_count >= dstripe_count)
+		/* Coding stripes cannot equal or exceed data stripes */
+		return -EINVAL;
+
+	if (dstripe_count < 2)
+		/* Need at least 2 data stripes for EC to make sense */
+		return -EINVAL;
+
+	return 0;
+}
+
 /**
  * on-disk data for lcm_flags. Valid if lcm_magic is LOV_MAGIC_COMP_V1.
  */
diff --git a/lustre/lod/lod_lov.c b/lustre/lod/lod_lov.c
index 193b82c12b..385596a77c 100644
--- a/lustre/lod/lod_lov.c
+++ b/lustre/lod/lod_lov.c
@@ -1415,7 +1415,7 @@ int lod_parse_striping(const struct lu_env *env, struct lod_object *lo,
 		}
 
 		pattern = le32_to_cpu(lmm->lmm_pattern);
-		if (!lov_pattern_supported(lov_pattern(pattern)))
+		if (!layout_pattern_supported(lov_pattern(pattern)))
 			GOTO(out, rc = -EINVAL);
 
 		if (pattern & LOV_PATTERN_MDT) {
@@ -1728,7 +1728,7 @@ static int lod_verify_v1v3(struct lod_device *d, const struct lu_buf *buf,
 	if (!is_from_disk && lum->lmm_pattern == LOV_PATTERN_NONE)
 		lum->lmm_pattern = cpu_to_le32(LOV_PATTERN_RAID0);
 
-	if (!lov_pattern_supported(le32_to_cpu(lum->lmm_pattern))) {
+	if (!layout_pattern_supported(le32_to_cpu(lum->lmm_pattern))) {
 		CDEBUG(D_LAYOUT, "bad userland stripe pattern: %#x\n",
 		       le32_to_cpu(lum->lmm_pattern));
 		GOTO(out, rc = -EINVAL);
diff --git a/lustre/lod/lod_object.c b/lustre/lod/lod_object.c
index a46ef8c52c..2272e2421d 100644
--- a/lustre/lod/lod_object.c
+++ b/lustre/lod/lod_object.c
@@ -5444,7 +5444,7 @@ static int lod_get_default_lov_striping(const struct lu_env *env,
 		       v1->lmm_stripe_size, (__s16)v1->lmm_stripe_offset,
 		       append_pool ?: "", append_stripe_count);
 
-		if (!lov_pattern_supported(v1->lmm_pattern) &&
+		if (!layout_pattern_supported(v1->lmm_pattern) &&
 		    !(v1->lmm_pattern & LOV_PATTERN_F_RELEASED)) {
 			lod_free_def_comp_entries(lds);
 			RETURN(-EINVAL);
diff --git a/lustre/lod/lod_qos.c b/lustre/lod/lod_qos.c
index 975f720758..14ba745509 100644
--- a/lustre/lod/lod_qos.c
+++ b/lustre/lod/lod_qos.c
@@ -2573,7 +2573,7 @@ int lod_qos_parse_config(const struct lu_env *env, struct lod_object *lo,
 
 		if (v1->lmm_pattern == 0)
 			v1->lmm_pattern = LOV_PATTERN_RAID0;
-		if (!lov_pattern_supported(lov_pattern(v1->lmm_pattern))) {
+		if (!layout_pattern_supported(lov_pattern(v1->lmm_pattern))) {
 			CDEBUG(D_LAYOUT, "%s: invalid pattern: %x\n",
 			       lod2obd(d)->obd_name, v1->lmm_pattern);
 			GOTO(free_comp, rc = -EINVAL);
diff --git a/lustre/lov/lov_ea.c b/lustre/lov/lov_ea.c
index ced3e2cc34..847d79f39a 100644
--- a/lustre/lov/lov_ea.c
+++ b/lustre/lov/lov_ea.c
@@ -77,7 +77,7 @@ static int lsm_lmm_verify_v1v3(struct lov_mds_md *lmm, size_t lmm_size,
 		goto out;
 	}
 
-	if (!lov_pattern_supported(lov_pattern(pattern))) {
+	if (!layout_pattern_supported(lov_pattern(pattern))) {
 		static int nr;
 		static ktime_t time2_clear_nr;
 		ktime_t now = ktime_get();
@@ -131,7 +131,7 @@ static void lsme_free(struct lov_stripe_md_entry *lsme)
 	if (!lsme_inited(lsme) ||
 	    lsme->lsme_pattern & LOV_PATTERN_F_RELEASED ||
 	    !lov_supported_comp_magic(lsme->lsme_magic) ||
-	    !lov_pattern_supported(lov_pattern(lsme->lsme_pattern)))
+	    !layout_pattern_supported(lov_pattern(lsme->lsme_pattern)))
 		stripe_count = 0;
 	for (i = 0; i < stripe_count; i++)
 		OBD_SLAB_FREE_PTR(lsme->lsme_oinfo[i], lov_oinfo_slab);
@@ -189,7 +189,7 @@ lsme_unpack(struct lov_obd *lov, struct lov_mds_md *lmm, size_t buf_size,
 
 	pattern = le32_to_cpu(lmm->lmm_pattern);
 	if (pattern & LOV_PATTERN_F_RELEASED || !inited ||
-	    !lov_pattern_supported(lov_pattern(pattern)))
+	    !layout_pattern_supported(lov_pattern(pattern)))
 		stripe_count = 0;
 	else
 		stripe_count = le16_to_cpu(lmm->lmm_stripe_count);
@@ -758,7 +758,7 @@ void dump_lsm(unsigned int level, const struct lov_stripe_md *lsm)
 			if (!lsme_inited(lse) ||
 			    lse->lsme_pattern & LOV_PATTERN_F_RELEASED ||
 			    !lov_supported_comp_magic(lse->lsme_magic) ||
-			    !lov_pattern_supported(
+			    !layout_pattern_supported(
 				    	lov_pattern(lse->lsme_pattern)))
 				continue;
 			for (j = 0; j < lse->lsme_stripe_count; j++) {
diff --git a/lustre/lov/lov_internal.h b/lustre/lov/lov_internal.h
index 21e83e2c36..89da172095 100644
--- a/lustre/lov/lov_internal.h
+++ b/lustre/lov/lov_internal.h
@@ -33,9 +33,12 @@ struct lov_stripe_md_entry {
 	u64			lsme_timestamp;
 	union {
 		struct { /* For stripe objects */
+			/* EC info */
 			u32	lsme_stripe_size;
 			u16	lsme_stripe_count;
 			u16	lsme_layout_gen;
+			u8	lsme_dstripe_count;
+			u8	lsme_cstripe_count;
 			char	lsme_pool_name[LOV_MAXPOOLNAME + 1];
 			struct lov_oinfo	*lsme_oinfo[];
 		};
@@ -99,6 +102,17 @@ struct lov_stripe_md {
 
 #define lsm_foreign(lsm) (lsm->lsm_entries[0])
 
+static inline bool lsme_is_parity(const struct lov_stripe_md_entry *lsme)
+{
+	return lsme->lsme_flags & LCME_FL_PARITY;
+}
+
+static inline bool lsm_entry_is_parity(const struct lov_stripe_md *lsm,
+					int index)
+{
+	return lsme_is_parity(lsm->lsm_entries[index]);
+}
+
 static inline bool lsme_is_foreign(const struct lov_stripe_md_entry *lsme)
 {
 	return lsme->lsme_magic == LOV_MAGIC_FOREIGN;
diff --git a/lustre/ptlrpc/pack_generic.c b/lustre/ptlrpc/pack_generic.c
index 07d8693f77..4c4736ba01 100644
--- a/lustre/ptlrpc/pack_generic.c
+++ b/lustre/ptlrpc/pack_generic.c
@@ -2457,6 +2457,12 @@ void lustre_print_user_md(unsigned int lvl, struct lov_user_md *lum,
 		if (ent->lcme_flags & LCME_FL_NOSYNC)
 			CDEBUG(lvl, "\tlcme_timestamp: %llu\n",
 					ent->lcme_timestamp);
+		if (ent->lcme_flags & LCME_FL_PARITY) {
+			CDEBUG(lvl, "\tlcme_dstripe_count: %#x\n",
+			       ent->lcme_dstripe_count);
+			CDEBUG(lvl, "\tlcme_cstripe_count: %#x\n",
+			       ent->lcme_cstripe_count);
+		}
 		CDEBUG(lvl, "\tlcme_extent.e_start: %llu\n",
 		       ent->lcme_extent.e_start);
 		CDEBUG(lvl, "\tlcme_extent.e_end: %llu\n",
diff --git a/lustre/tests/llapi_layout_test.c b/lustre/tests/llapi_layout_test.c
index b51ee39dfa..9bf5b0225f 100644
--- a/lustre/tests/llapi_layout_test.c
+++ b/lustre/tests/llapi_layout_test.c
@@ -34,6 +34,16 @@ static char lustre_dir[PATH_MAX - 5];	/* Lustre test directory */
 
 #define IN_RANGE(value, low, high) ((value >= low) && (value <= high))
 
+/* Layout sanity error codes - should match liblustreapi_layout.c */
+#define LSE_NOT_ADJACENT_PREV 12
+
+#define LAYOUT_ASSERTF(cond, rc, fmt, ...)					\
+do {									\
+	if (!(cond))							\
+		llapi_layout_sanity_perror(rc);				\
+	ASSERTF(cond, fmt, ## __VA_ARGS__);				\
+} while (0)
+
 static void usage(char *prog)
 {
 	printf("Usage: %s [-d lustre_dir] [-p pool_name] [-o num_osts] "
@@ -1340,7 +1350,8 @@ static void test30(void)
 	rc = llapi_layout_comp_extent_set(layout, start[1] * 2, end[1]);
 	ASSERTF(rc == 0, "errno %d", errno);
 	rc = llapi_layout_sanity(layout, false, false);
-	ASSERTF(rc == 12 /*LSE_NOT_ADJACENT_PREV*/, "rc %d", rc);
+	LAYOUT_ASSERTF(rc == LSE_NOT_ADJACENT_PREV, rc, "errno = %d",
+		       errno);
 
 	rc = llapi_layout_comp_extent_set(layout, start[1], end[1]);
 	ASSERTF(rc == 0, "errno %d", errno);
@@ -1707,7 +1718,7 @@ static void test34(void)
 	ASSERTF(layout != NULL, "errno = %d", errno);
 
 	rc = llapi_layout_sanity(layout, false, false);
-	ASSERTF(rc == 0, "errno %d", errno);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno %d", errno);
 }
 
 #define T35FILE		"f35"
@@ -1725,8 +1736,6 @@ static void test35(void)
 	int rc;
 
 	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T35FILE);
-	fd = open(path, O_RDWR |  O_CREAT | O_LOV_DELAY_CREATE, 0640);
-	ASSERTF(fd >= 0, "failed to create " T35FILE);
 
 	layout = llapi_layout_alloc();
 	ASSERTF(layout != NULL, "failed to allocate layout structure");
@@ -1734,10 +1743,14 @@ static void test35(void)
 	llapi_layout_stripe_size_set(layout, T35_STRIPE_SIZE);
 	llapi_layout_pool_name_set(layout, poolname);
 
-	rc = llapi_layout_set_by_fd(fd, layout);
-	ASSERTF(rc == 0, "llapi_layout_set_by_fd failed");
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "failed to create " T35FILE);
+
+	llapi_layout_free(layout);
+
+	layout = llapi_layout_get_by_fd(fd, 0);
+	ASSERTF(layout != NULL , "failed to get layout");
 
-	layout = llapi_layout_get_by_fd(fd, O_RDWR);
 
 	rc = llapi_layout_stripe_count_get(layout, &count);
 	ASSERTF(rc == 0 && count == T35_STRIPE_COUNT, "invalid stripe count");
@@ -1748,6 +1761,1085 @@ static void test35(void)
 	rc = llapi_layout_pool_name_get(layout, mypool, sizeof(mypool));
 	ASSERTF(rc == 0, "error reading pool name");
 	ASSERTF(strcmp(mypool, poolname) == 0, "invalid pool name");
+
+	llapi_layout_free(layout);
+	close(fd);
+}
+
+#define T40_DESC	"verify LCME_FL_PARITY cannot be set with flags_set function"
+static void test40(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create a layout with one data component */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Add a regular component with explicit extent */
+	rc = llapi_layout_comp_add_extent(layout, 0, LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Try to set LCME_FL_PARITY flag - this should fail */
+	rc = llapi_layout_comp_flags_set(layout, LCME_FL_PARITY);
+	ASSERTF(rc != 0,
+		"Setting LCME_FL_PARITY with flags_set should fail but succeeded");
+
+	llapi_layout_free(layout);
+}
+
+#define T41_DESC	"verify comp_add_opts parameter validation for EC components"
+static void test41(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Try to add EC component with zero cstripe/dstripe */
+	rc = llapi_layout_comp_add_ec(layout, 0, LUSTRE_EOF, 0, 0);
+	ASSERTF(rc != 0,
+		"Parity component with zero cstripe/dstripe should fail but succeeded");
+
+	llapi_layout_free(layout);
+}
+
+#define T42_DESC	"verify parity component with non-matching extent fails"
+static void test42(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create layout with data mirror and EC mirror */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data component [0, EOF] */
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC component with different extent [0, 10MiB] */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Try to add EC component with different extent [0, 10MiB] */
+	rc = llapi_layout_comp_add_ec(layout, 0, 10*1024*1024, 6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validation should catch the mismatch */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc != 0, rc,
+		       "Layout sanity should fail for non-matching extent");
+
+	llapi_layout_free(layout);
+}
+
+#define T43_DESC	"verify EC component cannot be added to incomplete layout"
+static void test43(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create layout with incomplete data mirror: [0, 1GiB] (doesn't go
+	 * to EOF)
+	 */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Incomplete data component [0, 1GiB] */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Try to add EC parity component - creation should succeed but
+	 * validation should fail
+	 */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "EC component creation should succeed: errno = %d",
+		errno);
+
+	/* Validation should catch the incomplete layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc != 0, rc,
+		       "EC component on incomplete layout should fail validation");
+
+	llapi_layout_free(layout);
+}
+
+#define T44_DESC	"verify EC components with zero stripe counts are rejected"
+static void test44(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create a complete layout first */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* COMP1: [0, 1GiB] */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP2: [1GiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					   LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Test 1: cstripe_count = 0, dstripe_count > 0 (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 0);
+	ASSERTF(rc != 0, "EC component with zero coding stripes should fail");
+
+	/* Test 2: cstripe_count > 0, dstripe_count = 0 (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 0, 2);
+	ASSERTF(rc != 0, "EC component with zero data stripes should fail");
+
+	/* Test 3: cstripe_count = 0, dstripe_count = 0 (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 0, 0);
+	ASSERTF(rc != 0, "EC component with zero stripe counts should fail");
+
+	llapi_layout_free(layout);
+}
+
+#define T45_DESC	"verify overlapping EC extents are rejected"
+static void test45(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create layout: COMP1[0-1GB], COMP2[1GB-2GB], COMP3[2GB-EOF] */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* COMP1: [0, 1GiB] */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP2: [1GiB, 2GiB] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					   2*1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP3: [2GiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 8);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 2*1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Add first EC component: [0, 1GiB] */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Try to add overlapping EC component: [512MiB, 1.5GiB] */
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL,
+				      1536*1024*1024ULL, 6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validation should catch the overlap */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc != 0, rc,
+		       "Overlapping EC component should fail validation");
+
+	llapi_layout_free(layout);
+}
+
+#define T46_DESC	"verify invalid EC extent ranges are rejected"
+static void test46(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create a complete layout first */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* COMP1: [0, 1GiB] */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP2: [1GiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Test 1: start > end (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL,
+				      512*1024*1024ULL, 4, 2);
+	ASSERTF(rc != 0, "EC component with start > end should fail");
+
+	/* Test 2: start == end (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL,
+				      512*1024*1024ULL, 4, 2);
+	ASSERTF(rc != 0, "EC component with start == end should fail");
+
+	/* Test 3: start == LUSTRE_EOF (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, LUSTRE_EOF, LUSTRE_EOF, 4, 2);
+	ASSERTF(rc != 0, "EC component with start == LUSTRE_EOF should fail");
+
+	llapi_layout_free(layout);
+}
+
+#define T47_DESC	"verify EC parameter constraints are enforced"
+static void test47(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create a complete layout first */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* COMP1: [0, 1GiB] */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP2: [1GiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Test 1: cstripe_count >= dstripe_count (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 4);
+	ASSERTF(rc != 0, "EC component with cstripe >= dstripe should fail");
+
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 5);
+	ASSERTF(rc != 0, "EC component with cstripe > dstripe should fail");
+
+	/* Test 2: dstripe_count < 2 (should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 1, 1);
+	ASSERTF(rc != 0, "EC component with dstripe < 2 should fail");
+
+	/* Test 3: Valid parameters (should succeed) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T48_DESC	"verify duplicate EC components are rejected"
+static void test48(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Create layout with data mirror and EC mirror */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components */
+	/* M1 COMP1: [0, 1GiB] */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [1GiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC components */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Add first EC component: [0, 1GiB] */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Try to add duplicate EC component: [0, 1GiB] */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validation should catch the duplicate */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc != 0, rc,
+		       "Duplicate EC component should fail validation");
+
+	/* Try to add overlapping EC component: [512MiB, 1.5GiB] */
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL,
+				      1536*1024*1024ULL, 6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validation should catch the overlap */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc != 0, rc,
+		       "Overlapping EC component should fail validation");
+
+	/* Add non-overlapping EC component: [1GiB, EOF] */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T49_DESC	"verify API parameter validation and error handling"
+static void test49(void)
+{
+	int rc;
+	struct llapi_layout *layout;
+
+	/* Test 1: NULL layout pointer (should fail) */
+	rc = llapi_layout_comp_add_ec(NULL, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc != 0, "NULL layout should fail but succeeded");
+
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Test 2: start == end (zero-length extent, should fail) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL,
+				      1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc != 0, "Zero-length extent should fail but succeeded");
+
+	llapi_layout_free(layout);
+}
+
+#define T50FILE		"f50"
+#define T50_DESC	"create simple EC layout with data and parity components"
+static void test50(void)
+{
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+	int fd;
+	int rc;
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T50FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create a layout with one data mirror and one EC mirror */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data component [0, EOF] with 6 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC component [0, EOF] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 0, LUSTRE_EOF, 6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (2 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T51FILE		"f51"
+#define T51_DESC	"verify multiple data + multiple parity components layout"
+static void test51(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T51FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout with data mirror and EC mirror, each with 2
+	 * components
+	 */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components */
+	/* M1 COMP1: [0, 1GiB] with 4 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [1GiB, EOF] with 6 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC components matching Mirror 1 extents */
+	/* M2 EC1: [0, 1GiB] with EC(2,4) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC2: [1GiB, EOF] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (2 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T52FILE		"f52"
+#define T52_DESC	"verify complex multi-component EC layout"
+static void test52(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T52FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout with data mirror and EC mirror, each with 4
+	 * components
+	 */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components */
+	/* M1 COMP1: [0, 256MiB] with 2 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 256*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [256MiB, 512MiB] with 4 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 256*1024*1024ULL,
+					  512*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP3: [512MiB, 1GiB] with 6 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 512*1024*1024ULL,
+					  1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP4: [1GiB, EOF] with 8 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 8);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC components matching Mirror 1 extents */
+	/* M2 EC1: [0, 256MiB] with EC(1,2) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 256*1024*1024ULL, 2, 1);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC2: [256MiB, 512MiB] with EC(2,4) */
+	rc = llapi_layout_comp_add_ec(layout, 256*1024*1024ULL,
+				      512*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC3: [512MiB, 1GiB] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL,
+				      1024*1024*1024ULL, 6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC4: [1GiB, EOF] with EC(3,8) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      8, 3);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (2 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T53FILE		"f53"
+#define T53_DESC	"verify valid partial EC component ordering"
+static void test53(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T53FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout with data mirror and partial EC mirror */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components (3 components) */
+	/* M1 COMP1: [0, 512MiB] */
+	rc = llapi_layout_stripe_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 512*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [512MiB, 1GiB] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 512*1024*1024ULL,
+					  1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP3: [1GiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: Partial EC mirror - only EC for [512MiB, EOF] */
+	/* M2 COMP1: [0, 512MiB] - regular data component */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 512*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC1: [512MiB, 1GiB] with EC(2,4) */
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL,
+				      1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC2: [1GiB, EOF] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (2 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout - partial EC mirror should be valid */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T54FILE		"f54"
+#define T54_DESC	"verify additional EC component ordering scenarios"
+static void test54(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T54FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout: COMP1 COMP2 COMP3 (complete to EOF) */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* COMP1: [0, 256MiB] */
+	rc = llapi_layout_stripe_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 256*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP2: [256MiB, 512MiB] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 256*1024*1024ULL,
+					  512*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* COMP3: [512MiB, EOF] */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 512*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Add EC for all components in order - should work */
+	rc = llapi_layout_comp_add_ec(layout, 0, 256*1024*1024ULL, 2, 1);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_add_ec(layout, 256*1024*1024ULL,
+				      512*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (2 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T55FILE		"f55"
+#define T55_DESC	"verify EC layout with two mirrors - EC only first mirror"
+static void test55(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T55FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout with 3 mirrors: data, EC, data */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components */
+	/* M1 COMP1: [0, 1GiB] with 4 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [1GiB, EOF] with 6 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC components matching Mirror 1 extents */
+	/* M2 EC1: [0, 1GiB] with EC(2,4) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC2: [1GiB, EOF] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 3: Regular data components with different extents */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M3 COMP1: [0, 2GiB] with 8 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 8);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 2*1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M3 COMP2: [2GiB, EOF] with 10 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 10);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 2*1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (3 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 3);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T56FILE		"f56"
+#define T56_DESC	"verify EC layout with two mirrors - EC both mirrors"
+static void test56(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T56FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout with 4 mirrors: data, EC, data, EC */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components */
+	/* M1 COMP1: [0, 1GiB] with 4 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [1GiB, EOF] with 6 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC components matching Mirror 1 */
+	/* M2 EC1: [0, 1GiB] with EC(2,4) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC2: [1GiB, EOF] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 3: Regular data components (different extents from M1) */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M3 COMP1: [0, 2GiB] with 8 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 8);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 2*1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M3 COMP2: [2GiB, EOF] with 10 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 10);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 2*1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 4: EC components matching Mirror 1 (not Mirror 3) */
+	/* M4 EC1: [0, 1GiB] with EC(2,4) - matches M1 COMP1 */
+	rc = llapi_layout_comp_add_ec(layout, 0, 1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M4 EC2: [1GiB, EOF] with EC(2,6) - matches M1 COMP2 */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (4 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
+}
+
+#define T57FILE		"f57"
+#define T57_DESC	"verify three mirrors with different extents - EC first only"
+static void test57(void)
+{
+	int fd;
+	int rc;
+	struct llapi_layout *layout;
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "%s/%s", lustre_dir, T57FILE);
+
+	rc = unlink(path);
+	ASSERTF(rc >= 0 || errno == ENOENT, "errno = %d", errno);
+
+	/* Create layout with 4 mirrors with different extent structures */
+	layout = llapi_layout_alloc();
+	ASSERTF(layout != NULL, "errno = %d", errno);
+
+	/* Mirror 1: Regular data components with 3 components */
+	/* M1 COMP1: [0, 512MiB] with 2 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 512*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP2: [512MiB, 1GiB] with 4 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 512*1024*1024ULL,
+					  1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M1 COMP3: [1GiB, EOF] with 6 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 6);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 1024*1024*1024ULL,
+					  LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 2: EC components matching Mirror 1 extents */
+	/* M2 EC1: [0, 512MiB] with EC(1,2) */
+	rc = llapi_layout_comp_add_ec(layout, 0, 512*1024*1024ULL, 2, 1);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC2: [512MiB, 1GiB] with EC(2,4) */
+	rc = llapi_layout_comp_add_ec(layout, 512*1024*1024ULL,
+				      1024*1024*1024ULL, 4, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M2 EC3: [1GiB, EOF] with EC(2,6) */
+	rc = llapi_layout_comp_add_ec(layout, 1024*1024*1024ULL, LUSTRE_EOF,
+				      6, 2);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 3: Regular data with different extents (2 components) */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M3 COMP1: [0, 2GiB] with 8 stripes */
+	rc = llapi_layout_stripe_count_set(layout, 8);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, 2*1024*1024*1024ULL);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M3 COMP2: [2GiB, EOF] with 10 stripes */
+	rc = llapi_layout_comp_add(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_stripe_count_set(layout, 10);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 2*1024*1024*1024ULL,
+					   LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Mirror 4: Regular data with single component */
+	rc = llapi_layout_add_first_comp(layout);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* M4 COMP1: [0, EOF] with 12 stripes (single component) */
+	rc = llapi_layout_stripe_count_set(layout, 12);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	rc = llapi_layout_comp_extent_set(layout, 0, LUSTRE_EOF);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Set mirror count for the layout (4 mirrors total) */
+	rc = llapi_layout_mirror_count_set(layout, 4);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	/* Validate the layout */
+	rc = llapi_layout_sanity(layout, false, false);
+	LAYOUT_ASSERTF(rc == 0, rc, "errno = %d", errno);
+
+	fd = llapi_layout_file_create(path, 0, 0640, layout);
+	ASSERTF(fd >= 0, "errno = %d", errno);
+
+	rc = close(fd);
+	ASSERTF(rc == 0, "errno = %d", errno);
+
+	llapi_layout_free(layout);
 }
 
 static struct test_tbl_entry test_tbl[] = {
@@ -1787,6 +2879,24 @@ static struct test_tbl_entry test_tbl[] = {
 	TEST_REGISTER(33),
 	TEST_REGISTER(34),
 	TEST_REGISTER(35),
+	TEST_REGISTER(40),
+	TEST_REGISTER(41),
+	TEST_REGISTER(42),
+	TEST_REGISTER(43),
+	TEST_REGISTER(44),
+	TEST_REGISTER(45),
+	TEST_REGISTER(46),
+	TEST_REGISTER(47),
+	TEST_REGISTER(48),
+	TEST_REGISTER(49),
+	TEST_REGISTER(50),
+	TEST_REGISTER(51),
+	TEST_REGISTER(52),
+	TEST_REGISTER(53),
+	TEST_REGISTER(54),
+	TEST_REGISTER(55),
+	TEST_REGISTER(56),
+	TEST_REGISTER(57),
 	TEST_REGISTER_END
 };
 
diff --git a/lustre/tests/llapi_test_utils.c b/lustre/tests/llapi_test_utils.c
index 05a66f0061..7d6f6532fc 100644
--- a/lustre/tests/llapi_test_utils.c
+++ b/lustre/tests/llapi_test_utils.c
@@ -157,6 +157,7 @@ int run_tests(const char *lustre_dir, struct test_tbl_entry *tst_tbl)
 	struct test_tbl_entry *tst;
 	char fsname[8 + 1];
 	struct stat st;
+	int saved_msg_level = llapi_msg_get_level();
 	int rc;
 
 	if (lustre_dir == NULL)
@@ -165,7 +166,7 @@ int run_tests(const char *lustre_dir, struct test_tbl_entry *tst_tbl)
 	if (tst_tbl == NULL)
 		DIE("no test table provided\n");
 
-	llapi_msg_set_level(LLAPI_MSG_OFF);
+	llapi_msg_set_level(LLAPI_MSG_ERROR);
 
 	if (stat(lustre_dir, &st) < 0)
 		DIE("cannot stat %s: %s\n", lustre_dir, strerror(errno));
@@ -190,5 +191,7 @@ int run_tests(const char *lustre_dir, struct test_tbl_entry *tst_tbl)
 			rc++;
 	}
 
+	llapi_msg_set_level(saved_msg_level);
+
 	return rc;
 }
diff --git a/lustre/utils/liblustreapi.c b/lustre/utils/liblustreapi.c
index 0fc026a296..6480069ed7 100644
--- a/lustre/utils/liblustreapi.c
+++ b/lustre/utils/liblustreapi.c
@@ -2749,7 +2749,7 @@ static void lov_dump_user_lmm_header(struct lov_user_md *lum, char *path,
 		if (verbose & ~VERBOSE_PATTERN)
 			llapi_printf(LLAPI_MSG_NORMAL, "%s%spattern:       ",
 				     space, prefix);
-		if (lov_pattern_supported(lum->lmm_pattern))
+		if (layout_pattern_supported(lum->lmm_pattern))
 			llapi_printf(LLAPI_MSG_NORMAL, "%s",
 				     llapi_lov_pattern_string(lum->lmm_pattern,
 							buf, sizeof(buf)) ?:
diff --git a/lustre/utils/liblustreapi_layout.c b/lustre/utils/liblustreapi_layout.c
index cbcc8b2c03..7928bbdaa1 100644
--- a/lustre/utils/liblustreapi_layout.c
+++ b/lustre/utils/liblustreapi_layout.c
@@ -52,6 +52,11 @@ struct llapi_layout_comp {
 			 * initialized.
 			 */
 			uint32_t	llc_objects_count;
+			/**
+			 * EC parity comp specific fields.
+			 */
+			uint8_t		llc_dstripe_count;
+			uint8_t		llc_cstripe_count;
 			struct lov_user_ost_data_v1 *llc_objects;
 		};
 		struct { /* For FOREIGN/HSM layout. */
@@ -1436,6 +1441,11 @@ int llapi_layout_stripe_count_set(struct llapi_layout *layout,
 	if (comp == NULL)
 		return -1;
 
+	if (comp->llc_flags & LCME_FL_PARITY) {
+		errno = EINVAL;
+		return -1;
+	}
+
 	if (!llapi_layout_stripe_count_is_valid(count)) {
 		errno = EINVAL;
 		return -1;
@@ -1521,7 +1531,8 @@ static int layout_stripe_size_set(struct llapi_layout *layout,
 	if (comp == NULL)
 		return -1;
 
-	if (comp->llc_pattern == LLAPI_LAYOUT_FOREIGN) {
+	if (comp->llc_pattern == LLAPI_LAYOUT_FOREIGN ||
+	    comp->llc_flags & LCME_FL_PARITY) {
 		errno = EINVAL;
 		return -1;
 	}
@@ -2249,6 +2260,12 @@ int llapi_layout_comp_flags_set(struct llapi_layout *layout, uint32_t flags)
 {
 	struct llapi_layout_comp *comp;
 
+	/* LCME_FL_PARITY cannot be set with this function */
+	if (flags & LCME_FL_PARITY) {
+		errno = EINVAL;
+		return -1;
+	}
+
 	comp = __llapi_layout_cur_comp(layout);
 	if (comp == NULL)
 		return -1;
@@ -2336,10 +2353,9 @@ int llapi_layout_mirror_id_get(const struct llapi_layout *layout, uint32_t *id)
 
 /**
  * Adds a component to \a layout, the new component will be added to
- * the tail of components list and it'll inherit attributes of existing
- * ones. The \a layout will change it's current component pointer to
- * the newly added component, and it'll be turned into a composite
- * layout if it was not before the adding.
+ * the tail of components list. The \a layout will change it's current
+ * component pointer to the newly added component, and it'll be turned
+ * into a composite layout if it was not before the adding.
  *
  * \param[in] layout	existing composite or plain layout
  *
@@ -2347,9 +2363,29 @@ int llapi_layout_mirror_id_get(const struct llapi_layout *layout, uint32_t *id)
  * \retval	<0 if error occurs
  */
 int llapi_layout_comp_add(struct llapi_layout *layout)
+{
+	return llapi_layout_comp_add_extent(layout, 0, 0);
+}
+
+int llapi_layout_comp_add_extent(struct llapi_layout *layout,
+				 uint64_t start, uint64_t end)
 {
 	struct llapi_layout_comp *last, *comp, *new;
-	bool composite = layout->llot_is_composite;
+	bool save_composite;
+
+	/* Validate input parameters */
+	if (!layout) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	/* extent start should be less than extent end */
+	if (start != 0 && start >= end) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	save_composite = layout->llot_is_composite;
 
 	comp = __llapi_layout_cur_comp(layout);
 	if (comp == NULL)
@@ -2361,27 +2397,55 @@ int llapi_layout_comp_add(struct llapi_layout *layout)
 
 	last = list_last_entry(&layout->llot_comp_list, typeof(*last),
 			       llc_list);
-
 	list_add_tail(&new->llc_list, &layout->llot_comp_list);
 
-	/* We must mark the layout composite for the sanity check, but it may
-	 * not stay that way if the check fails */
 	layout->llot_is_composite = true;
 	layout->llot_cur_comp = new;
 
-	/* We need to set a temporary non-zero value for "end" when we call
+	/* If no extent was provided:
+	 * We need to set a temporary non-zero value for "end" when we call
 	 * comp_extent_set, so we use LUSTRE_EOF-1, which is > all allowed
 	 * for the end of the previous component.  (If we're adding this
-	 * component, the end of the previous component cannot be EOF.) */
-	if (llapi_layout_comp_extent_set(layout, last->llc_extent.e_end,
-					LUSTRE_EOF - 1)) {
+	 * component, the end of the previous component cannot be EOF.)
+	 */
+	if (start == 0 && end == 0) {
+		start = last->llc_extent.e_end;
+		end = LUSTRE_EOF - 1;
+	}
+	if (llapi_layout_comp_extent_set(layout, start, end)) {
 		(void)llapi_layout_comp_del(layout);
-		layout->llot_is_composite = composite;
+		layout->llot_is_composite = save_composite;
+		return -1;
+	}
+
+	return 0;
+}
+
+int llapi_layout_comp_add_ec(struct llapi_layout *layout,
+			     uint64_t start, uint64_t end,
+			     uint8_t dstripe_count, uint8_t cstripe_count)
+{
+	struct llapi_layout_comp *cur_comp;
+	int rc;
+
+	/* Parity components require non-zero cstripe and dstripe */
+	if (layout_ec_verify_stripes(dstripe_count, cstripe_count)) {
+		errno = EINVAL;
 		return -1;
 	}
 
+	rc = llapi_layout_comp_add_extent(layout, start, end);
+	if (rc)
+		return rc;
+
+	cur_comp = __llapi_layout_cur_comp(layout);
+	cur_comp->llc_flags |= LCME_FL_PARITY;
+	cur_comp->llc_cstripe_count = cstripe_count;
+	cur_comp->llc_dstripe_count = dstripe_count;
+
 	return 0;
 }
+
 /**
  * Adds a first component of a mirror to \a layout.
  * The \a layout will change it's current component pointer to
@@ -3645,6 +3709,11 @@ enum llapi_layout_comp_sanity_error {
 	LSE_ALIGN_END,
 	LSE_ALIGN_EXT,
 	LSE_FOREIGN_EXTENSION,
+	LSE_EC_FIRST,
+	LSE_EC_PARAM,
+	LSE_EC_MATCH_DATA,
+	LSE_EC_DUP,
+	LSE_EC_OVERLAP,
 	LSE_LAST,
 };
 
@@ -3683,6 +3752,16 @@ const char *const llapi_layout_strerror[] =
 		"The extension size must be aligned by the stripe size",
 	[LSE_FOREIGN_EXTENSION] =
 		"FOREIGN components can't be extension space",
+	[LSE_EC_FIRST] =
+		"EC component should not be the first one in a file/mirror",
+	[LSE_EC_PARAM] =
+		"EC component should have valid parameters",
+	[LSE_EC_MATCH_DATA] =
+		"EC component should have matching data component",
+	[LSE_EC_DUP] =
+		"EC component should not duplicate in the same mirror",
+	[LSE_EC_OVERLAP] =
+		"EC components should not overlapped in the same mirror",
 };
 
 struct llapi_layout_sanity_args {
@@ -3748,7 +3827,13 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 
 	/* Start of zero implies a new mirror */
 	if (comp->llc_extent.e_start == 0) {
-		first_comp = true;
+		/*
+		 * EC parity components can start at 0 without being first
+		 * component
+		 */
+		if (!(comp->llc_flags & LCME_FL_PARITY))
+			first_comp = true;
+
 		/* Most checks apply only within one mirror, this is an
 		 * exception. */
 		if (prev && prev->llc_extent.e_end != LUSTRE_EOF) {
@@ -3756,7 +3841,9 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 			goto out_err;
 		}
 
-		prev = NULL;
+		/* Don't nullify prev for EC parity components */
+		if (!(comp->llc_flags & LCME_FL_PARITY))
+			prev = NULL;
 	}
 
 	if (next && next->llc_extent.e_start == 0)
@@ -3778,6 +3865,12 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 		goto out_err;
 	}
 
+	/* Parity components cannot be the first component */
+	if ((comp->llc_flags & LCME_FL_PARITY) && first_comp) {
+		args->lsa_rc = LSE_EC_FIRST;
+		goto out_err;
+	}
+
 	if (comp->llc_ondisk) {
 		if (comp->llc_flags & LCME_FL_NEG)
 			args->lsa_rc = LSE_FLAGS;
@@ -3788,8 +3881,9 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 		} else {
 			if (comp->llc_flags &
 			    ~(LCME_FL_EXTENSION | LCME_FL_PREF_RW |
-			      LCME_FL_NOCOMPR))
+			      LCME_FL_NOCOMPR | LCME_FL_PARITY)) {
 				args->lsa_rc = LSE_FLAGS;
+			}
 		}
 	}
 	if (args->lsa_rc)
@@ -3846,8 +3940,12 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 			goto out_err;
 		}
 
-		/* End must come after end of previous comp */
-		if (prev && comp->llc_extent.e_end < prev->llc_extent.e_end) {
+		/*
+		 * End must come after end of previous comp, except for
+		 * EC parity components which can have overlapping extents
+		 */
+		if (prev && comp->llc_extent.e_end < prev->llc_extent.e_end &&
+		    !(comp->llc_flags & LCME_FL_PARITY)) {
 			args->lsa_rc = LSE_END_NOT_GREATER;
 			goto out_err;
 		}
@@ -3884,11 +3982,19 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 		}
 	}
 
-	/* Components must have start == prev->end */
+	/*
+	 * Components must have start == prev->end, except for EC parity
+	 * components which can overlap with their corresponding data components
+	 */
 	if (prev && comp->llc_extent.e_start != 0 &&
 	    comp->llc_extent.e_start != prev->llc_extent.e_end) {
-		args->lsa_rc = LSE_NOT_ADJACENT_PREV;
-		goto out_err;
+		/* Allow non-adjacent extents for EC parity components */
+		bool is_ec_parity = (comp->llc_flags & LCME_FL_PARITY);
+
+		if (!is_ec_parity) {
+			args->lsa_rc = LSE_NOT_ADJACENT_PREV;
+			goto out_err;
+		}
 	}
 
 	/* Components must have start <= end */
@@ -3897,6 +4003,143 @@ static int llapi_layout_sanity_cb(struct llapi_layout *layout,
 		goto out_err;
 	}
 
+	/* EC parity component specific validation */
+	if (comp->llc_flags & LCME_FL_PARITY) {
+		/* EC parameter validation */
+		if (comp->llc_cstripe_count == 0 ||
+		    comp->llc_dstripe_count == 0) {
+			args->lsa_rc = LSE_EC_PARAM;
+			goto out_err;
+		}
+
+		if (comp->llc_cstripe_count >= comp->llc_dstripe_count) {
+			args->lsa_rc = LSE_EC_PARAM;
+			goto out_err;
+		}
+
+		if (comp->llc_dstripe_count < 2) {
+			args->lsa_rc = LSE_EC_PARAM;
+			goto out_err;
+		}
+
+		/* Check for layout completeness - EC can only be added to
+		 * complete layouts
+		 */
+		uint64_t max_data_end = 0;
+		bool layout_complete = false;
+		struct llapi_layout_comp *search_comp;
+
+		list_for_each_entry(search_comp, &layout->llot_comp_list,
+				    llc_list) {
+			if (search_comp == comp)
+				continue;
+			if (search_comp->llc_flags & LCME_FL_PARITY)
+				continue;
+
+			if (search_comp->llc_extent.e_end > max_data_end)
+				max_data_end = search_comp->llc_extent.e_end;
+		}
+
+		if (max_data_end == LUSTRE_EOF)
+			layout_complete = true;
+
+		if (!layout_complete) {
+			args->lsa_rc = LSE_EC_PARAM;
+			goto out_err;
+		}
+
+		/* Find matching data component for this EC component */
+		bool found_matching_data = false;
+
+		list_for_each_entry(search_comp, &layout->llot_comp_list,
+				    llc_list) {
+			if (search_comp == comp)
+				continue;
+			if (search_comp->llc_flags & LCME_FL_PARITY)
+				continue;
+
+			/* Check for exact extent match */
+			if (search_comp->llc_extent.e_start ==
+			    comp->llc_extent.e_start &&
+			    search_comp->llc_extent.e_end ==
+			    comp->llc_extent.e_end) {
+				found_matching_data = true;
+				break;
+			}
+		}
+
+		if (!found_matching_data) {
+			args->lsa_rc = LSE_EC_MATCH_DATA;
+			goto out_err;
+		}
+
+		/* Check for duplicate EC components within the same mirror */
+		list_for_each_entry(search_comp,
+				    &layout->llot_comp_list, llc_list) {
+			/* Determine if search_comp is in the same mirror as
+			 * comp
+			 */
+			bool same_mirror = true;
+			struct llapi_layout_comp *iter_comp;
+			bool found_comp = false, found_search = false;
+			bool crossed_mirror_boundary = false;
+
+			if (search_comp == comp)
+				continue;
+			if (!(search_comp->llc_flags & LCME_FL_PARITY))
+				continue;
+
+			/* Walk through components to determine mirror
+			 * boundaries
+			 */
+			list_for_each_entry(iter_comp,&layout->llot_comp_list,
+					    llc_list) {
+				/* Check if we've crossed a mirror boundary */
+				if (iter_comp->llc_extent.e_start == 0 &&
+				    !(iter_comp->llc_flags & LCME_FL_PARITY) &&
+				    (found_comp || found_search))
+					crossed_mirror_boundary = true;
+
+				if (iter_comp == comp) {
+					found_comp = true;
+					if (found_search &&
+					    crossed_mirror_boundary) {
+						same_mirror = false;
+						break;
+					}
+				}
+				if (iter_comp == search_comp) {
+					found_search = true;
+					if (found_comp &&
+					    crossed_mirror_boundary) {
+						same_mirror = false;
+						break;
+					}
+				}
+			}
+
+			/* Only check for conflicts within the same mirror */
+			if (!same_mirror)
+				continue;
+
+			/* Check for duplicate extent within same mirror */
+			if (search_comp->llc_extent.e_start ==
+			    comp->llc_extent.e_start &&
+			    search_comp->llc_extent.e_end ==
+			    comp->llc_extent.e_end) {
+				args->lsa_rc = LSE_EC_DUP;
+				goto out_err;
+			}
+
+			/* Check for overlapping extents within same mirror */
+			if (lu_extent_is_overlapped(&search_comp->llc_extent,
+						     &comp->llc_extent)) {
+				args->lsa_rc = LSE_EC_OVERLAP;
+				goto out_err;
+			}
+		}
+	}
+
 	return LLAPI_LAYOUT_ITER_CONT;
 
 out_err:

</pre>
</body>
</html>
