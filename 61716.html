<html lang="en">
<body>
<pre>
From 91493ebf135e4a4d25348a6aaa534aa0d4b990ab Mon Sep 17 00:00:00 2001
From: James Simmons <jsimmons@infradead.org>
Date: Mon, 27 Oct 2025 11:28:06 -0400
Subject: [PATCH 1/1] LU-8066 mgs: migrate files out of procfs

Move all the simple proc files to sysfs. The more complex files
get moved to debugfs. The MGS layer was the last to use
lprocfs_evict_client_seq_write(). We can instead use the already
existing evice_client_store() that is already being used by other
obd device layers.

Change-Id: I9358c4e422c323c784dbdb375f0e767429c6c7da
Signed-off-by: James Simmons <jsimmons@infradead.org>
---
 lustre/include/lprocfs_status.h         | 12 ----
 lustre/mgs/lproc_mgs.c                  | 78 +++++++++----------------
 lustre/mgs/mgs_handler.c                |  2 +-
 lustre/mgs/mgs_internal.h               | 24 ++------
 lustre/mgs/mgs_llog.c                   |  2 +-
 lustre/mgs/mgs_nids.c                   | 13 ++---
 lustre/obdclass/lprocfs_status_server.c | 47 ---------------
 7 files changed, 41 insertions(+), 137 deletions(-)

diff --git a/lustre/include/lprocfs_status.h b/lustre/include/lprocfs_status.h
index b8c2e5f360..967424719f 100644
--- a/lustre/include/lprocfs_status.h
+++ b/lustre/include/lprocfs_status.h
@@ -621,9 +621,6 @@ extern ssize_t
 lprocfs_timeouts_seq_write(struct file *file, const char __user *buffer,
 			   size_t count, loff_t *off);
 #ifdef HAVE_SERVER_SUPPORT
-extern ssize_t
-lprocfs_evict_client_seq_write(struct file *file, const char __user *buffer,
-				size_t count, loff_t *off);
 ssize_t evict_client_store(struct kobject *kobj, struct attribute *attr,
 			   const char *buffer, size_t count);
 #endif
@@ -1170,15 +1167,6 @@ lprocfs_timeouts_seq_write(struct file *file, const char __user *buffer,
 {
 	return 0;
 }
-#ifdef HAVE_SERVER_SUPPORT
-static inline ssize_t
-lprocfs_evict_client_seq_write(struct file *file, const char __user *buffer,
-			       size_t count, loff_t *off)
-{
-	return 0;
-}
-#endif
-
 static inline ssize_t
 lprocfs_ping_seq_write(struct file *file, const char __user *buffer,
 		       size_t count, loff_t *off)
diff --git a/lustre/mgs/lproc_mgs.c b/lustre/mgs/lproc_mgs.c
index 47f7da3515..db50ee04c6 100644
--- a/lustre/mgs/lproc_mgs.c
+++ b/lustre/mgs/lproc_mgs.c
@@ -21,8 +21,6 @@
 #include <uapi/linux/lustre/lustre_param.h>
 #include "mgs_internal.h"
 
-#ifdef CONFIG_PROC_FS
-
 static int mgs_fs_seq_show(struct seq_file *seq, void *v)
 {
 	struct obd_device	*obd = seq->private;
@@ -110,7 +108,7 @@ LDEBUGFS_SEQ_FOPS_RO(mgsself_srpc);
 
 static int mgs_live_seq_show(struct seq_file *seq, void *v)
 {
-	struct fs_db             *fsdb = seq->private;
+	struct fs_db *fsdb = seq->private;
 	struct mgs_tgt_srpc_conf *srpc_tgt;
 	int i;
 
@@ -147,8 +145,8 @@ static int mgs_live_seq_show(struct seq_file *seq, void *v)
 static ssize_t mgs_live_seq_write(struct file *file, const char __user *buf,
 				  size_t len, loff_t *off)
 {
-	struct seq_file *seq  = file->private_data;
-	struct fs_db    *fsdb = seq->private;
+	struct seq_file *seq = file->private_data;
+	struct fs_db *fsdb = seq->private;
 	ssize_t rc;
 
 	rc = lprocfs_wr_ir_state(file, buf, len, fsdb);
@@ -156,50 +154,45 @@ static ssize_t mgs_live_seq_write(struct file *file, const char __user *buf,
 		rc = len;
 	return rc;
 }
-LPROC_SEQ_FOPS(mgs_live);
+LDEBUGFS_SEQ_FOPS(mgs_live);
 
 int lproc_mgs_add_live(struct mgs_device *mgs, struct fs_db *fsdb)
 {
-	int rc;
-
-	if (!mgs->mgs_proc_live || fsdb->fsdb_has_lproc_entry)
+	if (IS_ERR_OR_NULL(mgs->mgs_debugfs_live))
 		return 0;
 
-	rc = lprocfs_seq_create(mgs->mgs_proc_live, fsdb->fsdb_name, 0644,
-				&mgs_live_fops, fsdb);
-	if (!rc)
-		fsdb->fsdb_has_lproc_entry = 1;
+	debugfs_create_file(fsdb->fsdb_name, 0644, mgs->mgs_debugfs_live,
+			    fsdb, &mgs_live_fops);
+	fsdb->fsdb_has_debugfs_entry = 1;
 
-	return rc;
+	return 0;
 }
 
 int lproc_mgs_del_live(struct mgs_device *mgs, struct fs_db *fsdb)
 {
-	if (!mgs->mgs_proc_live || !fsdb->fsdb_has_lproc_entry)
+	if (IS_ERR_OR_NULL(mgs->mgs_debugfs_live) ||
+	    !fsdb->fsdb_has_debugfs_entry)
 		return 0;
 
 	/* didn't create the proc file for MGSSELF_NAME */
 	if (!test_bit(FSDB_MGS_SELF, &fsdb->fsdb_flags))
-		lprocfs_remove_proc_entry(fsdb->fsdb_name, mgs->mgs_proc_live);
+		debugfs_lookup_and_remove(fsdb->fsdb_name,
+					  mgs->mgs_debugfs_live);
 	return 0;
 }
 
-LPROC_SEQ_FOPS_RO_TYPE(mgs, hash);
-LPROC_SEQ_FOPS_WR_ONLY(mgs, evict_client);
-LPROC_SEQ_FOPS_RW_TYPE(mgs, ir_timeout);
+LDEBUGFS_SEQ_FOPS_RO_TYPE(mgs, hash);
 /* belongs to export directory */
 LDEBUGFS_SEQ_FOPS_RW_TYPE(mgs, nid_stats_clear);
 
-static struct lprocfs_vars lprocfs_mgs_obd_vars[] = {
+static struct ldebugfs_vars ldebugfs_mgs_obd_vars[] = {
 	{ .name	=	"hash_stats",
 	  .fops	=	&mgs_hash_fops		},
-	{ .name	=	"evict_client",
-	  .fops	=	&mgs_evict_client_fops	},
-	{ .name	=	"ir_timeout",
-	  .fops	=	&mgs_ir_timeout_fops	},
 	{ NULL }
 };
 
+LUSTRE_WO_ATTR(evict_client);
+LUSTRE_RW_ATTR(ir_timeout);
 LUSTRE_RO_ATTR(num_exports);
 LUSTRE_RO_ATTR(eviction_count);
 
@@ -249,7 +242,9 @@ LUSTRE_OBD_UINT_PARAM_ATTR(at_history);
 LUSTRE_OBD_UINT_PARAM_ATTR(at_unhealthy_factor);
 
 static struct attribute *mgs_attrs[] = {
+	&lustre_attr_evict_client.attr,
 	&lustre_attr_fstype.attr,
+	&lustre_attr_ir_timeout.attr,
 	&lustre_attr_mntdev.attr,
 	&lustre_attr_eviction_count.attr,
 	&lustre_attr_num_exports.attr,
@@ -264,14 +259,14 @@ KOBJ_ATTRIBUTE_GROUPS(mgs); /* creates mgs_groups from mgs_attrs */
 
 int lproc_mgs_setup(struct mgs_device *mgs, const char *osd_name)
 {
-	int osd_len = strlen(osd_name) - strlen("-osd");
 	struct obd_device *obd = mgs->mgs_obd;
 	const struct kobj_type *bottom_type;
 	struct attribute *attr;
 	struct obd_device *osd_obd;
+	char path[MAX_OBD_NAME];
 	int rc;
 
-	obd->obd_vars = lprocfs_mgs_obd_vars;
+	obd->obd_debugfs_vars = ldebugfs_mgs_obd_vars;
 	obd->obd_ktype.default_groups = KOBJ_ATTR_GROUPS(mgs);
 	rc = lprocfs_obd_setup(obd, true);
 	if (rc != 0)
@@ -283,13 +278,8 @@ int lproc_mgs_setup(struct mgs_device *mgs, const char *osd_name)
 	debugfs_create_file("srpc_rules", 0400, obd->obd_debugfs_entry, obd,
 			    &mgsself_srpc_fops);
 
-	mgs->mgs_proc_live = lprocfs_register("live", obd->obd_proc_entry,
-					      NULL, NULL);
-        if (IS_ERR(mgs->mgs_proc_live)) {
-                rc = PTR_ERR(mgs->mgs_proc_live);
-                mgs->mgs_proc_live = NULL;
-		GOTO(out, rc);
-        }
+	mgs->mgs_debugfs_live = debugfs_create_dir("live",
+						   obd->obd_debugfs_entry);
 
 	obd->obd_debugfs_gss_dir = debugfs_create_dir("gss",
 						      obd->obd_debugfs_entry);
@@ -308,6 +298,10 @@ int lproc_mgs_setup(struct mgs_device *mgs, const char *osd_name)
 			    obd, &mgs_nid_stats_clear_fops);
 
 	osd_obd = mgs->mgs_bottom->dd_lu_dev.ld_obd;
+	snprintf(path, sizeof(path), "../../%s/%s",
+		 osd_obd->obd_type->typ_name,
+		 kobject_name(&mgs->mgs_bottom->dd_kobj));
+	debugfs_create_symlink("osd", obd->obd_debugfs_entry, path);
 
 	rc = sysfs_create_link(&obd->obd_kset.kobj, &mgs->mgs_bottom->dd_kobj,
 			       "osd");
@@ -325,14 +319,6 @@ int lproc_mgs_setup(struct mgs_device *mgs, const char *osd_name)
 	attr = get_attr_by_name(bottom_type, "mntdev");
 	if (attr)
 		mgs->mgs_fstype = mgs->mgs_mntdev;
-	mgs->mgs_proc_osd = lprocfs_add_symlink("osd",
-						obd->obd_proc_entry,
-						"../../%s/%.*s",
-						osd_obd->obd_type->typ_name,
-						osd_len, /* Strip "-osd". */
-						osd_name);
-	if (mgs->mgs_proc_osd == NULL)
-		rc = -ENOMEM;
 out:
 	if (rc != 0)
 		lproc_mgs_cleanup(mgs);
@@ -347,17 +333,8 @@ void lproc_mgs_cleanup(struct mgs_device *mgs)
 	if (obd == NULL)
 		return;
 
-	if (mgs->mgs_proc_osd != NULL)
-		lprocfs_remove(&mgs->mgs_proc_osd);
-
 	sysfs_remove_link(&obd->obd_kset.kobj, "osd");
 
-	if (mgs->mgs_proc_live != NULL) {
-		/* Should be no live entries */
-		lprocfs_remove(&mgs->mgs_proc_live);
-		mgs->mgs_proc_live = NULL;
-	}
-
 	lprocfs_free_per_client_stats(obd);
 	lprocfs_obd_cleanup(obd);
 	ldebugfs_free_obd_stats(obd);
@@ -379,4 +356,3 @@ void mgs_stats_counter_init(struct lprocfs_stats *stats)
 	lprocfs_counter_init(stats, LPROC_MGS_TARGET_REG, 0, "tgtreg");
 	lprocfs_counter_init(stats, LPROC_MGS_TARGET_DEL, 0, "tgtdel");
 }
-#endif
diff --git a/lustre/mgs/mgs_handler.c b/lustre/mgs/mgs_handler.c
index eff9952054..2b62d288a9 100644
--- a/lustre/mgs/mgs_handler.c
+++ b/lustre/mgs/mgs_handler.c
@@ -1837,7 +1837,7 @@ static int __init mgs_init(void)
 	if (rc)
 		return rc;
 
-	return class_register_type(&mgs_obd_device_ops, NULL, true,
+	return class_register_type(&mgs_obd_device_ops, NULL, false,
 				   LUSTRE_MGS_NAME, &mgs_device_type);
 }
 
diff --git a/lustre/mgs/mgs_internal.h b/lustre/mgs/mgs_internal.h
index a620eef6e9..70c2d174f3 100644
--- a/lustre/mgs/mgs_internal.h
+++ b/lustre/mgs/mgs_internal.h
@@ -150,7 +150,7 @@ struct fs_db {
 	atomic_t	      fsdb_notify_phase;
 	volatile unsigned int fsdb_notify_async:1,
 			      fsdb_notify_stop:1,
-			      fsdb_has_lproc_entry:1,
+			      fsdb_has_debugfs_entry:1,
 			      fsdb_barrier_disabled:1;
 	/* statistic data */
 	ktime_t		fsdb_notify_total;
@@ -168,8 +168,7 @@ struct mgs_device {
 	struct dt_object		*mgs_nidtbl_dir;
 	struct list_head		 mgs_fs_db_list;
 	spinlock_t			 mgs_lock; /* covers mgs_fs_db_list */
-	struct proc_dir_entry		*mgs_proc_live;
-	struct proc_dir_entry           *mgs_proc_osd;
+	struct dentry			*mgs_debugfs_live;
 	struct attribute		*mgs_fstype;
 	struct attribute		*mgs_mntdev;
 	time64_t			 mgs_start_time;
@@ -241,10 +240,10 @@ int  mgs_get_ir_logs(struct ptlrpc_request *req);
 int  lprocfs_wr_ir_state(struct file *file, const char __user *buffer,
 			 size_t count, void *data);
 int  lprocfs_rd_ir_state(struct seq_file *seq, void *data);
-ssize_t
-lprocfs_ir_timeout_seq_write(struct file *file, const char __user *buffer,
-			     size_t count, loff_t *off);
-int  lprocfs_ir_timeout_seq_show(struct seq_file *seq, void *data);
+ssize_t ir_timeout_show(struct kobject *kobj, struct attribute *attr,
+			char *buf);
+ssize_t ir_timeout_store(struct kobject *kobj, struct attribute *attr,
+			 const char *buffer, size_t count);
 void mgs_fsc_cleanup(struct obd_export *exp);
 void mgs_fsc_cleanup_by_fsdb(struct fs_db *fsdb);
 int  mgs_fsc_attach(const struct lu_env *env, struct obd_export *exp,
@@ -262,21 +261,10 @@ int mgs_iocontrol_barrier(const struct lu_env *env,
 			  struct mgs_device *mgs,
 			  struct obd_ioctl_data *data);
 
-#ifdef CONFIG_PROC_FS
 int lproc_mgs_setup(struct mgs_device *mgs, const char *osd_name);
 void lproc_mgs_cleanup(struct mgs_device *mgs);
 int lproc_mgs_add_live(struct mgs_device *mgs, struct fs_db *fsdb);
 int lproc_mgs_del_live(struct mgs_device *mgs, struct fs_db *fsdb);
-#else
-static inline int lproc_mgs_setup(struct mgs_device *mgs, const char *osd_name)
-{return 0;}
-static inline void lproc_mgs_cleanup(struct mgs_device *mgs)
-{}
-static inline int lproc_mgs_add_live(struct mgs_device *mgs, struct fs_db *fsdb)
-{return 0;}
-static inline int lproc_mgs_del_live(struct mgs_device *mgs, struct fs_db *fsdb)
-{return 0;}
-#endif
 
 /* mgs/lproc_mgs.c */
 enum {
diff --git a/lustre/mgs/mgs_llog.c b/lustre/mgs/mgs_llog.c
index cfbbbb1cdb..0364a476df 100644
--- a/lustre/mgs/mgs_llog.c
+++ b/lustre/mgs/mgs_llog.c
@@ -6031,7 +6031,7 @@ static int mgs_set_param2(const struct lu_env *env, struct mgs_device *mgs,
 
 		list_for_each(tmp, &mgs->mgs_fs_db_list) {
 			fsdb = list_entry(tmp, struct fs_db, fsdb_list);
-			if (fsdb->fsdb_has_lproc_entry &&
+			if (fsdb->fsdb_has_debugfs_entry &&
 			    strcmp(fsdb->fsdb_name, "params") != 0 &&
 			    strstr(param, fsdb->fsdb_name)) {
 				snprintf(mti->mti_svname,
diff --git a/lustre/mgs/mgs_nids.c b/lustre/mgs/mgs_nids.c
index cfacc192c8..1b933f4eb2 100644
--- a/lustre/mgs/mgs_nids.c
+++ b/lustre/mgs/mgs_nids.c
@@ -1093,17 +1093,16 @@ int lprocfs_rd_ir_state(struct seq_file *seq, void *data)
 	return 0;
 }
 
-int lprocfs_ir_timeout_seq_show(struct seq_file *m, void *data)
+ssize_t ir_timeout_show(struct kobject *kobj, struct attribute *attr,
+			char *buf)
 {
-	seq_printf(m, "%lld\n", ir_timeout);
-	return 0;
+	return scnprintf(buf, PAGE_SIZE, "%lld\n", ir_timeout);
 }
 
-ssize_t lprocfs_ir_timeout_seq_write(struct file *file,
-				     const char __user *buffer,
-				     size_t count, loff_t *off)
+ssize_t ir_timeout_store(struct kobject *kobj, struct attribute *attr,
+			 const char *buffer, size_t count)
 {
-	return kstrtoll_from_user(buffer, count, 0, &ir_timeout);
+	return kstrtou64(buffer, 10, &ir_timeout);
 }
 
 /* --------------- Handle non IR support clients --------------- */
diff --git a/lustre/obdclass/lprocfs_status_server.c b/lustre/obdclass/lprocfs_status_server.c
index a2a17bf9b9..ba0a74c781 100644
--- a/lustre/obdclass/lprocfs_status_server.c
+++ b/lustre/obdclass/lprocfs_status_server.c
@@ -81,53 +81,6 @@ ssize_t evict_client_store(struct kobject *kobj, struct attribute *attr,
 }
 EXPORT_SYMBOL(evict_client_store);
 
-#ifdef CONFIG_PROC_FS
-#define BUFLEN LNET_NIDSTR_SIZE
-
-ssize_t
-lprocfs_evict_client_seq_write(struct file *file, const char __user *buffer,
-			       size_t count, loff_t *off)
-{
-	struct seq_file *m = file->private_data;
-	struct obd_device *obd = m->private;
-	char *tmpbuf, *kbuf;
-
-	OBD_ALLOC(kbuf, BUFLEN);
-	if (kbuf == NULL)
-		return -ENOMEM;
-
-	/*
-	 * OBD_ALLOC() will zero kbuf, but we only copy BUFLEN - 1
-	 * bytes into kbuf, to ensure that the string is NUL-terminated.
-	 * LNET_NIDSTR_SIZE includes space for a trailing NUL already.
-	 */
-	if (copy_from_user(kbuf, buffer,
-			   min_t(unsigned long, BUFLEN - 1, count))) {
-		count = -EFAULT;
-		goto out;
-	}
-	tmpbuf = skip_spaces(kbuf);
-	tmpbuf = strsep(&tmpbuf, " \t\n\f\v\r");
-	class_incref(obd, __func__, current);
-
-	if (strncmp(tmpbuf, "nid:", 4) == 0)
-		obd_export_evict_by_nid(obd, tmpbuf + 4);
-	else if (strncmp(tmpbuf, "uuid:", 5) == 0)
-		obd_export_evict_by_uuid(obd, tmpbuf + 5);
-	else
-		obd_export_evict_by_uuid(obd, tmpbuf);
-
-	class_decref(obd, __func__, current);
-
-out:
-	OBD_FREE(kbuf, BUFLEN);
-	return count;
-}
-EXPORT_SYMBOL(lprocfs_evict_client_seq_write);
-
-#undef BUFLEN
-#endif /* CONFIG_PROC_FS*/
-
 ssize_t eviction_count_show(struct kobject *kobj, struct attribute *attr,
 			 char *buf)
 {

</pre>
</body>
</html>
