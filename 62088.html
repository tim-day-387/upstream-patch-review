<html lang="en">
<body>
<pre>
From 99cd9847a8f38f034af84ad9d674174fa958f64f Mon Sep 17 00:00:00 2001
From: Qian Yingjin <qian@ddn.com>
Date: Wed, 29 Oct 2025 09:55:25 +0800
Subject: [PATCH 1/1] LU-17262 llite: debug after revert LU-19014 memcg: fix
 hang

revert the patch  https://review.whamcloud.com/59223
("LU-19014 memcg: fix client hang in balance_dirty_pages()")

Test-Parameters: fortestonly
Test-Parameters: testlist=replay-single fstype=zfs env=ONLY=135,ONLY_REPEAT=100
Test-Parameters: testlist=replay-single env=ONLY=135,ONLY_REPEAT=100
Signed-off-by: Yingjin Qian <qian@ddn.com>
Change-Id: I2296676d6d92ef2eff545063a51beecd19872918
---
 lustre/include/cl_object.h    |  51 +++------------
 lustre/include/lustre_osc.h   |  13 +---
 lustre/llite/file.c           |   9 +--
 lustre/llite/llite_internal.h |   6 +-
 lustre/llite/llite_lib.c      |   3 +-
 lustre/llite/rw.c             |  10 +--
 lustre/llite/rw26.c           |  25 +-------
 lustre/llite/vvp_internal.h   |   3 +-
 lustre/llite/vvp_io.c         |  20 +++---
 lustre/llite/vvp_object.c     |   3 +-
 lustre/lov/lov_io.c           |  18 ++----
 lustre/mdc/mdc_dev.c          |  18 ++----
 lustre/obdclass/cl_io.c       |  10 ++-
 lustre/osc/osc_cache.c        | 115 ++++++----------------------------
 lustre/osc/osc_internal.h     |   8 ++-
 lustre/osc/osc_io.c           |  32 ++++------
 lustre/osc/osc_lock.c         |   2 +-
 17 files changed, 86 insertions(+), 260 deletions(-)

diff --git a/lustre/include/cl_object.h b/lustre/include/cl_object.h
index 17b8ebeaca..66a48e0e05 100644
--- a/lustre/include/cl_object.h
+++ b/lustre/include/cl_object.h
@@ -1439,36 +1439,6 @@ static inline void cl_read_ahead_release(const struct lu_env *env,
 		ra->cra_release(env, ra);
 }
 
-enum cl_io_priority {
-	/* Normal I/O, usually just queue the pages in the client side cache. */
-	IO_PRIO_NORMAL	= 0,
-	/* I/O is urgent and should flush queued pages to OSTs ASAP. */
-	IO_PRIO_URGENT,
-	/* The memcg is under high memory pressure and the user write process
-	 * is dirty exceeded and under rate limiting in balance_dirty_pages().
-	 * It needs to flush dirty pages for the corresponding @wb ASAP.
-	 */
-	IO_PRIO_DIRTY_EXCEEDED,
-	/*
-	 * I/O is urgent and flushing pages are marked with OBD_BRW_SOFT_SYNC
-	 * flag and may trigger a soft sync on OSTs. Thus it can free unstable
-	 * pages much quickly.
-	 */
-	IO_PRIO_SOFT_SYNC,
-	/*
-	 * The system or a certain memcg is under high memory pressure. Need to
-	 * flush dirty pages to OSTs immediately and I/O RPC must wait the write
-	 * transcation commit on OSTs synchronously to release unstable pages.
-	 */
-	IO_PRIO_HARD_SYNC,
-	IO_PRIO_MAX,
-};
-
-static inline bool cl_io_high_prio(enum cl_io_priority prio)
-{
-	return prio >= IO_PRIO_URGENT;
-}
-
 /**
  * Per-layer io operations.
  * \see vvp_io_ops, lov_io_ops, lovsub_io_ops, osc_io_ops
@@ -1581,13 +1551,12 @@ struct cl_io_operations {
 	int  (*cio_commit_async)(const struct lu_env *env,
 				 const struct cl_io_slice *slice,
 				 struct cl_page_list *queue, int from, int to,
-				 cl_commit_cbt cb, enum cl_io_priority prio);
+				 cl_commit_cbt cb);
 	/**
 	 * Release active extent.
 	 */
 	void  (*cio_extent_release)(const struct lu_env *env,
-				    const struct cl_io_slice *slice,
-				    enum cl_io_priority prio);
+				    const struct cl_io_slice *slice);
 	/**
 	 * Decide maximum read ahead extent
 	 *
@@ -1875,14 +1844,13 @@ struct cl_io {
 			struct cl_page *ft_page;
 		} ci_fault;
 		struct cl_fsync_io {
-			loff_t			 fi_start;
-			loff_t			 fi_end;
+			loff_t             fi_start;
+			loff_t             fi_end;
 			/** file system level fid */
-			struct lu_fid	 	*fi_fid;
-			enum cl_fsync_mode	 fi_mode;
+			struct lu_fid     *fi_fid;
+			enum cl_fsync_mode fi_mode;
 			/* how many pages were written/discarded */
-			unsigned int		 fi_nr_written;
-			enum cl_io_priority	 fi_prio;
+			unsigned int       fi_nr_written;
 		} ci_fsync;
 		struct cl_ladvise_io {
 			__u64			 lio_start;
@@ -2426,9 +2394,8 @@ int   cl_io_submit_sync(const struct lu_env *env, struct cl_io *io,
 			long timeout);
 int   cl_io_commit_async(const struct lu_env *env, struct cl_io *io,
 			  struct cl_page_list *queue, int from, int to,
-			  cl_commit_cbt cb, enum cl_io_priority prio);
-void  cl_io_extent_release(const struct lu_env *env, struct cl_io *io,
-			   enum cl_io_priority prio);
+			  cl_commit_cbt cb);
+void  cl_io_extent_release(const struct lu_env *env, struct cl_io *io);
 int cl_io_lru_reserve(const struct lu_env *env, struct cl_io *io,
 		      loff_t pos, size_t bytes);
 int   cl_io_read_ahead(const struct lu_env *env, struct cl_io *io,
diff --git a/lustre/include/lustre_osc.h b/lustre/include/lustre_osc.h
index a50c7b37ad..4988d9bf81 100644
--- a/lustre/include/lustre_osc.h
+++ b/lustre/include/lustre_osc.h
@@ -564,8 +564,7 @@ int osc_cache_truncate_start(const struct lu_env *env, struct osc_object *obj,
 			     __u64 size, struct osc_extent **extp);
 void osc_cache_truncate_end(const struct lu_env *env, struct osc_extent *ext);
 int osc_cache_writeback_range(const struct lu_env *env, struct osc_object *obj,
-			      pgoff_t start, pgoff_t end, int hp, int discard,
-			      enum cl_io_priority prio);
+			      pgoff_t start, pgoff_t end, int hp, int discard);
 int osc_cache_wait_range(const struct lu_env *env, struct osc_object *obj,
 			 pgoff_t start, pgoff_t end);
 int osc_io_unplug0(const struct lu_env *env, struct client_obd *cli,
@@ -647,10 +646,9 @@ int osc_dio_submit(const struct lu_env *env, struct cl_io *io,
 int osc_io_commit_async(const struct lu_env *env,
 			const struct cl_io_slice *ios,
 			struct cl_page_list *qin, int from, int to,
-			cl_commit_cbt cb, enum cl_io_priority prio);
+			cl_commit_cbt cb);
 void osc_io_extent_release(const struct lu_env *env,
-			   const struct cl_io_slice *ios,
-			   enum cl_io_priority prio);
+			   const struct cl_io_slice *ios);
 int osc_io_iter_init(const struct lu_env *env, const struct cl_io_slice *ios);
 void osc_io_iter_fini(const struct lu_env *env,
 		      const struct cl_io_slice *ios);
@@ -736,11 +734,6 @@ static inline struct client_obd *osc_cli(const struct osc_object *obj)
 	return &osc_export(obj)->exp_obd->u.cli;
 }
 
-static inline char *cli_name(struct client_obd *cli)
-{
-	return cli->cl_import->imp_obd->obd_name;
-}
-
 static inline struct osc_object *cl2osc(const struct cl_object *obj)
 {
 	return container_of_safe(obj, struct osc_object, oo_cl);
diff --git a/lustre/llite/file.c b/lustre/llite/file.c
index 6cceaf2ab9..75c915be10 100644
--- a/lustre/llite/file.c
+++ b/lustre/llite/file.c
@@ -5175,7 +5175,7 @@ static loff_t ll_file_seek(struct file *file, loff_t offset, int origin)
 
 		/* flush local cache first if any */
 		cl_sync_file_range(inode, offset, OBD_OBJECT_EOF,
-				   CL_FSYNC_LOCAL, 0, IO_PRIO_NORMAL);
+				   CL_FSYNC_LOCAL, 0);
 
 		retval = ll_lseek(file, offset, origin);
 		if (retval < 0)
@@ -5231,8 +5231,7 @@ static int ll_flush(struct file *file, fl_owner_t id)
  * Return how many pages have been written.
  */
 int cl_sync_file_range(struct inode *inode, loff_t start, loff_t end,
-		       enum cl_fsync_mode mode, int ignore_layout,
-		       enum cl_io_priority prio)
+		       enum cl_fsync_mode mode, int ignore_layout)
 {
 	struct lu_env *env;
 	struct cl_io *io;
@@ -5262,7 +5261,6 @@ int cl_sync_file_range(struct inode *inode, loff_t start, loff_t end,
 	fio->fi_fid = ll_inode2fid(inode);
 	fio->fi_mode = mode;
 	fio->fi_nr_written = 0;
-	fio->fi_prio = prio;
 
 	if (cl_io_init(env, io, CIT_FSYNC, io->ci_obj) == 0)
 		result = cl_io_loop(env, io);
@@ -5341,8 +5339,7 @@ int ll_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 		err = pcc_fsync(file, start, end, datasync, &cached);
 		if (!cached)
 			err = cl_sync_file_range(inode, start, end,
-						 CL_FSYNC_ALL, 0,
-						 IO_PRIO_NORMAL);
+						 CL_FSYNC_ALL, 0);
 		if (rc == 0 && err < 0)
 			rc = err;
 		if (rc < 0)
diff --git a/lustre/llite/llite_internal.h b/lustre/llite/llite_internal.h
index d4ebaaf694..98a408eec6 100644
--- a/lustre/llite/llite_internal.h
+++ b/lustre/llite/llite_internal.h
@@ -1365,8 +1365,7 @@ int ll_read_folio(struct file *file, struct folio *folio);
 int ll_io_read_page(const struct lu_env *env, struct cl_io *io,
 			   struct cl_page *page, struct file *file);
 void ll_readahead_init(struct inode *inode, struct ll_readahead_state *ras);
-int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io,
-			enum cl_io_priority prio);
+int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io);
 
 enum lcc_type;
 void ll_cl_add(struct inode *inode, const struct lu_env *env, struct cl_io *io,
@@ -1983,8 +1982,7 @@ dentry_may_statahead(struct inode *dir, struct dentry *dentry)
 }
 
 int cl_sync_file_range(struct inode *inode, loff_t start, loff_t end,
-		       enum cl_fsync_mode mode, int ignore_layout,
-		       enum cl_io_priority prio);
+		       enum cl_fsync_mode mode, int ignore_layout);
 
 static inline int ll_file_nolock(const struct file *file)
 {
diff --git a/lustre/llite/llite_lib.c b/lustre/llite/llite_lib.c
index dcc5ac60e8..0b1b84295f 100644
--- a/lustre/llite/llite_lib.c
+++ b/lustre/llite/llite_lib.c
@@ -3283,8 +3283,7 @@ void ll_delete_inode(struct inode *inode)
 		 * unlink, so that file is not opened somewhere else
 		 */
 		cl_sync_file_range(inode, 0, OBD_OBJECT_EOF, inode->i_nlink ?
-				   CL_FSYNC_LOCAL : CL_FSYNC_DISCARD, 1,
-				   IO_PRIO_NORMAL);
+				   CL_FSYNC_LOCAL : CL_FSYNC_DISCARD, 1);
 	}
 
 	ll_truncate_inode_pages_final(inode);
diff --git a/lustre/llite/rw.c b/lustre/llite/rw.c
index d7825a5e77..d0d04f5bb9 100644
--- a/lustre/llite/rw.c
+++ b/lustre/llite/rw.c
@@ -1543,7 +1543,7 @@ int ll_writepage(struct page *vmpage, struct writeback_control *wbc)
 		 */
 		result = cl_sync_file_range(inode, offset,
 					    offset + PAGE_SIZE - 1,
-					    CL_FSYNC_LOCAL, 1, IO_PRIO_NORMAL);
+					    CL_FSYNC_LOCAL, 1);
 		if (result > 0) {
 			/* May have written more than one page. decreasing this
 			 * page because the caller will count it.
@@ -1570,7 +1570,6 @@ out:
 int ll_writepages(struct address_space *mapping, struct writeback_control *wbc)
 {
 	struct inode *inode = mapping->host;
-	enum cl_io_priority prio = IO_PRIO_NORMAL;
 	loff_t start;
 	loff_t end;
 	enum cl_fsync_mode mode;
@@ -1612,11 +1611,8 @@ int ll_writepages(struct address_space *mapping, struct writeback_control *wbc)
 		wb = inode_to_wb(inode);
 		if (wbc->for_background ||
 		    (wb->start_all_reason == WB_REASON_VMSCAN &&
-		     test_bit(WB_start_all, &wb->state))) {
+		     test_bit(WB_start_all, &wb->state)))
 			mode = CL_FSYNC_RECLAIM;
-			if (wb->dirty_exceeded)
-				prio = IO_PRIO_DIRTY_EXCEEDED;
-		}
 		spin_unlock(&inode->i_lock);
 #else
 		/*
@@ -1638,7 +1634,7 @@ int ll_writepages(struct address_space *mapping, struct writeback_control *wbc)
 	 * inside the IO context of write, which will cause deadlock at
 	 * layout_conf since it waits for active IOs to complete.
 	 */
-	result = cl_sync_file_range(inode, start, end, mode, 1, prio);
+	result = cl_sync_file_range(inode, start, end, mode, 1);
 	if (result > 0) {
 		wbc->nr_to_write -= result;
 		result = 0;
diff --git a/lustre/llite/rw26.c b/lustre/llite/rw26.c
index 8c06b9749d..a420534f0b 100644
--- a/lustre/llite/rw26.c
+++ b/lustre/llite/rw26.c
@@ -781,7 +781,7 @@ again:
 		}
 
 		/* commit pages and then wait for page lock */
-		result = vvp_io_write_commit(env, io, IO_PRIO_NORMAL);
+		result = vvp_io_write_commit(env, io);
 		if (result < 0)
 			GOTO(out, result);
 
@@ -902,7 +902,6 @@ static int ll_write_end(struct file *file, struct address_space *mapping,
 	struct cl_page *page;
 	struct page *vmpage = wbe_folio_page(vmfolio);
 	unsigned from = pos & (PAGE_SIZE - 1);
-	enum cl_io_priority prio = IO_PRIO_NORMAL;
 	bool unplug = false;
 	int result = 0;
 	ENTRY;
@@ -926,25 +925,6 @@ static int ll_write_end(struct file *file, struct address_space *mapping,
 	LASSERT(cl_page_is_owned(page, io));
 	if (copied > 0) {
 		struct cl_page_list *plist = &vio->u.readwrite.vui_queue;
-#ifdef SB_I_CGROUPWB
-		struct inode *inode = file_inode(file);
-		struct bdi_writeback *wb;
-
-		__mark_inode_dirty(inode, I_DIRTY_PAGES);
-		spin_lock(&inode->i_lock);
-		wb = inode_to_wb(inode);
-		LASSERT(wb != NULL);
-		if (wb->dirty_exceeded) {
-			unplug = true;
-			prio = IO_PRIO_URGENT;
-			CDEBUG(D_IOTRACE, "wb@%pK dirty_ratelimit=%lu balanced_dirty_ratelimit=%lu dirty_exceeded=%d state=%lX last_old_flush=%lu\n",
-			       wb, wb->dirty_ratelimit,
-			       wb->balanced_dirty_ratelimit,
-			       wb->dirty_exceeded, wb->state,
-			       wb->last_old_flush);
-		}
-		spin_unlock(&inode->i_lock);
-#endif
 
 		lcc->lcc_page = NULL; /* page will be queued */
 
@@ -981,11 +961,12 @@ static int ll_write_end(struct file *file, struct address_space *mapping,
 	    io->u.ci_rw.crw_pos + io->u.ci_rw.crw_bytes)
 		unplug = true;
 	if (unplug)
-		result = vvp_io_write_commit(env, io, prio);
+		result = vvp_io_write_commit(env, io);
 
 	if (result < 0)
 		io->ci_result = result;
 
+
 out:
 	RETURN(result >= 0 ? copied : result);
 }
diff --git a/lustre/llite/vvp_internal.h b/lustre/llite/vvp_internal.h
index 8776db1985..33821e6598 100644
--- a/lustre/llite/vvp_internal.h
+++ b/lustre/llite/vvp_internal.h
@@ -247,8 +247,7 @@ struct vvp_object *cl_inode2vvp(struct inode *inode);
 
 int vvp_io_init(const struct lu_env *env, struct cl_object *obj,
 		struct cl_io *io);
-int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io,
-			enum cl_io_priority prio);
+int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io);
 int vvp_page_init(const struct lu_env *env, struct cl_object *obj,
 		  struct cl_page *page, pgoff_t index);
 struct lu_object *vvp_object_alloc(const struct lu_env *env,
diff --git a/lustre/llite/vvp_io.c b/lustre/llite/vvp_io.c
index a4d379e475..0878a3ebfc 100644
--- a/lustre/llite/vvp_io.c
+++ b/lustre/llite/vvp_io.c
@@ -1161,8 +1161,7 @@ static bool page_list_sanity_check(struct cl_object *obj,
 }
 
 /* Return how many bytes have queued or written */
-int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io,
-			enum cl_io_priority prio)
+int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io)
 {
 	struct cl_object *obj = io->ci_obj;
 	struct inode *inode = vvp_object_inode(obj);
@@ -1178,9 +1177,8 @@ int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io,
 	if (npages == 0)
 		RETURN(0);
 
-	CDEBUG(D_VFSTRACE, "commit async pages: %d, from %d, to %d prio %d\n",
-		npages, vio->u.readwrite.vui_from, vio->u.readwrite.vui_to,
-		prio);
+	CDEBUG(D_VFSTRACE, "commit async pages: %d, from %d, to %d\n",
+		npages, vio->u.readwrite.vui_from, vio->u.readwrite.vui_to);
 
 	LASSERT(page_list_sanity_check(obj, queue));
 
@@ -1188,7 +1186,7 @@ int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io,
 	rc = cl_io_commit_async(env, io, queue,
 				vio->u.readwrite.vui_from,
 				vio->u.readwrite.vui_to,
-				write_commit_callback, prio);
+				write_commit_callback);
 	npages -= queue->pl_nr; /* already committed pages */
 	if (npages > 0) {
 		/* calculate how many bytes were written */
@@ -1212,7 +1210,7 @@ int vvp_io_write_commit(const struct lu_env *env, struct cl_io *io,
 	LASSERT(ergo(rc == 0, queue->pl_nr == 0));
 
 	/* out of quota, try sync write */
-	if ((rc == -EDQUOT && !cl_io_is_mkwrite(io)) || prio > IO_PRIO_NORMAL) {
+	if (rc == -EDQUOT && !cl_io_is_mkwrite(io)) {
 		struct ll_inode_info *lli = ll_i2info(inode);
 
 		rc = vvp_io_commit_sync(env, io, queue,
@@ -1356,7 +1354,7 @@ static int vvp_io_write_start(const struct lu_env *env,
 	}
 
 	if (result > 0) {
-		result = vvp_io_write_commit(env, io, IO_PRIO_NORMAL);
+		result = vvp_io_write_commit(env, io);
 		/* Simulate short commit */
 		if (CFS_FAULT_CHECK(OBD_FAIL_LLITE_SHORT_COMMIT)) {
 			vio->u.readwrite.vui_written >>= 1;
@@ -1594,8 +1592,7 @@ static int vvp_io_fault_start(const struct lu_env *env,
 			 * still have chance to detect it.
 			 */
 			result = cl_io_commit_async(env, io, plist, 0, to,
-						    mkwrite_commit_callback,
-						    IO_PRIO_NORMAL);
+						    mkwrite_commit_callback);
 			/* Have overquota flag, trying sync write to check
 			 * whether indeed out of quota
 			 */
@@ -1609,8 +1606,7 @@ static int vvp_io_fault_start(const struct lu_env *env,
 					cl_page_list_add(plist, page, true);
 					result = cl_io_commit_async(env, io,
 						plist, 0, to,
-						mkwrite_commit_callback,
-						IO_PRIO_NORMAL);
+						mkwrite_commit_callback);
 					io->ci_noquota = 0;
 				} else {
 					cl_page_put(env, page);
diff --git a/lustre/llite/vvp_object.c b/lustre/llite/vvp_object.c
index f7a67f91d3..b81140e608 100644
--- a/lustre/llite/vvp_object.c
+++ b/lustre/llite/vvp_object.c
@@ -162,8 +162,7 @@ static int vvp_prune(const struct lu_env *env, struct cl_object *obj)
 	int rc;
 
 	ENTRY;
-	rc = cl_sync_file_range(inode, 0, OBD_OBJECT_EOF, CL_FSYNC_LOCAL, 1,
-				IO_PRIO_NORMAL);
+	rc = cl_sync_file_range(inode, 0, OBD_OBJECT_EOF, CL_FSYNC_LOCAL, 1);
 	if (rc < 0) {
 		CDEBUG(D_VFSTRACE, DFID ": writeback failed: %d\n",
 		       PFID(lu_object_fid(&obj->co_lu)), rc);
diff --git a/lustre/lov/lov_io.c b/lustre/lov/lov_io.c
index b5dcbac55f..34849e1e67 100644
--- a/lustre/lov/lov_io.c
+++ b/lustre/lov/lov_io.c
@@ -758,7 +758,6 @@ static void lov_io_sub_inherit(struct lov_io_sub *sub, struct lov_io *lio,
 		io->u.ci_fsync.fi_end = end;
 		io->u.ci_fsync.fi_fid = parent->u.ci_fsync.fi_fid;
 		io->u.ci_fsync.fi_mode = parent->u.ci_fsync.fi_mode;
-		io->u.ci_fsync.fi_prio = parent->u.ci_fsync.fi_prio;
 		break;
 	}
 	case CIT_READ:
@@ -1446,11 +1445,10 @@ static int lov_io_submit(const struct lu_env *env,
 static int lov_io_commit_async(const struct lu_env *env,
 			       const struct cl_io_slice *ios,
 			       struct cl_page_list *queue, int from, int to,
-			       cl_commit_cbt cb, enum cl_io_priority prio)
+			       cl_commit_cbt cb)
 {
 	struct cl_page_list *plist = &lov_env_info(env)->lti_plist;
 	struct lov_io *lio = cl2lov_io(env, ios);
-	bool hp = cl_io_high_prio(prio);
 	struct lov_io_sub *sub;
 	struct cl_page *page;
 	int rc = 0;
@@ -1465,7 +1463,7 @@ static int lov_io_commit_async(const struct lu_env *env,
 		LASSERT(!IS_ERR(sub));
 		LASSERT(sub == &lio->lis_single_subio);
 		rc = cl_io_commit_async(sub->sub_env, &sub->sub_io, queue,
-					from, to, cb, prio);
+					from, to, cb);
 		RETURN(rc);
 	}
 
@@ -1495,8 +1493,7 @@ static int lov_io_commit_async(const struct lu_env *env,
 		sub = lov_sub_get(env, lio, index);
 		if (!IS_ERR(sub)) {
 			rc = cl_io_commit_async(sub->sub_env, &sub->sub_io,
-						plist, from, stripe_to, cb,
-						prio);
+						plist, from, stripe_to, cb);
 		} else {
 			rc = PTR_ERR(sub);
 			break;
@@ -1507,14 +1504,9 @@ static int lov_io_commit_async(const struct lu_env *env,
 
 		from = 0;
 
-		if (!hp && lov_comp_entry(index) !=
+		if (lov_comp_entry(index) !=
 		    lov_comp_entry(page->cp_lov_index))
-			cl_io_extent_release(sub->sub_env, &sub->sub_io, prio);
-	}
-
-	if (rc == 0 && hp) {
-		list_for_each_entry(sub, &lio->lis_subios, sub_list)
-			cl_io_extent_release(sub->sub_env, &sub->sub_io, prio);
+			cl_io_extent_release(sub->sub_env, &sub->sub_io);
 	}
 
 	/* for error case, add the page back into the qin list */
diff --git a/lustre/mdc/mdc_dev.c b/lustre/mdc/mdc_dev.c
index c44e310a02..9bb0348ee6 100644
--- a/lustre/mdc/mdc_dev.c
+++ b/lustre/mdc/mdc_dev.c
@@ -256,7 +256,7 @@ static int mdc_lock_flush(const struct lu_env *env, struct osc_object *obj,
 
 	if (mode == CLM_WRITE) {
 		result = osc_cache_writeback_range(env, obj, start, end, 1,
-						   discard, IO_PRIO_NORMAL);
+						   discard);
 		CDEBUG(D_CACHE, "object %p: [%lu -> %lu] %d pages were %s.\n",
 		       obj, start, end, result,
 		       discard ? "discarded" : "written back");
@@ -1182,16 +1182,9 @@ static int mdc_io_fsync_start(const struct lu_env *env,
 	if (fio->fi_mode == CL_FSYNC_RECLAIM) {
 		struct client_obd *cli = osc_cli(osc);
 
-		if (!atomic_read(&osc->oo_nr_ios) &&
-		    !atomic_read(&osc->oo_nr_writes) &&
-		    !atomic_long_read(&cli->cl_unstable_count)) {
-			/*
-			 * No active IO, no dirty pages needing to write and no
-			 * unstable pages needing to commit.
-			 */
-			CDEBUG(D_CACHE,
-			       "%s: dirty/unstable counts are both zero\n",
-			       cli_name(cli));
+		if (!atomic_long_read(&cli->cl_unstable_count)) {
+			/* Stop flush when there are no unstable pages? */
+			CDEBUG(D_CACHE, "unstable count is zero\n");
 			RETURN(0);
 		}
 	}
@@ -1200,8 +1193,7 @@ static int mdc_io_fsync_start(const struct lu_env *env,
 	 * possible range despite of supplied start/end values.
 	 */
 	result = osc_cache_writeback_range(env, osc, 0, CL_PAGE_EOF, 0,
-					   fio->fi_mode == CL_FSYNC_DISCARD,
-					   fio->fi_prio);
+					   fio->fi_mode == CL_FSYNC_DISCARD);
 	if (result > 0) {
 		fio->fi_nr_written += result;
 		result = 0;
diff --git a/lustre/obdclass/cl_io.c b/lustre/obdclass/cl_io.c
index d4a9f89f9d..ef209f54bb 100644
--- a/lustre/obdclass/cl_io.c
+++ b/lustre/obdclass/cl_io.c
@@ -631,14 +631,13 @@ EXPORT_SYMBOL(cl_io_lru_reserve);
  * @from: Starting position
  * @to: Ending position
  * @cb: callback function
- * @prio: I/O priority
  *
  * Returns 0 if all pages committed, or errcode if error occurred.
  * see cl_io_operations::cio_commit_async()
  */
 int cl_io_commit_async(const struct lu_env *env, struct cl_io *io,
 		       struct cl_page_list *queue, int from, int to,
-		       cl_commit_cbt cb, enum cl_io_priority prio)
+		       cl_commit_cbt cb)
 {
 	const struct cl_io_slice *scan;
 	int result = 0;
@@ -648,7 +647,7 @@ int cl_io_commit_async(const struct lu_env *env, struct cl_io *io,
 		if (scan->cis_iop->cio_commit_async == NULL)
 			continue;
 		result = scan->cis_iop->cio_commit_async(env, scan, queue,
-							 from, to, cb, prio);
+							 from, to, cb);
 		if (result != 0)
 			break;
 	}
@@ -656,8 +655,7 @@ int cl_io_commit_async(const struct lu_env *env, struct cl_io *io,
 }
 EXPORT_SYMBOL(cl_io_commit_async);
 
-void cl_io_extent_release(const struct lu_env *env, struct cl_io *io,
-			  enum cl_io_priority prio)
+void cl_io_extent_release(const struct lu_env *env, struct cl_io *io)
 {
 	const struct cl_io_slice *scan;
 	ENTRY;
@@ -665,7 +663,7 @@ void cl_io_extent_release(const struct lu_env *env, struct cl_io *io,
 	list_for_each_entry(scan, &io->ci_layers, cis_linkage) {
 		if (scan->cis_iop->cio_extent_release == NULL)
 			continue;
-		scan->cis_iop->cio_extent_release(env, scan, prio);
+		scan->cis_iop->cio_extent_release(env, scan);
 	}
 	EXIT;
 }
diff --git a/lustre/osc/osc_cache.c b/lustre/osc/osc_cache.c
index 86a9b818c4..c7b0859aa3 100644
--- a/lustre/osc/osc_cache.c
+++ b/lustre/osc/osc_cache.c
@@ -196,7 +196,8 @@ static int osc_extent_sanity_check0(struct osc_extent *ext,
 			GOTO(out, rc = 65);
 		fallthrough;
 	default:
-		break;
+		if (atomic_read(&ext->oe_users) > 0)
+			GOTO(out, rc = 70);
 	}
 
 	if (ext->oe_max_end < ext->oe_end || ext->oe_end < ext->oe_start)
@@ -563,13 +564,10 @@ static int osc_extent_merge(const struct lu_env *env, struct osc_extent *cur,
 /**
  * Drop user count of osc_extent, and unplug IO asynchronously.
  */
-void osc_extent_release(const struct lu_env *env, struct osc_extent *ext,
-			enum cl_io_priority prio)
+void osc_extent_release(const struct lu_env *env, struct osc_extent *ext)
 {
 	struct osc_object *obj = ext->oe_obj;
 	struct client_obd *cli = osc_cli(obj);
-	bool hp = cl_io_high_prio(prio);
-
 	ENTRY;
 
 	LASSERT(atomic_read(&ext->oe_users) > 0);
@@ -577,26 +575,15 @@ void osc_extent_release(const struct lu_env *env, struct osc_extent *ext,
 	LASSERT(ext->oe_grants > 0);
 
 	if (atomic_dec_and_lock(&ext->oe_users, &obj->oo_lock)) {
+		LASSERT(ext->oe_state == OES_ACTIVE);
 		if (ext->oe_trunc_pending) {
-			/*
-			 * A truncate process is waiting for this extent.
+			/* a truncate process is waiting for this extent.
 			 * This may happen due to a race, check
-			 * osc_cache_truncate_start().
-			 */
-			if (ext->oe_state != OES_ACTIVE) {
-				int rc;
-
-				osc_object_unlock(obj);
-				rc = osc_extent_wait(env, ext, OES_INV);
-				if (rc < 0)
-					OSC_EXTENT_DUMP(D_ERROR, ext,
-							"error: %d.\n", rc);
-				osc_object_lock(obj);
-			}
+			 * osc_cache_truncate_start(). */
 			osc_extent_state_set(ext, OES_TRUNC);
 			ext->oe_trunc_pending = 0;
 			osc_object_unlock(obj);
-		} else if (ext->oe_state == OES_ACTIVE) {
+		} else {
 			int grant = 0;
 
 			osc_extent_state_set(ext, OES_CACHE);
@@ -609,16 +596,17 @@ void osc_extent_release(const struct lu_env *env, struct osc_extent *ext,
 			if (osc_extent_merge(env, ext, next_extent(ext)) == 0)
 				grant += cli->cl_grant_extent_tax;
 
-			if (!hp && !ext->oe_rw && ext->oe_dlmlock) {
+			if (!ext->oe_rw && ext->oe_dlmlock) {
+				bool hp;
+
 				lock_res_and_lock(ext->oe_dlmlock);
 				hp = ldlm_is_cbpending(ext->oe_dlmlock);
 				unlock_res_and_lock(ext->oe_dlmlock);
-			}
-
 
-			/* HP extent should be written ASAP. */
-			if (hp)
-				ext->oe_hp = 1;
+				/* HP extent should be written ASAP. */
+				if (hp)
+					ext->oe_hp = 1;
+			}
 
 			if (ext->oe_hp)
 				list_move_tail(&ext->oe_link,
@@ -633,14 +621,9 @@ void osc_extent_release(const struct lu_env *env, struct osc_extent *ext,
 			osc_object_unlock(obj);
 			if (grant > 0)
 				osc_unreserve_grant(cli, 0, grant);
-		} else {
-			osc_object_unlock(obj);
 		}
 
-		if (unlikely(cl_io_high_prio(prio)))
-			osc_io_unplug(env, cli, obj);
-		else
-			osc_io_unplug_async(env, cli, obj);
+		osc_io_unplug_async(env, cli, obj);
 	}
 	osc_extent_put(env, ext);
 
@@ -933,7 +916,7 @@ static int osc_extent_wait(const struct lu_env *env, struct osc_extent *ext,
 	}
 	osc_object_unlock(obj);
 	if (rc == 1)
-		osc_extent_release(env, ext, IO_PRIO_NORMAL);
+		osc_extent_release(env, ext);
 
 	/* wait for the extent until its state becomes @state */
 	rc = wait_event_idle_timeout(ext->oe_waitq,
@@ -1177,9 +1160,6 @@ static int osc_extent_expand(struct osc_extent *ext, pgoff_t index,
 
 	LASSERT(ext->oe_max_end >= index && ext->oe_start <= index);
 	osc_object_lock(obj);
-	if (ext->oe_state != OES_ACTIVE)
-		GOTO(out, rc = -ESTALE);
-
 	LASSERT(sanity_check_nolock(ext) == 0);
 	end_chunk = ext->oe_end >> ppc_bits;
 	if (chunk > end_chunk + 1)
@@ -2362,10 +2342,7 @@ int osc_queue_async_io(const struct lu_env *env, struct cl_io *io,
 	 * 2. otherwise, a new extent will be allocated. */
 
 	ext = oio->oi_active;
-	if (ext != NULL && ext->oe_state != OES_ACTIVE) {
-		need_release = 1;
-	} else if (ext != NULL && ext->oe_start <= index &&
-		   ext->oe_max_end >= index) {
+	if (ext != NULL && ext->oe_start <= index && ext->oe_max_end >= index) {
 		/* one chunk plus extent overhead must be enough to write this
 		 * page */
 		grants = (1 << cli->cl_chunkbits) + cli->cl_grant_extent_tax;
@@ -2399,7 +2376,7 @@ int osc_queue_async_io(const struct lu_env *env, struct cl_io *io,
 		need_release = 1;
 	}
 	if (need_release) {
-		osc_extent_release(env, ext, IO_PRIO_NORMAL);
+		osc_extent_release(env, ext);
 		oio->oi_active = NULL;
 		ext = NULL;
 	}
@@ -2430,7 +2407,6 @@ int osc_queue_async_io(const struct lu_env *env, struct cl_io *io,
 				grants = tmp;
 		}
 
-restart_find:
 		tmp = grants;
 		if (rc == 0) {
 			ext = osc_extent_find(env, osc, index, &tmp);
@@ -2454,28 +2430,6 @@ restart_find:
 		LASSERT((oap->oap_brw_flags & OBD_BRW_FROM_GRANT) != 0);
 
 		osc_object_lock(osc);
-		if (ext->oe_state != OES_ACTIVE) {
-			if (ext->oe_state == OES_CACHE) {
-				osc_extent_state_set(ext, OES_ACTIVE);
-				osc_update_pending(osc, OBD_BRW_WRITE,
-						   -ext->oe_nr_pages);
-				list_del_init(&ext->oe_link);
-			} else {
-				osc_object_unlock(osc);
-				osc_extent_get(ext);
-				osc_extent_release(env, ext, IO_PRIO_NORMAL);
-				oio->oi_active = NULL;
-
-				/* Waiting for IO finished.  */
-				rc = osc_extent_wait(env, ext, OES_INV);
-				osc_extent_put(env, ext);
-				if (rc < 0)
-					RETURN(rc);
-
-				GOTO(restart_find, rc);
-			}
-		}
-
 		if (ext->oe_nr_pages == 0)
 			ext->oe_srvlock = ops->ops_srvlock;
 		else
@@ -3137,18 +3091,14 @@ EXPORT_SYMBOL(osc_cache_wait_range);
  * Return how many pages will be issued, or error code if error occurred.
  */
 int osc_cache_writeback_range(const struct lu_env *env, struct osc_object *obj,
-			      pgoff_t start, pgoff_t end, int hp, int discard,
-			      enum cl_io_priority prio)
+			      pgoff_t start, pgoff_t end, int hp, int discard)
 {
 	struct osc_extent *ext;
 	LIST_HEAD(discard_list);
-	bool active_ext_check = false;
 	bool unplug = false;
 	int result = 0;
-
 	ENTRY;
 
-repeat:
 	osc_object_lock(obj);
 	ext = osc_extent_search(obj, start);
 	if (ext == NULL)
@@ -3220,16 +3170,6 @@ repeat:
 			 * grants. We do this for the correctness of fsync. */
 			LASSERT(hp == 0 && discard == 0);
 			ext->oe_urgent = 1;
-
-			if (active_ext_check) {
-				osc_extent_state_set(ext, OES_CACHE);
-				list_move_tail(&ext->oe_link,
-					       &obj->oo_urgent_exts);
-				osc_update_pending(obj, OBD_BRW_WRITE,
-						   ext->oe_nr_pages);
-				unplug = true;
-			}
-
 			break;
 		case OES_TRUNC:
 			/* this extent is being truncated, can't do anything
@@ -3277,22 +3217,7 @@ repeat:
 			result = rc;
 	}
 
-	OSC_IO_DEBUG(obj, "pageout [%lu, %lu] npages %lu: rc=%d.\n",
-		     start, end, obj->oo_npages, result);
-
-	/*
-	 * Try to flush the active I/O extents of the object.
-	 * Otherwise, the user process writing the file may be dirty exceeded
-	 * and waiting endless in balance_dirty_pages().
-	 */
-	if (result == 0 && prio == IO_PRIO_DIRTY_EXCEEDED &&
-	    !active_ext_check && atomic_read(&obj->oo_nr_ios) &&
-	    obj->oo_npages > 0) {
-		osc_extent_tree_dump(D_CACHE, obj);
-		active_ext_check = true;
-		GOTO(repeat, result);
-	}
-
+	OSC_IO_DEBUG(obj, "pageout [%lu, %lu], %d.\n", start, end, result);
 	RETURN(result);
 }
 EXPORT_SYMBOL(osc_cache_writeback_range);
diff --git a/lustre/osc/osc_internal.h b/lustre/osc/osc_internal.h
index 3778394449..4a96296fb7 100644
--- a/lustre/osc/osc_internal.h
+++ b/lustre/osc/osc_internal.h
@@ -28,8 +28,7 @@ void osc_update_next_shrink(struct client_obd *cli);
 void lru_queue_work(struct work_struct *work);
 int osc_extent_finish(const struct lu_env *env, struct osc_extent *ext,
 		      int sent, int rc);
-void osc_extent_release(const struct lu_env *env, struct osc_extent *ext,
-			enum cl_io_priority prio);
+void osc_extent_release(const struct lu_env *env, struct osc_extent *ext);
 int osc_lock_discard_pages(const struct lu_env *env, struct osc_object *osc,
 			   pgoff_t start, pgoff_t end, bool discard);
 int osc_ldlm_hp_handle(const struct lu_env *env, struct osc_object *obj,
@@ -110,6 +109,11 @@ static inline unsigned long rpcs_in_flight(struct client_obd *cli)
 	return cli->cl_r_in_flight + cli->cl_w_in_flight;
 }
 
+static inline char *cli_name(struct client_obd *cli)
+{
+	return cli->cl_import->imp_obd->obd_name;
+}
+
 static inline char list_empty_marker(struct list_head *list)
 {
 	return list_empty(list) ? '-' : '+';
diff --git a/lustre/osc/osc_io.c b/lustre/osc/osc_io.c
index 68fb12dbc5..5675e3138e 100644
--- a/lustre/osc/osc_io.c
+++ b/lustre/osc/osc_io.c
@@ -392,7 +392,7 @@ void osc_page_touch_at(const struct lu_env *env, struct cl_object *obj,
 int osc_io_commit_async(const struct lu_env *env,
 			const struct cl_io_slice *ios,
 			struct cl_page_list *qin, int from, int to,
-			cl_commit_cbt cb, enum cl_io_priority prio)
+			cl_commit_cbt cb)
 {
 	struct cl_io *io = ios->cis_io;
 	struct osc_io *oio = cl2osc_io(env, ios);
@@ -470,8 +470,8 @@ int osc_io_commit_async(const struct lu_env *env,
 	/* for sync write, kernel will wait for this page to be flushed before
 	 * osc_io_end() is called, so release it earlier.
 	 * for mkwrite(), it's known there is no further pages. */
-	if (cl_io_is_sync_write(io) && oio->oi_active) {
-		osc_extent_release(env, oio->oi_active, prio);
+	if (cl_io_is_sync_write(io) && oio->oi_active != NULL) {
+		osc_extent_release(env, oio->oi_active);
 		oio->oi_active = NULL;
 	}
 
@@ -481,13 +481,12 @@ int osc_io_commit_async(const struct lu_env *env,
 EXPORT_SYMBOL(osc_io_commit_async);
 
 void osc_io_extent_release(const struct lu_env *env,
-			   const struct cl_io_slice *ios,
-			   enum cl_io_priority prio)
+			   const struct cl_io_slice *ios)
 {
 	struct osc_io *oio = cl2osc_io(env, ios);
 
 	if (oio->oi_active != NULL) {
-		osc_extent_release(env, oio->oi_active, prio);
+		osc_extent_release(env, oio->oi_active);
 		oio->oi_active = NULL;
 	}
 }
@@ -657,8 +656,7 @@ int osc_punch_start(const struct lu_env *env, struct cl_io *io,
 	int rc;
 
 	ENTRY;
-	rc = osc_cache_writeback_range(env, osc, pg_start, pg_end, 1, 0,
-				       IO_PRIO_NORMAL);
+	rc = osc_cache_writeback_range(env, osc, pg_start, pg_end, 1, 0);
 	if (rc < 0)
 		RETURN(rc);
 
@@ -1078,16 +1076,9 @@ static int osc_io_fsync_start(const struct lu_env *env,
 	if (fio->fi_mode == CL_FSYNC_RECLAIM) {
 		struct client_obd *cli = osc_cli(osc);
 
-		if (!atomic_read(&osc->oo_nr_ios) &&
-		    !atomic_read(&osc->oo_nr_writes) &&
-		    !atomic_long_read(&cli->cl_unstable_count)) {
-			/*
-			 * No active I/O, no dirty pages needing to write and
-			 * no unstable pages needing to commit.
-			 */
-			CDEBUG(D_CACHE,
-			       "%s: unstable/dirty counts are both zero\n",
-			       cli_name(cli));
+		if (!atomic_long_read(&cli->cl_unstable_count)) {
+			/* Stop flush when there are no unstable pages? */
+			CDEBUG(D_CACHE, "unstable count is zero\n");
 			RETURN(0);
 		}
 	}
@@ -1096,8 +1087,7 @@ static int osc_io_fsync_start(const struct lu_env *env,
 		end = CL_PAGE_EOF;
 
 	result = osc_cache_writeback_range(env, osc, start, end, 0,
-					   fio->fi_mode == CL_FSYNC_DISCARD,
-					   fio->fi_prio);
+					   fio->fi_mode == CL_FSYNC_DISCARD);
 	if (result < 0 && fio->fi_mode == CL_FSYNC_DISCARD) {
 		CDEBUG(D_CACHE,
 		       "%s: ignore error %d on discarding "DFID":[%lu-%lu]\n",
@@ -1238,7 +1228,7 @@ void osc_io_end(const struct lu_env *env, const struct cl_io_slice *slice)
 	struct osc_io *oio = cl2osc_io(env, slice);
 
 	if (oio->oi_active) {
-		osc_extent_release(env, oio->oi_active, IO_PRIO_NORMAL);
+		osc_extent_release(env, oio->oi_active);
 		oio->oi_active = NULL;
 	}
 }
diff --git a/lustre/osc/osc_lock.c b/lustre/osc/osc_lock.c
index 237d20c1c1..f6689f152f 100644
--- a/lustre/osc/osc_lock.c
+++ b/lustre/osc/osc_lock.c
@@ -349,7 +349,7 @@ static int osc_lock_flush(struct osc_object *obj, pgoff_t start, pgoff_t end,
 
 	if (mode == CLM_WRITE) {
 		rc = osc_cache_writeback_range(env, obj, start, end, 1,
-					       discard, IO_PRIO_NORMAL);
+					       discard);
 		CDEBUG(D_CACHE, "object %p: [%lu -> %lu] %d pages were %s.\n",
 		       obj, start, end, rc,
 		       discard ? "discarded" : "written back");

</pre>
</body>
</html>
