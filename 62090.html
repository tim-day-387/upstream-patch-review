<html lang="en">
<body>
<pre>
From 061a22e75be462a6394ba61beab4932b3bea5e2c Mon Sep 17 00:00:00 2001
From: Etienne AUJAMES <etienne.aujames@cea.fr>
Date: Wed, 29 Oct 2025 10:04:38 +0100
Subject: [PATCH 1/1] LU-19273 utils: add changelog_rec_hsm() helper function

This function return an union (changelog_rec_hsm_flags) to access to
HSM bitfiled information stores in the record "flags" field.

The patch updates hsm_(set|get)_cl_* helpers to use the bitfield
struct instead of bit operations for more clarity.

The manpage changelog_rec_hsm.7 has been introduced to document the
meaning and format of HSM changelog events.

2 examples of usages are added in llog_reader and "lfs changelog" to
decode HSM information (print HSM record type, error and flags).

Test-Parameters: trivial
Test-Parameters: testlist=sanity-hsm
Test-Parameters: testlist=sanity-hsm
Signed-off-by: Etienne AUJAMES <eaujames@ddn.com>
Change-Id: I88c92fb596e9ac1b3c3530cdc538f0501c6251b9
---
 Documentation/man7/Makefile.am                |  1 +
 Documentation/man7/changelog_rec_hsm.7        | 95 +++++++++++++++++++
 .../include/uapi/linux/lustre/lustre_user.h   | 83 +++++++++-------
 lustre/utils/lfs.c                            |  9 ++
 lustre/utils/llog_reader.c                    |  9 ++
 5 files changed, 165 insertions(+), 32 deletions(-)
 create mode 100644 Documentation/man7/changelog_rec_hsm.7

diff --git a/Documentation/man7/Makefile.am b/Documentation/man7/Makefile.am
index 113641921e..951a4c7d76 100644
--- a/Documentation/man7/Makefile.am
+++ b/Documentation/man7/Makefile.am
@@ -10,6 +10,7 @@ MANFILES =					\
 
 
 LIBMAN = 					\
+	changelog_rec_hsm.7			\
 	lustreapi.7				\
 	llapi_layout.7
 
diff --git a/Documentation/man7/changelog_rec_hsm.7 b/Documentation/man7/changelog_rec_hsm.7
new file mode 100644
index 0000000000..153b6b0792
--- /dev/null
+++ b/Documentation/man7/changelog_rec_hsm.7
@@ -0,0 +1,95 @@
+.TH CHANGELOG_REC_HSM 7 2025-10-28 "Lustre User API" "Lustre Miscellaneous Information"
+.SH NAME
+changelog_rec_hsm() \- Get HSM information from a changelog record
+.SH SYNOPSIS
+.nf
+.B #include <lustre/lustreapi.h>
+.PP
+.B static inline
+.BI "union changelog_rec_hsm_flags changelog_rec_hsm(const struct changelog_rec *" rec ");"
+.fi
+.SH DESCRIPTION
+The inline function
+.B changelog_rec_hsm()
+returns HSM information embedded inside a changelog record
+.IR rec .
+HSM data are stored inside a bitfield in the record "flags" field
+.RI ( rec->cr_flags ).
+.TS
+tab(;) allbox;
+cb s s s
+l l l l.
+cr_flags (16 bits);
+12-15 spare (4 bits);10-11 flags (2 bits);7-9 event (3 bits);0-6 error (7 bits);
+.TE
+.P
+HSM record flags format
+.P
+.B changelog_rec_hsm()
+returns the following union to access to the bitfield:
+.PP
+.BR "union changelog_rec_hsm_flags" " {"
+.EX
+        __u16 hf_flags;
+        struct {
+                __u16 error : 7;
+                __u16 event : 3;
+                __u16 flags : 2;
+                __u16 spare : 4;
+        } hf_bits;
+};
+.EE
+.TP
+.BR hf_bits.event :
+This field stores the type of HSM event (e.g: HE_ARCHIVE, archive event).
+.TP
+.BR hf_bits.error :
+This field stores the error code of HSM event (e.g: "event=HE_ARCHIVE,
+error=2" means that the archive failed with "No such file or directory").
+.TP
+.BR hf_bits.flags :
+This field stores flags associated to a HSM event. Only one flag is used
+for now:
+.BR CLF_HSM_DIRTY =1.
+This flag indicates that the HSM state has been marked as "dirty" (e.g: a write
+operation modified the file and updated the HSM state with dirty flag set).
+
+.SH HSM EVENT TYPES
+.PP
+.BR "enum hsm_event" " {"
+.EX
+        HE_ARCHIVE      = 0,
+        HE_RESTORE      = 1,
+        HE_CANCEL       = 2,
+        HE_RELEASE      = 3,
+        HE_REMOVE       = 4,
+        HE_STATE        = 5,
+        HE_SPARE1       = 6,
+        HE_SPARE2       = 7,
+};
+.TP
+.BR HE_ARCHIVE :
+Event on HSM archive success or failure (error > 0).
+.TP
+.BR HE_RESTORE :
+Event on HSM restore success or failure (error > 0).
+.TP
+.BR HE_CANCEL :
+Event on HSM cancel success or failure (error > 0).
+.TP
+.BR HE_STATE :
+Event on HSM state modification.
+
+.SH RETURN VALUES
+.PP
+Return HSM record flag bitfield
+.RB ( "union changelog_rec_hsm_flags" ).
+
+.SH SEE ALSO
+.BR lfs-changelog (1),
+.BR llapi_changelog_clear (3),
+.BR llapi_changelog_get_fd (3),
+.BR llapi_changelog_in_buf (3),
+.BR llapi_changelog_recv (3),
+.BR llapi_changelog_start (3),
+.BR lustreapi (7)
diff --git a/lustre/include/uapi/linux/lustre/lustre_user.h b/lustre/include/uapi/linux/lustre/lustre_user.h
index ced4b58b5e..ad7fd11772 100644
--- a/lustre/include/uapi/linux/lustre/lustre_user.h
+++ b/lustre/include/uapi/linux/lustre/lustre_user.h
@@ -1862,27 +1862,16 @@ enum changelog_rec_flags {
 					* has an archive in backend
 					*/
 
-/* Flags for HSM */
-/* 12b used (from high weight to low weight):
- * 2b for flags
- * 3b for event
- * 7b for error code
- */
-#define CLF_HSM_ERR_L        0 /* HSM return code, 7 bits */
-#define CLF_HSM_ERR_H        6
-#define CLF_HSM_EVENT_L      7 /* HSM event, 3 bits, see enum hsm_event */
-#define CLF_HSM_EVENT_H      9
-#define CLF_HSM_FLAG_L      10 /* HSM flags, 2 bits, 1 used, 1 spare */
-#define CLF_HSM_FLAG_H      11
-#define CLF_HSM_SPARE_L     12 /* 4 spare bits */
-#define CLF_HSM_SPARE_H     15
-#define CLF_HSM_LAST        15
-
-/* Remove bits higher than _h, then extract the value
- * between _h and _l by shifting lower weigth to bit 0.
- */
-#define CLF_GET_BITS(_b, _h, _l) (((_b << (CLF_HSM_LAST - _h)) & 0xFFFF) \
-				   >> (CLF_HSM_LAST - _h + _l))
+/* HSM bitfield for record flags */
+union changelog_rec_hsm_flags {
+	__u16 hf_flags;
+	struct {
+		__u16 error : 7; /* 0-6: HSM return code, 7 bits */
+		__u16 event : 3; /* 7-9: HSM event, 3 bits, see enum hsm_event */
+		__u16 flags : 2; /* 10-11: flags, 2 bits, 1 used, 1 spare */
+		__u16 spare : 4; /* 12-15: 4 spare bits */
+	} hf_bits;
+};
 
 #define CLF_HSM_SUCCESS      0x00
 #define CLF_HSM_MAXERROR     0x7E
@@ -1902,47 +1891,69 @@ enum hsm_event {
 	HE_SPARE2       = 7,
 };
 
+static inline const char *hsm_event2str(enum hsm_event ev)
+{
+	static const char *event2str[] = {
+		"ARCHIVE", "RESTORE", "CANCEL", "RELEASE", "REMOVE", "STATE",
+	};
+
+	if (ev < 0 || ev > HE_STATE)
+		return NULL;
+
+	return event2str[ev];
+}
+
 static inline enum hsm_event hsm_get_cl_event(__u16 flags)
 {
-	return (enum hsm_event)CLF_GET_BITS(flags, CLF_HSM_EVENT_H,
-					    CLF_HSM_EVENT_L);
+	union changelog_rec_hsm_flags fl = { .hf_flags = flags };
+
+	return (enum hsm_event) fl.hf_bits.event;
 }
 
 static inline void hsm_set_cl_event(enum changelog_rec_flags *clf_flags,
 				    enum hsm_event he)
 {
-	*clf_flags = (enum changelog_rec_flags)
-		(*clf_flags | (he << CLF_HSM_EVENT_L));
+	union changelog_rec_hsm_flags fl = { .hf_flags = *clf_flags };
+
+	fl.hf_bits.event = he;
+	*clf_flags = (enum changelog_rec_flags) fl.hf_flags;
 }
 
 static inline __u16 hsm_get_cl_flags(enum changelog_rec_flags clf_flags)
 {
-	return CLF_GET_BITS(clf_flags, CLF_HSM_FLAG_H, CLF_HSM_FLAG_L);
+	union changelog_rec_hsm_flags fl = { .hf_flags = clf_flags };
+
+	return fl.hf_bits.flags;
 }
 
 static inline void hsm_set_cl_flags(enum changelog_rec_flags *clf_flags,
 				    unsigned int bits)
 {
-	*clf_flags = (enum changelog_rec_flags)
-		(*clf_flags | (bits << CLF_HSM_FLAG_L));
+	union changelog_rec_hsm_flags fl = { .hf_flags = *clf_flags };
+
+	fl.hf_bits.flags = bits;
+	*clf_flags = (enum changelog_rec_flags) fl.hf_flags;
 }
 
 static inline int hsm_get_cl_error(enum changelog_rec_flags clf_flags)
 {
-	return CLF_GET_BITS(clf_flags, CLF_HSM_ERR_H, CLF_HSM_ERR_L);
+	union changelog_rec_hsm_flags fl = { .hf_flags = clf_flags };
+
+	return fl.hf_bits.error;
 }
 
 static inline int hsm_set_cl_error(enum changelog_rec_flags *clf_flags,
 				   int error)
 {
+	union changelog_rec_hsm_flags fl = { .hf_flags = *clf_flags };
+
 	/* In case a negative error is given */
 	error = abs(error);
-
 	if (error > CLF_HSM_MAXERROR)
 		error = CLF_HSM_ERROVERFLOW;
 
-	*clf_flags = (enum changelog_rec_flags)
-		(*clf_flags | (error << CLF_HSM_ERR_L));
+	fl.hf_bits.error = error;
+	*clf_flags = (enum changelog_rec_flags) fl.hf_flags;
 
 	return error == CLF_HSM_ERROVERFLOW ? -EOVERFLOW : 0;
 }
@@ -2232,6 +2243,14 @@ inline __kernel_size_t changelog_rec_snamelen(const struct changelog_rec *rec)
 	       (changelog_rec_sname(rec) - changelog_rec_name(rec));
 }
 
+static inline
+union changelog_rec_hsm_flags changelog_rec_hsm(const struct changelog_rec *rec)
+{
+	union changelog_rec_hsm_flags fl = { .hf_flags = rec->cr_flags };
+
+	return fl;
+}
+
 enum changelog_message_type {
 	CL_RECORD = 10, /* message is a changelog_rec */
 	CL_EOF    = 11, /* at end of current changelog */
diff --git a/lustre/utils/lfs.c b/lustre/utils/lfs.c
index e663ee52d4..f3429b2fa9 100644
--- a/lustre/utils/lfs.c
+++ b/lustre/utils/lfs.c
@@ -11243,6 +11243,15 @@ static int lfs_changelog(int argc, char **argv)
 			printf(" %.*s", rec->cr_namelen,
 			       changelog_rec_name(rec));
 
+		if (rec->cr_type == CL_HSM) {
+			union changelog_rec_hsm_flags fl;
+
+			fl = changelog_rec_hsm(rec);
+			printf(" he=%s hf=%hu hr=%hu",
+			       hsm_event2str(fl.hf_bits.event),
+			       fl.hf_bits.flags, fl.hf_bits.error);
+		}
+
 		if (rec->cr_flags & CLF_RENAME) {
 			struct changelog_ext_rename *rnm =
 				changelog_rec_rename(rec);
diff --git a/lustre/utils/llog_reader.c b/lustre/utils/llog_reader.c
index 2f52569ab7..353364f24b 100644
--- a/lustre/utils/llog_reader.c
+++ b/lustre/utils/llog_reader.c
@@ -811,6 +811,15 @@ static void print_changelog_rec(struct llog_changelog_rec *rec)
 		       __le32_to_cpu(rec->cr.cr_namelen),
 		       changelog_rec_name(&rec->cr));
 
+	if (rec->cr.cr_type == CL_HSM) {
+		union changelog_rec_hsm_flags fl;
+
+		fl = changelog_rec_hsm(&rec->cr);
+		printf(" hsm_event=%s hsm_flags=%hu hsm_error=%hu",
+		       hsm_event2str(fl.hf_bits.event),
+		       fl.hf_bits.flags, fl.hf_bits.error);
+	}
+
 	if (crf & CLF_RENAME) {
 		struct changelog_ext_rename *rnm =
 			changelog_rec_rename(&rec->cr);

</pre>
</body>
</html>
