<html lang="en">
<body>
<pre>
LU-8130 ldlm: convert ldlm_resource hash to rhashtable

Using an rhashtable allows lockless lookup at the cost
of rcu freeing of entries.

When we find an entry, we need to atomically check the
reference hasn't dropped to zero.

When adding an entry, we might find an existing entry which is in the
process of being removed - with a zero refcount.  In that case
we loop around and repeat the lookup.  To ensure this doesn't
spin, the 'cmp' function will fail any comparison with a resource
which has a zero refcount.

Now that we are using resizing hash tables, we don't need to preconfig
suitable sizes for each namespace.  We can just use the default and
let it grow or shrink as needed.  We keep the pre-configured sizes
for the bucket array.  Previously the sizeof the bucket array was the
difference between nsd_all_bits and nsd_bkt_bits.  As we don't need
nsd_all_bits any more, nsd_bkt_bits is changed to the number of bits
used to choose a bucket.

Walking an rhashtable requires that we manage refcounts ourself, so
a new function, ldlm_resource_for_each() is added to do that.

Note that with this patch we now update a per-table counter
on every insert/remove, which might cause more contention
between CPUs on a busy system.  Hopefully rhashtable will
be enhanced in the new future to support a per-CPU counter
for nelems.

Only use call_rcu() to free slab resources that have been removed
from the rhashtable, other cases can be free immediately.

Signed-off-by: Mr NeilBrown <neil@brown.name>
Signed-off-by: Shaun Tancheff <shaun.tancheff@hpe.com>
Change-Id: Ie65f6c5f6e246ed6684ade05ddab8740ac8137dd

</pre>
</body>
</html>
