From 123d5baa504c264408edee161cebb73ecc5c0255 Mon Sep 17 00:00:00 2001
From: Alex Zhuravlev <bzzz@whamcloud.com>
Date: Mon, 5 May 2025 20:23:14 +0300
Subject: [PATCH 1/1] LU-18950 ptlrpc: per-nodemap stats

each nodemap maintains own set of stats (data and metadata
operations).  literally it's a sum of all per-client stats
which are members of specific nodemap:

$ lctl get_param nodemap.c0.*_stats
nodemap.c0.md_stats=
snapshot_time             1746601510.804589748 secs.nsecs
start_time                1746601507.675857245 secs.nsecs
elapsed_time              3.128732503 secs.nsecs
open                      2 samples [usecs] 14 134 148 18152
close                     2 samples [usecs] 9 19 28 442
mknod                     1 samples [usecs] 105 105 105 11025
unlink                    1 samples [usecs] 95 95 95 9025
getattr                   2 samples [usecs] 3 6 9 45
sync                      1 samples [usecs] 124 124 124 15376
nodemap.c0.dt_stats=
snapshot_time             1746601510.814726699 secs.nsecs
start_time                1746601507.675852028 secs.nsecs
elapsed_time              3.138874671 secs.nsecs
write_bytes               1 samples [bytes] 1024 1024 1024 1048576
write                     1 samples [usecs] 18 18 18 324
sync                      1 samples [usecs] 88 88 88 7744

Test-Parameters: testlist=sanity-sec
Test-Parameters: testlist=sanity-sec
Signed-off-by: Alex Zhuravlev <bzzz@whamcloud.com>
Change-Id: I65fa0d154d51ecf4f56bae2a6132438a931a6b6f
---
 lustre/include/lprocfs_status.h  |   1 +
 lustre/include/lustre_nodemap.h  |   3 +
 lustre/mdt/mdt_lproc.c           |  19 ++-
 lustre/obdclass/lprocfs_status.c |  22 ++++
 lustre/ofd/ofd_internal.h        |  18 ++-
 lustre/ptlrpc/nodemap_handler.c  |  14 +++
 lustre/ptlrpc/nodemap_member.c   |  51 ++++++++
 lustre/tests/sanity-sec.sh       | 210 +++++++++++++++++++++++++++++--
 8 files changed, 320 insertions(+), 18 deletions(-)

diff --git a/lustre/include/lprocfs_status.h b/lustre/include/lprocfs_status.h
index b8c2e5f360..e90b102387 100644
--- a/lustre/include/lprocfs_status.h
+++ b/lustre/include/lprocfs_status.h
@@ -511,6 +511,7 @@ extern struct lprocfs_stats *
 lprocfs_stats_alloc(unsigned int num, enum lprocfs_stats_flags flags);
 extern void lprocfs_stats_clear(struct lprocfs_stats *stats);
 extern void lprocfs_stats_free(struct lprocfs_stats **stats);
+extern struct lprocfs_stats *lprocfs_stats_dup(struct lprocfs_stats *stats);
 extern void lprocfs_init_ldlm_stats(struct lprocfs_stats *ldlm_stats);
 struct lprocfs_stats *ldebugfs_stats_alloc(int num, char *name,
 					   struct dentry *entry,
diff --git a/lustre/include/lustre_nodemap.h b/lustre/include/lustre_nodemap.h
index 4d8a0d5ed7..b182e3c388 100644
--- a/lustre/include/lustre_nodemap.h
+++ b/lustre/include/lustre_nodemap.h
@@ -185,6 +185,9 @@ struct lu_nodemap {
 	struct lu_nodemap	*nm_parent_nm;
 	/* user capabilities */
 	kernel_cap_t		 nm_capabilities;
+	struct lprocfs_stats    *nm_dt_stats;
+	struct lprocfs_stats    *nm_md_stats;
+	struct mutex		 nm_stats_lock;
 };
 
 /* Store handles to local MGC storage to save config locally. In future
diff --git a/lustre/mdt/mdt_lproc.c b/lustre/mdt/mdt_lproc.c
index 15a4e690a4..4c5aeeffd1 100644
--- a/lustre/mdt/mdt_lproc.c
+++ b/lustre/mdt/mdt_lproc.c
@@ -39,6 +39,7 @@
 #include "mdt_internal.h"
 #include <obd_cksum.h>
 #include <linux/libcfs/libcfs_caps.h>
+#include <lustre_nodemap.h>
 
 /**
  * The rename stats output would be YAML formats, like
@@ -1549,18 +1550,32 @@ int ldebugfs_mdt_open_files_seq_open(struct inode *inode, struct file *file)
 void mdt_counter_incr(struct ptlrpc_request *req, int opcode, long amount)
 {
 	struct obd_export *exp = req->rq_export;
+	struct lu_nodemap *nm;
 
-	if (exp->exp_obd && exp->exp_obd->obd_md_stats)
+	if (unlikely(!exp->exp_obd))
+		return;
+
+	if (likely(exp->exp_obd->obd_md_stats))
 		lprocfs_counter_add(exp->exp_obd->obd_md_stats,
 				    opcode + LPROC_MD_LAST_OPC, amount);
+
 	if (exp->exp_nid_stats && exp->exp_nid_stats->nid_stats != NULL)
 		lprocfs_counter_add(exp->exp_nid_stats->nid_stats, opcode,
 				    amount);
-	if (exp->exp_obd && obd2obt(exp->exp_obd)->obt_jobstats.ojs_cntr_num &&
+
+	if (obd2obt(exp->exp_obd)->obt_jobstats.ojs_cntr_num &&
 	    (exp_connect_flags(exp) & OBD_CONNECT_JOBSTATS))
 		lprocfs_job_stats_log(exp->exp_obd,
 				      lustre_msg_get_jobid(req->rq_reqmsg),
 				      opcode, amount);
+
+	nm = nodemap_get_from_exp(exp);
+	if (!IS_ERR_OR_NULL(nm)) {
+		if (likely(nm->nm_md_stats))
+			lprocfs_counter_add(nm->nm_md_stats,
+					    opcode + LPROC_MD_LAST_OPC, amount);
+		nodemap_putref(nm);
+	}
 }
 
 static const char * const mdt_stats[] = {
diff --git a/lustre/obdclass/lprocfs_status.c b/lustre/obdclass/lprocfs_status.c
index b4627851ed..3ff027d5e4 100644
--- a/lustre/obdclass/lprocfs_status.c
+++ b/lustre/obdclass/lprocfs_status.c
@@ -1572,6 +1572,28 @@ void lprocfs_stats_free(struct lprocfs_stats **statsh)
 }
 EXPORT_SYMBOL(lprocfs_stats_free);
 
+struct lprocfs_stats *lprocfs_stats_dup(struct lprocfs_stats *stats)
+{
+	struct lprocfs_stats *s;
+	int i;
+
+	s = lprocfs_stats_alloc(stats->ls_num, stats->ls_flags);
+	if (IS_ERR(s))
+		return s;
+
+	for (i = 0; i < stats->ls_num; i++) {
+		struct lprocfs_counter_header *header;
+
+		header = &stats->ls_cnt_header[i];
+		s->ls_cnt_header[i].lc_config = header->lc_config;
+		s->ls_cnt_header[i].lc_name = header->lc_name;
+		s->ls_cnt_header[i].lc_units = header->lc_units;
+	}
+
+	return s;
+}
+EXPORT_SYMBOL(lprocfs_stats_dup);
+
 unsigned int lustre_stats_scan(struct lustre_stats_list *slist, const char *source)
 {
 	struct lprocfs_stats *item, **stats;
diff --git a/lustre/ofd/ofd_internal.h b/lustre/ofd/ofd_internal.h
index cdf82da8d7..1d4ff3e018 100644
--- a/lustre/ofd/ofd_internal.h
+++ b/lustre/ofd/ofd_internal.h
@@ -19,6 +19,7 @@
 #include <dt_object.h>
 #include <md_object.h>
 #include <lustre_fid.h>
+#include <lustre_nodemap.h>
 
 #define OFD_INIT_OBJID	0
 #define OFD_PRECREATE_BATCH_DEFAULT (OBJ_SUBDIR_COUNT * 4)
@@ -70,17 +71,28 @@ enum {
 static inline void ofd_counter_incr(struct obd_export *exp, int opcode,
 				    char *jobid, long amount)
 {
-	if (exp->exp_obd && exp->exp_obd->obd_stats)
+	struct lu_nodemap *nm;
+
+	if (unlikely(!exp->exp_obd))
+		return;
+
+	if (likely(exp->exp_obd->obd_stats))
 		lprocfs_counter_add(exp->exp_obd->obd_stats, opcode, amount);
 
-	if (exp->exp_obd && obd2obt(exp->exp_obd)->obt_jobstats.ojs_cntr_num &&
+	if (obd2obt(exp->exp_obd)->obt_jobstats.ojs_cntr_num &&
 	    (exp_connect_flags(exp) & OBD_CONNECT_JOBSTATS))
 		lprocfs_job_stats_log(exp->exp_obd, jobid, opcode, amount);
 
 	if (exp->exp_nid_stats != NULL &&
-	    exp->exp_nid_stats->nid_stats != NULL) {
+	    exp->exp_nid_stats->nid_stats != NULL)
 		lprocfs_counter_add(exp->exp_nid_stats->nid_stats, opcode,
 				    amount);
+
+	nm = nodemap_get_from_exp(exp);
+	if (!IS_ERR_OR_NULL(nm)) {
+		if (likely(nm->nm_dt_stats))
+			lprocfs_counter_add(nm->nm_dt_stats, opcode, amount);
+		nodemap_putref(nm);
 	}
 }
 
diff --git a/lustre/ptlrpc/nodemap_handler.c b/lustre/ptlrpc/nodemap_handler.c
index c227e7b9e6..137c597c17 100644
--- a/lustre/ptlrpc/nodemap_handler.c
+++ b/lustre/ptlrpc/nodemap_handler.c
@@ -49,6 +49,10 @@ static void nodemap_destroy(struct lu_nodemap *nodemap)
 
 	if (nodemap->nm_pde_data != NULL)
 		lprocfs_nodemap_remove(nodemap->nm_pde_data);
+	if (nodemap->nm_dt_stats)
+		lprocfs_stats_free(&nodemap->nm_dt_stats);
+	if (nodemap->nm_md_stats)
+		lprocfs_stats_free(&nodemap->nm_md_stats);
 
 	OBD_FREE(nodemap->nm_fileset_prim, nodemap->nm_fileset_prim_size);
 
@@ -3341,6 +3345,7 @@ struct lu_nodemap *nodemap_create(const char *name,
 		list_add(&nodemap->nm_parent_entry,
 			 &parent_nodemap->nm_subnodemaps);
 
+	mutex_init(&nodemap->nm_stats_lock);
 	mutex_init(&nodemap->nm_member_list_lock);
 	init_rwsem(&nodemap->nm_idmap_lock);
 
@@ -4466,6 +4471,15 @@ void nodemap_config_set_active(struct nodemap_config *config)
 		if (old_nm != NULL) {
 			nodemap->nm_pde_data = old_nm->nm_pde_data;
 			old_nm->nm_pde_data = NULL;
+
+			/* old nodemap can't be used for new exports */
+			mutex_lock(&nodemap->nm_stats_lock);
+			nodemap->nm_dt_stats = old_nm->nm_dt_stats;
+			nodemap->nm_md_stats = old_nm->nm_md_stats;
+			old_nm->nm_dt_stats = NULL;
+			old_nm->nm_md_stats = NULL;
+			mutex_unlock(&nodemap->nm_stats_lock);
+
 			nodemap_putref(old_nm);
 		} else {
 			bool is_def = (nodemap == config->nmc_default_nodemap);
diff --git a/lustre/ptlrpc/nodemap_member.c b/lustre/ptlrpc/nodemap_member.c
index 824a544c9d..1e98e40581 100644
--- a/lustre/ptlrpc/nodemap_member.c
+++ b/lustre/ptlrpc/nodemap_member.c
@@ -67,6 +67,53 @@ void nm_member_delete_list(struct lu_nodemap *nodemap)
 	mutex_unlock(&nodemap->nm_member_list_lock);
 }
 
+static void nm_register_obd_stats(struct lu_nodemap *nm, struct obd_export *exp)
+{
+	struct obd_device *obd = exp->exp_obd;
+
+	if (unlikely(!exp->exp_obd->obd_stats && !exp->exp_obd->obd_md_stats))
+		return;
+	if (obd->obd_stats && nm->nm_dt_stats)
+		return;
+	if (obd->obd_md_stats && nm->nm_md_stats)
+		return;
+
+	mutex_lock(&nm->nm_stats_lock);
+	if (obd->obd_md_stats && !nm->nm_md_stats) {
+		/*
+		 * here we have no idea how to configure stats properly
+		 * (fields, their names, units, etc), so we rather ask
+		 * obdclass to duplicate configuration of the existing
+		 * stats.
+		 */
+		nm->nm_md_stats = lprocfs_stats_dup(obd->obd_md_stats);
+		if (!nm->nm_md_stats) {
+			CERROR("%s: can't alloc stats for nodemap %s\n",
+				obd->obd_name, nm->nm_name);
+			goto unlock;
+		}
+		debugfs_create_file("md_stats", 0644,
+				    nm->nm_pde_data->npe_debugfs_entry,
+				    nm->nm_md_stats,
+				    &ldebugfs_stats_seq_fops);
+	}
+	if (obd->obd_stats && !nm->nm_dt_stats) {
+		nm->nm_dt_stats = lprocfs_stats_dup(obd->obd_stats);
+		if (!nm->nm_dt_stats) {
+			CERROR("%s: can't alloc stats for nodemap %s\n",
+				obd->obd_name, nm->nm_name);
+			goto unlock;
+		}
+		debugfs_create_file("dt_stats", 0644,
+				    nm->nm_pde_data->npe_debugfs_entry,
+				    nm->nm_dt_stats,
+				    &ldebugfs_stats_seq_fops);
+	}
+
+unlock:
+	mutex_unlock(&nm->nm_stats_lock);
+}
+
 /**
  * nm_member_add() - Add a member export to a nodemap
  * @nodemap: nodemap to add to
@@ -118,6 +165,8 @@ int nm_member_add(struct lu_nodemap *nodemap, struct obd_export *exp)
 		 &nodemap->nm_member_list);
 	mutex_unlock(&nodemap->nm_member_list_lock);
 
+	nm_register_obd_stats(nodemap, exp);
+
 	RETURN(0);
 }
 
@@ -221,6 +270,8 @@ void nm_member_reclassify_nodemap(struct lu_nodemap *nodemap)
 				 &new_nodemap->nm_member_list);
 			mutex_unlock(&new_nodemap->nm_member_list_lock);
 
+			nm_register_obd_stats(new_nodemap, exp);
+
 			if (nodemap_active)
 				nm_member_exp_revoke(exp);
 		} else {
diff --git a/lustre/tests/sanity-sec.sh b/lustre/tests/sanity-sec.sh
index a9087b3fe8..605c316a91 100755
--- a/lustre/tests/sanity-sec.sh
+++ b/lustre/tests/sanity-sec.sh
@@ -2059,6 +2059,20 @@ test_24() {
 }
 run_test 24 "check nodemap proc files for LBUGs and Oopses"
 
+function filter_nodemap_info() {
+	local awkcmd
+	local facet=$1
+
+	shift
+	awkcmd='/^nodemap[.].*[.]dt_stats=/{ignore=1; next}
+		/^nodemap[.].*[.]md_stats=/{ignore=1; next}
+		/^nodemap./{ignore=0}
+		{if(ignore==0)print}'
+
+	do_facet $facet $LCTL $* | awk "$awkcmd"
+	return ${PIPESTATUS[0]}
+}
+
 test_25a() {
 	local tmpfile=$(mktemp)
 	local tmpfile2=$(mktemp)
@@ -2067,6 +2081,8 @@ test_25a() {
 	local subdir=c0dir
 	local client
 
+	stack_trap "rm -f $tmpfile $tmpfile2 $tmpfile3 $tmpfile4"
+
 	nodemap_version_check || return 0
 
 	# stop clients for this test
@@ -2097,8 +2113,8 @@ test_25a() {
 
 	wait_nm_sync test25 id
 
-	do_facet mgs $LCTL $nodemap_info > $tmpfile
-	do_facet mds $LCTL $nodemap_info > $tmpfile2
+	filter_nodemap_info mgs $nodemap_info >$tmpfile
+	filter_nodemap_info mds $nodemap_info >$tmpfile2
 
 	if ! $SHARED_KEY; then
 		# will conflict with SK's nodemaps
@@ -2108,13 +2124,25 @@ test_25a() {
 	zconf_umount_clients $CLIENTS $MOUNT ||
 	    error "unable to umount clients $CLIENTS"
 
-	do_facet mgs $LCTL $nodemap_info > $tmpfile3
-	diff -q $tmpfile3 $tmpfile >& /dev/null ||
+	filter_nodemap_info mgs $nodemap_info >$tmpfile3
+	diff -q $tmpfile3 $tmpfile >& /dev/null || {
+		echo "== $tmpfile =="
+		cat $tmpfile
+		echo "== $tmpfile3 =="
+		cat $tmpfile3
+		echo
 		error "$nodemap_info diff on MGS after remount"
+	}
 
-	do_facet mds $LCTL $nodemap_info > $tmpfile4
-	diff -q $tmpfile4 $tmpfile2 >& /dev/null ||
+	filter_nodemap_info mds $nodemap_info >$tmpfile4
+	diff -q $tmpfile4 $tmpfile2 >& /dev/null || {
+		echo "== $tmpfile4 =="
+		cat $tmpfile4
+		echo "== $tmpfile2 =="
+		cat $tmpfile2
+		echo
 		error "$nodemap_info diff on MDS after remount"
+	}
 
 	# cleanup nodemap
 	do_facet mgs $LCTL nodemap_del test25 ||
@@ -2124,7 +2152,6 @@ test_25a() {
 	zconf_mount_clients $CLIENTS $MOUNT ||
 	    error "unable to mount clients $CLIENTS"
 
-	rm -f $tmpfile $tmpfile2
 	export SK_UNIQUE_NM=false
 }
 run_test 25a "test save and reload nodemap config"
@@ -2154,10 +2181,10 @@ test_25b() {
 		error "unable to add fileset info"
 
 	# full nodemap dump
-	do_facet mgs $LCTL $nodemap_info > $info_dump ||
+	filter_nodemap_info mgs $nodemap_info > $info_dump ||
 		error "$nodemap_info failed"
 	stack_trap "rm -f $info_dump" EXIT
-	do_facet mgs $LCTL get_param -R nodemap > $param_dump ||
+	filter_nodemap_info mgs get_param -R nodemap > $param_dump ||
 		error "get_param -R nodemap failed"
 	stack_trap "rm -f $param_dump" EXIT
 
@@ -2165,19 +2192,19 @@ test_25b() {
 		error "$nodemap_info differs from get_param output (1)"
 
 	# nodemap dump for $nm
-	do_facet mgs $LCTL $nodemap_info --name $nm > $info_dump ||
+	filter_nodemap_info mgs $nodemap_info --name $nm > $info_dump ||
 		error "$nodemap_info failed"
-	do_facet mgs $LCTL get_param -R nodemap.$nm > $param_dump ||
+	filter_nodemap_info mgs get_param -R nodemap.$nm > $param_dump ||
 		error "get_param -R nodemap.$nm failed"
 
 	diff -q $info_dump $param_dump >& /dev/null ||
 		error "$nodemap_info differs from get_param output (2)"
 
 	# nodemap dump for $nm and property fileset
-	do_facet mgs $LCTL $nodemap_info --name $nm \
+	filter_nodemap_info mgs $nodemap_info --name $nm \
 		--property fileset > $info_dump ||
 		error "$nodemap_info failed"
-	do_facet mgs $LCTL get_param nodemap.$nm.fileset > $param_dump ||
+	filter_nodemap_info mgs get_param nodemap.$nm.fileset > $param_dump ||
 		error "get_param nodemap.$nm.fileset failed"
 
 	diff -q $info_dump $param_dump >& /dev/null ||
@@ -10141,6 +10168,163 @@ test_77() {
 }
 run_test 77 "root offsetting"
 
+function parse_nodemap_stats() {
+	local awkcmd
+
+	awkcmd='/open/			{ropen=$2}
+		/close/			{rclose=$2}
+		/mknod/			{mknod=$2}
+		/link/			{link=$2}
+		/unlink/		{unlink=$2}
+		/mkdir/			{mkdir=$2}
+		/rmdir/			{rmdir=$2}
+		/rename/		{rename=$2}
+		/getattr/		{getattr=$2}
+		/setattr/		{setattr=$2}
+		/getxattr/		{getxattr=$2}
+		/setxattr/		{setxattr=$2}
+		/statfs/		{statfs=$2}
+		/sync/			{sync=$2}
+		/samedir_rename/	{samedir_rename=$2}
+		/parallel_rename_file/	{parallel_rename_file=$2}
+		/parallel_rename_dir/	{parallel_rename_dir=$2}
+		/crossdir_rename/	{crossdir_rename=$2}
+		/rename_trylocks/	{rename_trylocks=$2}
+		/read_bytes/		{read_bytes=$2}
+		/write_bytes/		{write_bytes=$2}
+		/read/			{rread=$2}
+		/write/			{rwrite=$2}
+		/punch/			{punch=$2}
+		/migrate/		{migrate=$2}
+		/fallocate/		{fallocate=$2}
+		END {print \
+			"[OPEN]=" ropen, \
+			"[CLOSE]=" rclose, \
+			"[MKNOD]=" mknod, \
+			"[LINK]=" link, \
+			"[UNLINK]=" unlink, \
+			"[MKDIR]=" mkdir, \
+			"[RMDIR]=" rmdir, \
+			"[RENAME]=" rename, \
+			"[GETATTR]=" getattr, \
+			"[SETATTR]=" setattr, \
+			"[GETXATTR]=" getxattr, \
+			"[SETXATTR]=" setxattr, \
+			"[STATFS]=" statfs, \
+			"[SYNC]=" sync, \
+			"[SAMEDIR_RENAME]=" samedir_rename, \
+			"[PARALLEL_RENAME_FILE]=" parallel_rename_file, \
+			"[PARALLEL_RENAME_DIR]=" parallel_rename_dir, \
+			"[CROSSDIR_RENAME]=" crossdir_rename, \
+			"[RENAME_TRYLOCKS]=" rename_trylocks, \
+			"[READ_BYTES]=" read_bytes, \
+			"[WRITE_BYTES]=" write_bytes, \
+			"[READ]=" rread, \
+			"[WRITE]=" rwrite, \
+			"[PUNCH]=" punch, \
+			"[MIGRATE]=" migrate, \
+			"[FALLOCATE]=" fallocate }'
+
+	do_facet $1 $LCTL get_param -n nodemap.${2}.*_stats |
+		awk "$awkcmd"
+}
+
+test_78() {
+	local activedefault
+	local td=$DIR/$tdir
+	declare -A stats
+
+	(( $MGS_VERSION >= $(version_code 2.16.54) )) ||
+		skip "nodemap stats need 2.16.54+"
+
+	test_mkdir -i0 -c1 $td || error "can't mkdir $td"
+	chmod a+rwx $td || error "can't chmod"
+	$LFS setstripe -i0 -c1 $td || error "can't set def striping"
+
+	activedefault=$(do_facet mgs $LCTL get_param -n nodemap.active)
+	(( $activedefault == 1 )) || {
+		do_facet mgs $LCTL nodemap_activate 1
+		wait_nm_sync active
+		stack_trap cleanup_active EXIT
+	}
+
+	do_facet mgs $LCTL nodemap_add c0
+	stack_trap "do_facet mgs $LCTL nodemap_del c0"
+	do_facet mgs $LCTL nodemap_add c1
+	stack_trap "do_facet mgs $LCTL nodemap_del c1"
+
+	local client_ip=$(host_nids_address ${clients_arr[0]} $NETTYPE)
+	local client_nid=$(h2nettype $client_ip)
+	echo "add client ${clients_arr[0]} with $client_ip"
+	do_facet mgs $LCTL nodemap_add_range \
+		--name c0 --range $client_nid ||
+		error "Add range $client_nid to c0 failed rc = $?"
+	$LCTL nodemap_modify --name c0 --property admin --value 1
+	$LCTL nodemap_modify --name c0 --property trusted --value 1
+	wait_nm_sync c0 trusted
+
+	(( num_clients > 1 )) && {
+		client_ip=$(host_nids_address ${clients_arr[1]} $NETTYPE)
+		client_nid=$(h2nettype $client_ip)
+		echo "add client ${clients_arr[1]} with $client_ip"
+		do_facet mgs $LCTL nodemap_add_range \
+			--name c1 --range $client_nid ||
+			error "Add range $client_nid to c1 failed rc = $?"
+		$LCTL nodemap_modify --name c1 --property admin --value 1
+		$LCTL nodemap_modify --name c1 --property trusted --value 1
+		wait_nm_sync c1 trusted
+	}
+
+	echo "stats before test"
+	do_facet mds1 "$LCTL get_param nodemap.c0.exports"
+	do_facet mds1 "$LCTL get_param nodemap.c0.md_stats"
+	do_facet ost1 "$LCTL get_param nodemap.c0.dt_stats"
+	(( num_clients > 1 )) && {
+		do_facet mds1 "$LCTL get_param nodemap.c1.exports"
+		do_facet mds1 "$LCTL get_param nodemap.c1.md_stats"
+		do_facet ost1 "$LCTL get_param nodemap.c1.dt_stats"
+	}
+
+	do_node ${clients_arr[0]} \
+		"dd if=/dev/zero of=$td/$tfile bs=1k count=1 conv=fsync"
+
+	(( num_clients > 1 )) &&
+		do_node ${clients_arr[1]} \
+			"dd if=/dev/zero of=$td/$tfile-2 bs=1k count=1 conv=fsync"
+
+	do_node ${clients_arr[0]} "rm -rf $td/*"
+	ls -lR $td
+
+	echo "stats after test"
+	do_facet mds1 "$LCTL get_param nodemap.c0.md_stats"
+	do_facet ost1 "$LCTL get_param nodemap.c0.dt_stats"
+	eval stats=($(parse_nodemap_stats mds1 c0))
+	(( ${stats[OPEN]} >= 1 && ${stats[CLOSE]} >= 1 &&
+	   ${stats[UNLINK]} >= 1 && ${stats[GETATTR]} >= 1 )) || {
+		do_facet mds2 "$LCTL get_param nodemap.c0.md_stats"
+		do_facet mds3 "$LCTL get_param nodemap.c0.md_stats"
+		do_facet mds4 "$LCTL get_param nodemap.c0.md_stats"
+		error "unexpected stats in c0"
+	   }
+	eval stats=($(parse_nodemap_stats ost1 c0))
+	(( ${stats[WRITE]} == 1 && ${stats[SYNC]} == 1 )) ||
+		do_facet ost1 "$LCTL get_param nodemap.c0.dt_stats"
+	(( num_clients > 1 )) && {
+		eval stats=($(parse_nodemap_stats mds1 c1))
+		do_facet mds1 "$LCTL get_param nodemap.c1.md_stats"
+		do_facet ost1 "$LCTL get_param nodemap.c1.dt_stats"
+		(( ${stats[OPEN]} >= 1 && ${stats[CLOSE]} >= 1 &&
+		   ${stats[GETATTR]} >= 1 )) ||
+			error "unexpected stats in c1"
+		eval stats=($(parse_nodemap_stats ost1 c1))
+		(( ${stats[WRITE]} == 1 && ${stats[SYNC]} == 1 )) ||
+			error "unexpected stats in c1"
+	}
+
+	return 0
+}
+run_test 78 "nodemap stats"
+
 test_79() {
 	# reserve test_79
 	skip "not implemented yet"
