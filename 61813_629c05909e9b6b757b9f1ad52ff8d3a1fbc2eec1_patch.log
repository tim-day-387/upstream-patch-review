LU-19469 llite: hole-aware read optimization for truncate extend

A client can cache hole extent information locally and serve
zero-filled pages for hole regions avoiding long client I/O path,
without network round-trips and bulk data transfer, significantly
improving performance for sparse file read operations while
maintainint data consistency through Lustre's existing DLM
infrastructure.

This patch implements hole-aware read optimization for the holes
generated by extended truncate().

The hole extents are managed using the existing @osc_extent data
structure with the following enhancements:
- hole marker: Add a flag (oe_hole) to distinguish hole extents
  from regular data extents;
- Rbtree integration: Store hole extents in the same osc_object->
  oo_root tree alongside regular extents;
- State management: define specific states for hole extent
  lifecycle (e.g., OES_CACHE with oe_hole=1);
- Lock association (optional): Maintain association between hole
  extents and protecting DLM locks;

The hole extent will be inserted into per-object extent rbtree
when a client executed extended truncate operation and extended
the file beyond current size.
Page read or readahead will try to check the OSC object's extent
tree. If found a matched hole extent, directly zero-fill pages
for the hole regions and mark pages as uptodate.
The hole extent will be removed when detect the write operations
overlapping with the cached hole extent.
Lock blocking AST will also remove conflicting hole extents from
the rbtree of the object.

Add sanity/test_856{a/b/c/d/e} to verify it.

Signed-off-by: Yingjin Qian <qian@ddn.com>
Change-Id: I53ffaded1bc92fb60ceecf6b3acc78e979713953
