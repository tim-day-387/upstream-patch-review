<html lang="en">
<body>
<pre>
From cdb8fa67495fceb54b415788242f665ec9f33c17 Mon Sep 17 00:00:00 2001
From: Patrick Farrell <pfarrell@whamcloud.com>
Date: Mon, 27 Oct 2025 15:19:01 -0400
Subject: [PATCH 1/1] LU-19527 lod: prevent parity mirrors from being write
 targets

Parity mirrors store erasure coding redundancy information and
should never be selected as write targets. They can only be
updated through resync operations from their corresponding
data mirrors.

Add checks in mirror selection logic to skip parity mirrors
when choosing a primary mirror for writes.

Test-Parameters: forjanitoronly
Signed-off-by: Patrick Farrell <pfarrell@whamcloud.com>
Change-Id: Id3532cbe2ba09df72c844382321b1cd3b1d74393
---
 lustre/lod/lod_object.c | 44 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/lustre/lod/lod_object.c b/lustre/lod/lod_object.c
index 191adbab26..54db7fd81c 100644
--- a/lustre/lod/lod_object.c
+++ b/lustre/lod/lod_object.c
@@ -7764,6 +7764,28 @@ static inline int lod_check_ost_avail(const struct lu_env *env,
 	return 1;
 }
 
+/**
+ * lod_mirror_has_parity() - Check if a mirror has any parity components.
+ * @lo: object
+ * @mirror_idx: mirror index
+ *
+ * Return:
+ * * %true if mirror has parity components
+ * * %false otherwise
+ */
+static inline
+bool lod_mirror_has_parity(struct lod_object *lo, int mirror_idx)
+{
+	struct lod_layout_component *lod_comp;
+
+	lod_foreach_mirror_comp(lod_comp, lo, mirror_idx) {
+		if (lod_comp->llc_flags & LCME_FL_PARITY)
+			return true;
+	}
+
+	return false;
+}
+
 /**
  * lod_primary_pick() - Pick primary mirror for write
  * @env: execution environment
@@ -7811,6 +7833,13 @@ static int lod_primary_pick(const struct lu_env *env, struct lod_object *lo,
 			continue;
 		}
 
+		/* parity mirrors should never be selected for writes */
+		if (lod_mirror_has_parity(lo, index)) {
+			CDEBUG(D_LAYOUT, DFID": mirror %d has parity\n",
+			       PFID(lod_object_fid(lo)), index);
+			continue;
+		}
+
 		/* 2nd pick is for the primary mirror containing unavail OST */
 		if (lo->ldo_mirrors[index].lme_prefer && second_pick < 0)
 			second_pick = index;
@@ -8414,6 +8443,7 @@ static int lod_declare_update_write_pending(const struct lu_env *env,
 		struct thandle *th)
 {
 	struct lod_thread_info *info = lod_env_info(env);
+	struct lod_device *lod = lu2lod_dev(lo->ldo_obj.do_lu.lo_dev);
 	struct lu_attr *layout_attr = &info->lti_layout_attr;
 	struct lod_layout_component *lod_comp;
 	struct lu_extent extent = { 0 };
@@ -8434,6 +8464,13 @@ static int lod_declare_update_write_pending(const struct lu_env *env,
 			continue;
 		if (lo->ldo_mirrors[i].lme_hsm)
 			continue;
+		if (lod_mirror_has_parity(lo, i)) {
+			CERROR("%s: "DFID" found non-stale parity mirror %d\n",
+			       lod2obd(lod)->obd_name,
+			       PFID(lod_object_fid(lo)),
+			       lo->ldo_mirrors[i].lme_id);
+			GOTO(out, rc = -EUCLEAN);
+		}
 
 		primary = i;
 		break;
@@ -8443,6 +8480,13 @@ static int lod_declare_update_write_pending(const struct lu_env *env,
 		for (i = 0; i < lo->ldo_mirror_count; i++) {
 			if (lo->ldo_mirrors[i].lme_stale)
 				continue;
+			if (lod_mirror_has_parity(lo, i)) {
+				CERROR("%s: "DFID" found non-stale parity mirror %d\n",
+				       lod2obd(lod)->obd_name,
+				       PFID(lod_object_fid(lo)),
+				       lo->ldo_mirrors[i].lme_id);
+				GOTO(out, rc = -EUCLEAN);
+			}
 			primary = i;
 			break;
 		}

</pre>
</body>
</html>
