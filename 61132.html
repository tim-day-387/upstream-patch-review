<html lang="en">
<body>
<pre>
From 46e91cb7c629b884eb4e5a216170418b970e1698 Mon Sep 17 00:00:00 2001
From: Hongchao Zhang <hongchao@whamcloud.com>
Date: Tue, 28 Oct 2025 09:26:21 +0000
Subject: [PATCH 1/1] LU-19018 quota: use the new qids for fallocated file

When using fallocate to create file and preallocate space,
the UID/GID/PROJID in the passed-in attributes should be
used to enforce the quota.

Signed-off-by: Hongchao Zhang <hongchao@whamcloud.com>
Change-Id: If985df55e063f1f8aaedffad29a285e8bc246034
---
 lustre/include/dt_object.h   | 10 ++++---
 lustre/mdt/mdt_io.c          |  2 +-
 lustre/ofd/ofd_objects.c     |  7 ++++-
 lustre/osd-ldiskfs/osd_io.c  | 20 +++++++++++---
 lustre/tests/sanity-quota.sh | 52 +++++++++++++++++++++++++++++++++++-
 5 files changed, 80 insertions(+), 11 deletions(-)

diff --git a/lustre/include/dt_object.h b/lustre/include/dt_object.h
index 14ae53a228..540b499f6f 100644
--- a/lustre/include/dt_object.h
+++ b/lustre/include/dt_object.h
@@ -1459,8 +1459,9 @@ struct dt_body_operations {
 	 * Return: 0 on success, negative on error
 	 */
 	int (*dbo_declare_fallocate)(const struct lu_env *env,
-				    struct dt_object *dt, __u64 start,
-				    __u64 end, int mode, struct thandle *th,
+				    struct dt_object *dt, struct lu_attr *attr,
+				    __u64 start, __u64 end, int mode,
+				    struct thandle *th,
 				    enum dt_fallocate_error_t *error_code);
 
 	/**
@@ -2730,7 +2731,8 @@ static inline int dt_ladvise(const struct lu_env *env, struct dt_object *dt,
 }
 
 static inline int dt_declare_fallocate(const struct lu_env *env,
-				       struct dt_object *dt, __u64 start,
+				       struct dt_object *dt,
+				       struct lu_attr *attr, __u64 start,
 				       __u64 end, int mode, struct thandle *th,
 				       enum dt_fallocate_error_t *error_code)
 {
@@ -2742,7 +2744,7 @@ static inline int dt_declare_fallocate(const struct lu_env *env,
 	if (!dt->do_body_ops->dbo_declare_fallocate)
 		return -EOPNOTSUPP;
 
-	return dt->do_body_ops->dbo_declare_fallocate(env, dt, start, end,
+	return dt->do_body_ops->dbo_declare_fallocate(env, dt, attr, start, end,
 						      mode, th, error_code);
 }
 
diff --git a/lustre/mdt/mdt_io.c b/lustre/mdt/mdt_io.c
index c47ba19070..feee504abf 100644
--- a/lustre/mdt/mdt_io.c
+++ b/lustre/mdt/mdt_io.c
@@ -887,7 +887,7 @@ static int mdt_object_fallocate(const struct lu_env *env, struct dt_device *dt,
 		if (rc)
 			GOTO(stop, rc);
 
-		rc = dt_declare_fallocate(env, dob, start, end, mode, th,
+		rc = dt_declare_fallocate(env, dob, la, start, end, mode, th,
 					  error_code);
 		if (rc)
 			GOTO(stop, rc);
diff --git a/lustre/ofd/ofd_objects.c b/lustre/ofd/ofd_objects.c
index 21071a1daa..c4ff0419da 100644
--- a/lustre/ofd/ofd_objects.c
+++ b/lustre/ofd/ofd_objects.c
@@ -837,6 +837,10 @@ int ofd_object_fallocate(const struct lu_env *env, struct ofd_object *fo,
 
 		restart = false;
 
+		rc = ofd_attr_handle_id(env, fo, la, 1 /* is_setattr */);
+		if (rc != 0)
+			RETURN(rc);
+
 		th = ofd_trans_create(env, ofd);
 		if (IS_ERR(th))
 			RETURN(PTR_ERR(th));
@@ -855,7 +859,8 @@ int ofd_object_fallocate(const struct lu_env *env, struct ofd_object *fo,
 				GOTO(stop, rc);
 		}
 
-		rc = dt_declare_fallocate(env, dob, start, end, mode, th, NULL);
+		rc = dt_declare_fallocate(env, dob, la, start, end, mode, th,
+					  NULL);
 		if (rc)
 			GOTO(stop, rc);
 
diff --git a/lustre/osd-ldiskfs/osd_io.c b/lustre/osd-ldiskfs/osd_io.c
index f89ec302a6..c4dbc405d1 100644
--- a/lustre/osd-ldiskfs/osd_io.c
+++ b/lustre/osd-ldiskfs/osd_io.c
@@ -2374,14 +2374,16 @@ static ssize_t osd_write(const struct lu_env *env, struct dt_object *dt,
 }
 
 static int osd_declare_fallocate(const struct lu_env *env,
-				 struct dt_object *dt, __u64 start, __u64 end,
-				 int mode, struct thandle *th,
+				 struct dt_object *dt, struct lu_attr *attr,
+				 __u64 start, __u64 end, int mode,
+				 struct thandle *th,
 				 enum dt_fallocate_error_t *error_code)
 {
 	struct osd_thandle *oh = container_of(th, struct osd_thandle, ot_super);
 	struct osd_device *osd = osd_obj2dev(osd_dt_obj(dt));
 	struct inode *inode = osd_dt_obj(dt)->oo_inode;
 	long long quota_space = 0;
+	qid_t uid, gid, projid;
 	/* 5 is max tree depth. (inode + 4 index blocks) */
 	int depth = 5;
 	int rc;
@@ -2423,8 +2425,18 @@ static int osd_declare_fallocate(const struct lu_env *env,
 			LDISKFS_META_TRANS_BLOCKS(inode->i_sb);
 	}
 
-	rc = osd_declare_inode_qid(env, i_uid_read(inode), i_gid_read(inode),
-				   i_projid_read(inode), quota_space, oh,
+	uid = i_uid_read(inode);
+	gid = i_gid_read(inode);
+	projid = i_projid_read(inode);
+	if (attr) {
+		if (attr->la_valid & LA_UID)
+			uid = attr->la_uid;
+		if (attr->la_valid & LA_GID)
+			gid = attr->la_gid;
+		if (attr->la_valid & LA_PROJID)
+			projid = attr->la_projid;
+	}
+	rc = osd_declare_inode_qid(env, uid, gid, projid, quota_space, oh,
 				   osd_dt_obj(dt), NULL, OSD_QID_BLK);
 	if (rc)
 		RETURN(rc);
diff --git a/lustre/tests/sanity-quota.sh b/lustre/tests/sanity-quota.sh
index 54e5fb3bf1..3b5728a7c1 100755
--- a/lustre/tests/sanity-quota.sh
+++ b/lustre/tests/sanity-quota.sh
@@ -1122,6 +1122,7 @@ run_test 1g "Quota pools: Block hard limit with wide striping"
 
 test_1h() {
 	local limit=10 # MB
+	local testdir="$DIR/$tdir"
 	local testfile="$DIR/$tdir/$tfile-0"
 
 	check_set_fallocate_or_skip
@@ -1153,6 +1154,53 @@ test_1h() {
 	used=$(getquota -u $TSTUSR global curspace)
 	[ $used -eq 0 ] || quota_error u $TSTUSR \
 		"user quota isn't released after deletion"
+
+	$LFS setstripe -i 0 -c 1 $testdir || error "setstripe $testdir failed"
+
+	$RUNAS fallocate -l$((count + 2))MiB $testfile &&
+		quota_error u $TSTUSR "Write success, expect EDQUOT"
+	$LFS quota -u $TSTID
+
+	$LFS setquota -u $TSTUSR -b 0 -B 0 -i 0 -I 0 $DIR ||
+		error "reset user quota failed"
+	$LFS setquota -g $TSTUSR -b 0 -B ${limit}M -i 0 -I 0 $DIR ||
+		error "set group quota failed"
+
+	wait_quota_synced ost1 OST0000 grp $TSTID hardlimit $((limit*1024))
+
+	rm -f $testfile
+	wait_delete_completed || error "wait_delete_completed failed"
+	sync_all_data || true
+
+	$RUNAS fallocate -l$((count + 2))MiB $testfile &&
+		quota_error g $TSTUSR "Write success, expect EDQUOT"
+	$LFS quota -g $TSTID
+
+	! is_project_quota_supported &&
+		echo "Skip project quota is not supported" && return 0
+
+	$LFS setquota -g $TSTUSR -b 0 -B 0 -i 0 -I 0 $DIR ||
+		error "reset group quota failed"
+
+	rm -f $testfile
+	wait_delete_completed || error "wait_delete_completed failed"
+	sync_all_data || true
+
+	$LFS setquota -p $TSTPRJID -b 0 -B ${limit}M -i 0 -I 0 $DIR ||
+		error "set project quota failed"
+
+	wait_quota_synced ost1 OST0000 prj $TSTPRJID hardlimit $((limit*1024))
+
+	# make sure the system is clean
+	used=$(getquota -p $TSTPRJID global curinodes)
+	[ $used -ne 0 ] &&
+		error "Used inodes($used) for project $TSTPRJID isn't 0"
+
+	change_project -sp $TSTPRJID $DIR/$tdir
+
+	$RUNAS fallocate -l$((count + 2))MiB $testfile &&
+		quota_error p $TSTUSR "Write success, expect EDQUOT"
+	$LFS quota -p $TSTPRJID $DIR
 }
 run_test 1h "Block hard limit test using fallocate"
 
@@ -7362,7 +7410,9 @@ test_delete_big_file() {
 	$LFS setstripe $tfile2 -i 1 -c 1 || error "setstripe $tfile2 failed"
 	chown $TSTID:$TSTID $tfile2 || error "fail to chown $tfile2"
 
-	$RUNAS fallocate -l2GiB $tfile2 || error "fail to write 2GiB"
+	$RUNAS fallocate -l2GiB $tfile2 || {
+		(( equot_expected == 0 )) && error "fail to write 2GiB"
+	}
 
 	(( equot_expected == 1 )) && {
 		$RUNAS $DD of=$tfile2 seek=2048 count=512 oflag=sync &&

</pre>
</body>
</html>
