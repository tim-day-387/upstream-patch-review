<html lang="en">
<body>
<pre>
From 1f4850d4248bfef789bb9e67d622d84f0a67c741 Mon Sep 17 00:00:00 2001
From: Maximilian Dilger <mdilger@whamcloud.com>
Date: Fri, 17 Oct 2025 11:16:04 -0600
Subject: [PATCH 1/1] LU-19054 utils: New max client connection limit.

This introduces a new parameter that allows a maximum number of
client connections to be set.

This only affects client -> server connections. Server -> server
connections are unaffected.

Signed-off-by: Max Dilger <mdilger@whamcloud.com>
Change-Id: Ibef99a9bd1f889abdfeb97942600b66e9a9be123
---
 Documentation/man4/mdt.client_count.4       |   1 +
 Documentation/man4/mdt.client_limit.4       |   1 +
 Documentation/man4/nodemap.client_count.4   |  25 +++++
 Documentation/man4/nodemap.client_limit.4   |  33 +++++++
 Documentation/man4/obdfilter.client_count.4 |   1 +
 Documentation/man4/obdfilter.client_limit.4 |   1 +
 Documentation/man4/ost.client_count.4       |   1 +
 Documentation/man4/ost.client_limit.4       |   1 +
 lustre/include/lprocfs_status.h             |   6 ++
 lustre/include/lustre_net.h                 |  16 +++
 lustre/include/lustre_nodemap.h             |   4 +
 lustre/include/obd.h                        |   4 +
 lustre/ldlm/ldlm_lib.c                      |  78 +++++++++++++++
 lustre/llite/super25.c                      |  10 +-
 lustre/mdt/mdt_lproc.c                      |   5 +
 lustre/obdclass/genops.c                    |   6 ++
 lustre/obdclass/lprocfs_status_server.c     |  38 +++++++
 lustre/ofd/lproc_ofd.c                      |   5 +
 lustre/ptlrpc/import.c                      |  33 +++++++
 lustre/ptlrpc/nodemap_lproc.c               |  76 ++++++++++++++
 lustre/ptlrpc/nodemap_member.c              |  21 ++++
 lustre/tests/sanity.sh                      | 104 ++++++++++++++++++++
 22 files changed, 468 insertions(+), 2 deletions(-)
 create mode 100644 Documentation/man4/mdt.client_count.4
 create mode 100644 Documentation/man4/mdt.client_limit.4
 create mode 100644 Documentation/man4/nodemap.client_count.4
 create mode 100644 Documentation/man4/nodemap.client_limit.4
 create mode 100644 Documentation/man4/obdfilter.client_count.4
 create mode 100644 Documentation/man4/obdfilter.client_limit.4
 create mode 100644 Documentation/man4/ost.client_count.4
 create mode 100644 Documentation/man4/ost.client_limit.4

diff --git a/Documentation/man4/mdt.client_count.4 b/Documentation/man4/mdt.client_count.4
new file mode 100644
index 0000000000..834d4e7b1e
--- /dev/null
+++ b/Documentation/man4/mdt.client_count.4
@@ -0,0 +1 @@
+.so man4/nodemap.client_count.4
diff --git a/Documentation/man4/mdt.client_limit.4 b/Documentation/man4/mdt.client_limit.4
new file mode 100644
index 0000000000..46b729331d
--- /dev/null
+++ b/Documentation/man4/mdt.client_limit.4
@@ -0,0 +1 @@
+.so man4/nodemap.client_limit.4
diff --git a/Documentation/man4/nodemap.client_count.4 b/Documentation/man4/nodemap.client_count.4
new file mode 100644
index 0000000000..73ff45384f
--- /dev/null
+++ b/Documentation/man4/nodemap.client_count.4
@@ -0,0 +1,25 @@
+.TH NODEMAP.CLIENT_COUNT 4 2025-10-27 Lustre "Lustre Kernel Interfaces"
+.SH NAME
+nodemap.client_count \- number of current client to server connections
+.SH SYNOPSIS
+.SY lctl get_param nodemap.default.client_count
+.SH DESCRIPTION
+.B client_count
+returns the current number of client to server connections. Server to
+Server connections are not counted. This is a read only parameter. To
+set a client limit use the client_limit parameter. This parameter can
+be run on the mdt directly or the specified nodemap.
+.SH EXAMPLES
+List client connection count:
+.EX
+.B # lctl get_param get_param nodemap.default.client_count
+.B # lctl get_param mdt.testfs-MDT0000.client_count
+.EE
+.SH AVAILABILITY
+.B nodemap.client_count
+is part of the
+.BR lustre (7)
+filesystem package.
+.\" Added in Lustre 2.16.59
+.SH SEE ALSO
+.BR nodemap.client_limit (4)
diff --git a/Documentation/man4/nodemap.client_limit.4 b/Documentation/man4/nodemap.client_limit.4
new file mode 100644
index 0000000000..1bbc3de867
--- /dev/null
+++ b/Documentation/man4/nodemap.client_limit.4
@@ -0,0 +1,33 @@
+.TH NODEMAP.CLIENT_LIMIT 4 2025-10-27 Lustre "Lustre Kernel Interfaces"
+.SH NAME
+nodemap.client_limit \- the maximum allowed client to server connections
+.SH SYNOPSIS
+.SY lctl get_param nodemap.default.client_limit
+or
+.SY lctl set_param nodemap.default.client_limit=VALUE
+.SH DESCRIPTION
+Sets the maximum number of clients that can connect to the specified
+nodemap or target. By default this is set to -1 to allow unlimited
+connections. This will not remove existing connections, only deny
+new connections after being set. This value can be set on MDTs, OSTs
+or individual nodemaps.
+.SH EXAMPLES
+List current client limit:
+.EX
+.B # lctl get_param nodemap.default.client_limit
+.B # lctl get_param mdt.testfs-MDT0000.client_limit
+.EE
+.PP
+Set current client limit:
+.EX
+.B # lctl set_param nodemap.default.client_limit=4
+.B # lctl set_param mdt.lustre-MDT0000.client_limit=4
+.EE
+.SH AVAILABILITY
+.B nodemap.client_limit
+is part of the
+.BR lustre (7)
+filesystem package.
+.\" Added in Lustre 2.16.59
+.SH SEE ALSO
+.BR nodemap.client_count (4)
diff --git a/Documentation/man4/obdfilter.client_count.4 b/Documentation/man4/obdfilter.client_count.4
new file mode 100644
index 0000000000..834d4e7b1e
--- /dev/null
+++ b/Documentation/man4/obdfilter.client_count.4
@@ -0,0 +1 @@
+.so man4/nodemap.client_count.4
diff --git a/Documentation/man4/obdfilter.client_limit.4 b/Documentation/man4/obdfilter.client_limit.4
new file mode 100644
index 0000000000..46b729331d
--- /dev/null
+++ b/Documentation/man4/obdfilter.client_limit.4
@@ -0,0 +1 @@
+.so man4/nodemap.client_limit.4
diff --git a/Documentation/man4/ost.client_count.4 b/Documentation/man4/ost.client_count.4
new file mode 100644
index 0000000000..834d4e7b1e
--- /dev/null
+++ b/Documentation/man4/ost.client_count.4
@@ -0,0 +1 @@
+.so man4/nodemap.client_count.4
diff --git a/Documentation/man4/ost.client_limit.4 b/Documentation/man4/ost.client_limit.4
new file mode 100644
index 0000000000..46b729331d
--- /dev/null
+++ b/Documentation/man4/ost.client_limit.4
@@ -0,0 +1 @@
+.so man4/nodemap.client_limit.4
diff --git a/lustre/include/lprocfs_status.h b/lustre/include/lprocfs_status.h
index b8c2e5f360..4eac8b201e 100644
--- a/lustre/include/lprocfs_status.h
+++ b/lustre/include/lprocfs_status.h
@@ -605,6 +605,12 @@ extern int lprocfs_connect_flags_seq_show(struct seq_file *m, void *data);
 #ifdef HAVE_SERVER_SUPPORT
 ssize_t num_exports_show(struct kobject *kobj, struct attribute *attr,
 			 char *buf);
+ssize_t client_count_show(struct kobject *kobj, struct attribute *attr,
+			  char *buf);
+ssize_t client_limit_show(struct kobject *kobj, struct attribute *attr,
+			 char *buf);
+ssize_t client_limit_store(struct kobject *kobj, struct attribute *attr,
+			  const char *buffer, size_t count);
 ssize_t grant_check_threshold_show(struct kobject *kobj,
 				   struct attribute *attr, char *buf);
 ssize_t grant_check_threshold_store(struct kobject *kobj,
diff --git a/lustre/include/lustre_net.h b/lustre/include/lustre_net.h
index 004a02a5ca..f63c427f6b 100644
--- a/lustre/include/lustre_net.h
+++ b/lustre/include/lustre_net.h
@@ -2574,6 +2574,22 @@ int import_set_conn_priority(struct obd_import *imp, struct obd_uuid *uuid);
 void client_destroy_import(struct obd_import *imp);
 /** @} */
 
+/**
+ * Check if connection is from another server (MDS, OST, or LWP).
+ * Server connections should not be subject to client connection limits.
+ *
+ * \param[in] data	connect data from client
+ *
+ * \retval true		if connection is from a server
+ * \retval false	if connection is from a regular client
+ */
+static inline bool is_server_connection(struct obd_connect_data *data)
+{
+	return (data->ocd_connect_flags & OBD_CONNECT_MDS) ||
+	       (data->ocd_connect_flags & OBD_CONNECT_MDS_MDS) ||
+	       (data->ocd_connect_flags & OBD_CONNECT_LIGHTWEIGHT);
+}
+
 #ifdef HAVE_SERVER_SUPPORT
 int server_disconnect_export(struct obd_export *exp);
 #endif
diff --git a/lustre/include/lustre_nodemap.h b/lustre/include/lustre_nodemap.h
index 4d8a0d5ed7..38ad81831e 100644
--- a/lustre/include/lustre_nodemap.h
+++ b/lustre/include/lustre_nodemap.h
@@ -185,6 +185,10 @@ struct lu_nodemap {
 	struct lu_nodemap	*nm_parent_nm;
 	/* user capabilities */
 	kernel_cap_t		 nm_capabilities;
+	/* limit on number of clients that can connect, -1 = unlimited */
+	signed int			 nm_client_limit;
+	/* count of non-server client connections in this nodemap */
+	atomic_t		 nm_client_count;
 };
 
 /* Store handles to local MGC storage to save config locally. In future
diff --git a/lustre/include/obd.h b/lustre/include/obd.h
index ef3e4344e2..7cc1e2ee01 100644
--- a/lustre/include/obd.h
+++ b/lustre/include/obd.h
@@ -699,6 +699,10 @@ struct obd_device {
 	atomic_t                obd_max_recoverable_clients;
 	atomic_t                obd_connected_clients;
 	int                     obd_stale_clients;
+	/* limit on number of clients that can connect, -1 = unlimited */
+	int			obd_client_limit;
+	/* count of non-server client connections */
+	atomic_t		obd_client_count;
 	/* this lock protects all recovery list_heads, timer and
 	 * obd_next_recovery_transno value
 	 */
diff --git a/lustre/ldlm/ldlm_lib.c b/lustre/ldlm/ldlm_lib.c
index 79d47e3f01..e7ed2143f7 100644
--- a/lustre/ldlm/ldlm_lib.c
+++ b/lustre/ldlm/ldlm_lib.c
@@ -1308,6 +1308,26 @@ int target_handle_connect(struct ptlrpc_request *req)
 		}
 	}
 
+	/*
+	 * Check connection limits for non-server connections.
+	 * Server-to-server connections (MDS-MDS, LWP) are exempt.
+	 */
+	if (!is_server_connection(data) && initial_conn) {
+		/* Check global per-target limit (-1 = unlimited, 0 = no connections) */
+		if (target->obd_client_limit >= 0 &&
+		    atomic_read(&target->obd_client_count) >=
+		    target->obd_client_limit) {
+			rc = -EUSERS;
+			LCONSOLE_WARN("%s: Refusing connection for new client %s (at %s), client_limit (%d) reached (%d connected) rc = %d\n",
+				      target->obd_name, cluuid.uuid,
+				      libcfs_nidstr(&req->rq_peer.nid),
+				      target->obd_client_limit,
+				      atomic_read(&target->obd_client_count),
+					  rc);
+			GOTO(out, rc);
+		}
+	}
+
 	/* lctl gets a backstage, all-access pass. */
 	if (obd_uuid_equals(&cluuid, &target->obd_uuid))
 		goto dont_check_exports;
@@ -1529,6 +1549,42 @@ dont_check_exports:
 	if (rc)
 		GOTO(out, rc);
 
+	/*
+	 * Check per-nodemap client limit for new non-server connections.
+	 * This check is done after export creation since the nodemap is
+	 * assigned during obd_connect().
+	 *
+	 * NOTE: This check MUST use the 'data' parameter (not
+	 * exp->exp_connect_data) because exp_connect_data is not populated
+	 * until later in the connection process. When nm_member_add() is
+	 * called (via nodemap_add_member()), exp_connect_data is still empty,
+	 * so is_server_connection() would incorrectly return false for
+	 * server connections (LWP, MDT-MDT, MDT-OST), causing them to be
+	 * rejected. The 'data' parameter is already populated at this point.
+	 * For this reason it is simpler to do this check here and not in
+	 * nodemap_member.c
+	 */
+	if (!is_server_connection(data) && initial_conn && export) {
+		struct lu_nodemap *nodemap;
+
+		nodemap = nodemap_get_from_exp(export);
+		if (!IS_ERR_OR_NULL(nodemap)) {
+			if (nodemap->nm_client_limit != -1 &&
+			    atomic_read(&nodemap->nm_client_count) >=
+			    nodemap->nm_client_limit) {
+				LCONSOLE_WARN("%s: Refusing connection for new client %s (at %s), nodemap '%s' client_limit (%d) reached (%d connected)\n",
+					      target->obd_name, cluuid.uuid,
+					      libcfs_nidstr(&req->rq_peer.nid),
+					      nodemap->nm_name,
+					      nodemap->nm_client_limit,
+					      atomic_read(&nodemap->nm_client_count));
+				nodemap_putref(nodemap);
+				GOTO(out, rc = -EUSERS);
+			}
+			nodemap_putref(nodemap);
+		}
+	}
+
 	data->ocd_instance = obd2obt(target)->obt_instance;
 
 	/*
@@ -1681,6 +1737,19 @@ dont_check_exports:
 	if (test_bit(OBDF_RECOVERING, target->obd_flags) && !lw_client)
 		lustre_msg_add_op_flags(req->rq_repmsg, MSG_CONNECT_RECOVERING);
 
+	/*
+	 * Increment client connection counter for successful initial
+	 * non-server connections. This must be done after all validation
+	 * checks pass to avoid incrementing on connections that will be
+	 * rejected, which would cause the counter to get decremented during
+	 * cleanup without ever being properly incremented.
+	 *
+	 * Note: nodemap->nm_client_count is incremented separately in
+	 * nm_member_add() when the export is added to the nodemap.
+	 */
+	if (rc == 0 && !is_server_connection(data) && initial_conn && export)
+		atomic_inc(&target->obd_client_count);
+
 out:
 	if (export) {
 		spin_lock(&export->exp_lock);
@@ -1725,6 +1794,15 @@ int target_handle_disconnect(struct ptlrpc_request *req)
 	/* Keep the rq_export around so we can send the reply. */
 	req->rq_status = obd_disconnect(class_export_get(req->rq_export));
 
+	/*
+	 * Decrement target-level client count for non-server connections.
+	 * This mirrors the increment done in target_handle_connect().
+	 */
+	if (!is_server_connection(&req->rq_export->exp_connect_data) &&
+	    req->rq_export->exp_obd &&
+	    atomic_read(&req->rq_export->exp_obd->obd_client_count) > 0)
+		atomic_dec(&req->rq_export->exp_obd->obd_client_count);
+
 	RETURN(0);
 }
 
diff --git a/lustre/llite/super25.c b/lustre/llite/super25.c
index 0f8bd9f003..ce0168408f 100644
--- a/lustre/llite/super25.c
+++ b/lustre/llite/super25.c
@@ -195,8 +195,14 @@ static int lustre_fill_super(struct super_block *sb, void *lmd2_data,
 	 */
 out:
 	if (rc) {
-		CERROR("llite: Unable to mount %s: rc = %d\n",
-		       s2lsi(sb) ? lmd->lmd_dev : "<unknown>", rc);
+		if (rc == -EUSERS) {
+			LCONSOLE_ERROR("Unable to mount %s: server has reached its max_clients limit. "
+			"Please contact your administrator to increase the limit or disconnect unused clients.\n",
+				       s2lsi(sb) ? lmd->lmd_dev : "<unknown>");
+		} else {
+			CERROR("llite: Unable to mount %s: rc = %d\n",
+			       s2lsi(sb) ? lmd->lmd_dev : "<unknown>", rc);
+		}
 	} else {
 		CDEBUG(D_SUPER, "%s: Mount complete\n",
 		       lmd->lmd_dev);
diff --git a/lustre/mdt/mdt_lproc.c b/lustre/mdt/mdt_lproc.c
index 15a4e690a4..c6bcacad63 100644
--- a/lustre/mdt/mdt_lproc.c
+++ b/lustre/mdt/mdt_lproc.c
@@ -1401,6 +1401,9 @@ LUSTRE_RO_ATTR(num_exports);
 LUSTRE_RW_ATTR(grant_check_threshold);
 LUSTRE_RO_ATTR(eviction_count);
 
+LUSTRE_RW_ATTR(client_limit);
+LUSTRE_RO_ATTR(client_count);
+
 /* per-device at parameters */
 LUSTRE_OBD_UINT_PARAM_ATTR(at_min);
 LUSTRE_OBD_UINT_PARAM_ATTR(at_max);
@@ -1424,6 +1427,8 @@ static struct attribute *mdt_attrs[] = {
 	&lustre_attr_grant_check_threshold.attr,
 	&lustre_attr_evict_client.attr,
 	&lustre_attr_eviction_count.attr,
+	&lustre_attr_client_limit.attr,
+	&lustre_attr_client_count.attr,
 	&lustre_attr_identity_expire.attr,
 	&lustre_attr_identity_acquire_expire.attr,
 	&lustre_attr_identity_upcall.attr,
diff --git a/lustre/obdclass/genops.c b/lustre/obdclass/genops.c
index a3abf687eb..fcbd083ec3 100644
--- a/lustre/obdclass/genops.c
+++ b/lustre/obdclass/genops.c
@@ -373,6 +373,12 @@ struct obd_device *class_newdev(const char *type_name, const char *name,
 	newdev->obd_pool_limit = 0;
 	newdev->obd_pool_slv = 0;
 
+#ifdef HAVE_SERVER_SUPPORT
+	/* Initialize client connection limit to unlimited (-1) */
+	newdev->obd_client_limit = -1;
+	atomic_set(&newdev->obd_client_count, 0);
+#endif
+
 	INIT_LIST_HEAD(&newdev->obd_exports);
 	newdev->obd_num_exports = 0;
 	newdev->obd_grant_check_threshold = 100;
diff --git a/lustre/obdclass/lprocfs_status_server.c b/lustre/obdclass/lprocfs_status_server.c
index a2a17bf9b9..46739a3f43 100644
--- a/lustre/obdclass/lprocfs_status_server.c
+++ b/lustre/obdclass/lprocfs_status_server.c
@@ -149,6 +149,44 @@ ssize_t num_exports_show(struct kobject *kobj, struct attribute *attr,
 }
 EXPORT_SYMBOL(num_exports_show);
 
+ssize_t client_limit_show(struct kobject *kobj, struct attribute *attr,
+			 char *buf)
+{
+	struct obd_device *obd = container_of(kobj, struct obd_device,
+					      obd_kset.kobj);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", obd->obd_client_limit);
+}
+EXPORT_SYMBOL(client_limit_show);
+
+ssize_t client_limit_store(struct kobject *kobj, struct attribute *attr,
+			  const char *buffer, size_t count)
+{
+	struct obd_device *obd = container_of(kobj, struct obd_device,
+					      obd_kset.kobj);
+	int val;
+	int rc;
+
+	rc = kstrtoint(buffer, 0, &val);
+	if (rc)
+		return rc;
+
+	obd->obd_client_limit = val;
+	return count;
+}
+EXPORT_SYMBOL(client_limit_store);
+
+ssize_t client_count_show(struct kobject *kobj, struct attribute *attr,
+			  char *buf)
+{
+	struct obd_device *obd = container_of(kobj, struct obd_device,
+					      obd_kset.kobj);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n",
+			 atomic_read(&obd->obd_client_count));
+}
+EXPORT_SYMBOL(client_count_show);
+
 ssize_t grant_check_threshold_show(struct kobject *kobj, struct attribute *attr,
 				   char *buf)
 {
diff --git a/lustre/ofd/lproc_ofd.c b/lustre/ofd/lproc_ofd.c
index 08f882d019..a4fe50d318 100644
--- a/lustre/ofd/lproc_ofd.c
+++ b/lustre/ofd/lproc_ofd.c
@@ -1092,6 +1092,9 @@ LUSTRE_RO_ATTR(num_exports);
 LUSTRE_RW_ATTR(grant_check_threshold);
 LUSTRE_RO_ATTR(eviction_count);
 
+LUSTRE_RW_ATTR(client_limit);
+LUSTRE_RO_ATTR(client_count);
+
 LDEBUGFS_SEQ_FOPS_RO_TYPE(ofd, recovery_status);
 LDEBUGFS_SEQ_FOPS_RO_TYPE(ofd, recovery_stale_clients);
 
@@ -1199,6 +1202,8 @@ static struct attribute *ofd_attrs[] = {
 	&lustre_attr_no_precreate.attr,
 #endif
 	&lustre_attr_num_exports.attr,
+	&lustre_attr_client_limit.attr,
+	&lustre_attr_client_count.attr,
 	&lustre_attr_precreate_batch.attr,
 	&lustre_attr_readonly.attr,
 	&lustre_attr_recovery_time_hard.attr,
diff --git a/lustre/ptlrpc/import.c b/lustre/ptlrpc/import.c
index ee0668791a..de0c3c955a 100644
--- a/lustre/ptlrpc/import.c
+++ b/lustre/ptlrpc/import.c
@@ -1409,6 +1409,39 @@ out:
 				ptlrpc_deactivate_import_nolock(imp);
 				inact = true;
 			}
+		} else if (rc == -EUSERS) {
+			/*
+			 * -EUSERS means client_limit reached. This is
+			 * a capacity/administrative limit.
+			 *
+			 * NOTE: Server connections (LWP, MDT-MDT, MDT-OST)
+			 * are exempt from client limits on the server side
+			 * (see is_server_connection() in ldlm_lib.c) and
+			 * should NEVER receive -EUSERS under normal
+			 * operation. This handling is only a failsafe for
+			 * edge cases.
+			 *
+			 * For regular clients: fail connection and
+			 * deactivate to prevent background retries.
+			 *
+			 * For server connections: treat as temporary error
+			 * and keep retrying (should not happen in practice).
+			 */
+			LCONSOLE_WARN("%s: connection refused by %s: client_limit reached\n",
+				      imp->imp_obd->obd_name,
+				      obd2cli_tgt(imp->imp_obd));
+			if (imp->imp_connect_flags_orig &
+			    (OBD_CONNECT_LIGHTWEIGHT |
+			     OBD_CONNECT_MDS_MDS | OBD_CONNECT_MDS)) {
+				/* Server connections: treat as temporary, keep retrying */
+				rc = -EAGAIN;
+				imp->imp_force_reconnect = 1;
+			} else {
+				/* Regular clients: deactivate to prevent retries */
+				imp->imp_deactive = 1;
+				ptlrpc_deactivate_import_nolock(imp);
+				inact = true;
+			}
 		} else if (rc == -EPROTO) {
 			struct obd_connect_data *ocd;
 
diff --git a/lustre/ptlrpc/nodemap_lproc.c b/lustre/ptlrpc/nodemap_lproc.c
index 8b72c9ff00..4173fce234 100644
--- a/lustre/ptlrpc/nodemap_lproc.c
+++ b/lustre/ptlrpc/nodemap_lproc.c
@@ -745,6 +745,64 @@ static int nodemap_squash_projid_seq_show(struct seq_file *m, void *data)
 	return 0;
 }
 
+/**
+ * nodemap_client_limit_seq_show() - Read/print client limit for nodemap.
+ * @m: seq file in proc fs
+ * @data: unused
+ *
+ * Return:
+ * * %0 on success
+ * * %negative error code on failure
+ */
+static int nodemap_client_limit_seq_show(struct seq_file *m, void *data)
+{
+	struct lu_nodemap *nodemap;
+
+	mutex_lock(&active_config_lock);
+	nodemap = nodemap_lookup(m->private);
+	mutex_unlock(&active_config_lock);
+	if (IS_ERR(nodemap)) {
+		int rc = PTR_ERR(nodemap);
+
+		CERROR("%s: nodemap not found: rc = %d\n",
+		       (char *)m->private, rc);
+		return rc;
+	}
+
+	seq_printf(m, "%d\n", nodemap->nm_client_limit);
+	nodemap_putref(nodemap);
+	return 0;
+}
+
+/**
+ * nodemap_client_count_seq_show() - Read/print current client count for nodemap
+ * @m: seq file in proc fs
+ * @data: unused
+ *
+ * Return:
+ * * %0 on success
+ * * %negative error code on failure
+ */
+static int nodemap_client_count_seq_show(struct seq_file *m, void *data)
+{
+	struct lu_nodemap *nodemap;
+
+	mutex_lock(&active_config_lock);
+	nodemap = nodemap_lookup(m->private);
+	mutex_unlock(&active_config_lock);
+	if (IS_ERR(nodemap)) {
+		int rc = PTR_ERR(nodemap);
+
+		CERROR("%s: nodemap not found: rc = %d\n",
+		       (char *)m->private, rc);
+		return rc;
+	}
+
+	seq_printf(m, "%d\n", atomic_read(&nodemap->nm_client_count));
+	nodemap_putref(nodemap);
+	return 0;
+}
+
 /**
  * nodemap_trusted_seq_show() - Read/print trusted flag for the given nodemap.
  * @m: seq file in proc fs
@@ -1172,6 +1230,8 @@ LDEBUGFS_SEQ_FOPS_RO(nodemap_admin);
 LDEBUGFS_SEQ_FOPS_RO(nodemap_squash_uid);
 LDEBUGFS_SEQ_FOPS_RO(nodemap_squash_gid);
 LDEBUGFS_SEQ_FOPS_RO(nodemap_squash_projid);
+LDEBUGFS_SEQ_FOPS_RO(nodemap_client_limit);
+LDEBUGFS_SEQ_FOPS_RO(nodemap_client_count);
 
 LDEBUGFS_SEQ_FOPS_RO(nodemap_deny_unknown);
 LDEBUGFS_SEQ_FOPS_RO(nodemap_map_mode);
@@ -1223,6 +1283,14 @@ static struct ldebugfs_vars lprocfs_nodemap_vars[] = {
 		.name		= "audit_mode",
 		.fops		= &nodemap_audit_mode_fops,
 	},
+	{
+		.name		= "client_count",
+		.fops		= &nodemap_client_count_fops,
+	},
+	{
+		.name		= "client_limit",
+		.fops		= &nodemap_client_limit_fops,
+	},
 	{
 		.name		= "deny_unknown",
 		.fops		= &nodemap_deny_unknown_fops,
@@ -1322,6 +1390,14 @@ static struct ldebugfs_vars lprocfs_default_nodemap_vars[] = {
 		.name		= "audit_mode",
 		.fops		= &nodemap_audit_mode_fops,
 	},
+	{
+		.name		= "client_count",
+		.fops		= &nodemap_client_count_fops,
+	},
+	{
+		.name		= "client_limit",
+		.fops		= &nodemap_client_limit_fops,
+	},
 	{
 		.name		= "deny_unknown",
 		.fops		= &nodemap_deny_unknown_fops,
diff --git a/lustre/ptlrpc/nodemap_member.c b/lustre/ptlrpc/nodemap_member.c
index 824a544c9d..9518a1a4b3 100644
--- a/lustre/ptlrpc/nodemap_member.c
+++ b/lustre/ptlrpc/nodemap_member.c
@@ -28,6 +28,8 @@
  */
 void nm_member_del(struct lu_nodemap *nodemap, struct obd_export *exp)
 {
+	bool is_server;
+
 	ENTRY;
 
 	/* because all changes to ted_nodemap are with active_config_lock */
@@ -40,6 +42,16 @@ void nm_member_del(struct lu_nodemap *nodemap, struct obd_export *exp)
 	exp->exp_target_data.ted_nodemap = NULL;
 	spin_unlock(&exp->exp_target_data.ted_nodemap_lock);
 
+	/*
+	 * Decrement client count for non-server connections.
+	 * Server connections (MDS, MDS-MDS, LWP) should not be counted in
+	 * client limits.
+	 */
+	is_server = is_server_connection(&exp->exp_connect_data);
+
+	if (!is_server && atomic_read(&nodemap->nm_client_count) > 0)
+		atomic_dec(&nodemap->nm_client_count);
+
 	/* ref formerly held by ted_nodemap */
 	nodemap_putref(nodemap);
 
@@ -116,6 +128,15 @@ int nm_member_add(struct lu_nodemap *nodemap, struct obd_export *exp)
 	spin_unlock(&exp->exp_target_data.ted_nodemap_lock);
 	list_add(&exp->exp_target_data.ted_nodemap_member,
 		 &nodemap->nm_member_list);
+
+	/*
+	 * Increment client count for non-server connections.
+	 * Server connections (MDS, MDS-MDS, LWP) should not be counted in
+	 * client limits.
+	 */
+	if (!is_server_connection(&exp->exp_connect_data))
+		atomic_inc(&nodemap->nm_client_count);
+
 	mutex_unlock(&nodemap->nm_member_list_lock);
 
 	RETURN(0);
diff --git a/lustre/tests/sanity.sh b/lustre/tests/sanity.sh
index 3aa8797305..9466edfb3a 100755
--- a/lustre/tests/sanity.sh
+++ b/lustre/tests/sanity.sh
@@ -35121,6 +35121,110 @@ test_820() {
 }
 run_test 820 "update max EA from open intent"
 
+#LU-19054 adding client connection limits
+test_821() {
+	[ $PARALLEL == "yes" ] && skip "skip parallel run"
+
+	local mdt_param_limit="mdt.$FSNAME-MDT0000.client_limit"
+	local mdt_param_count="mdt.$FSNAME-MDT0000.client_count"
+	local old_limit
+	local baseline_count
+	local current_count
+
+	old_limit=$(do_facet mds1 $LCTL get_param -n $mdt_param_limit)
+	stack_trap "do_facet mds1 $LCTL set_param $mdt_param_limit=$old_limit" EXIT
+
+	echo "Current client_limit: $old_limit"
+
+	# Get baseline client count (may be 0 if test client isn't counted yet)
+	baseline_count=$(do_facet mds1 $LCTL get_param -n $mdt_param_count)
+	echo "Baseline client_count: $baseline_count"
+
+	# Mount a test client to establish a known baseline
+	local mount1=$TMP/mnt_lustre_821a_$$
+	mkdir -p $mount1
+	stack_trap "rmdir $mount1" EXIT
+
+	mount -t lustre $MGSNID:/$FSNAME $mount1 ||
+		error "Failed to mount test client"
+	stack_trap "umount $mount1" EXIT
+
+	# Verify client count increased
+	current_count=$(do_facet mds1 $LCTL get_param -n $mdt_param_count)
+	echo "Client_count after mount: $current_count"
+	(( $current_count == $baseline_count + 1 )) ||
+		error "client_count should be $((baseline_count + 1)), got $current_count"
+
+	# Set client_limit to current_count (at capacity)
+	echo "Setting client_limit to $current_count (at capacity)"
+	do_facet mds1 $LCTL set_param $mdt_param_limit=$current_count
+
+	# Try to mount another client - should fail
+	local mount2=$TMP/mnt_lustre_821b_$$
+	mkdir -p $mount2
+	stack_trap "rmdir $mount2" EXIT
+
+	# This should fail with EUSERS since we're at capacity
+	! mount -t lustre $MGSNID:/$FSNAME $mount2 2>&1 |
+		tee $TMP/mount_821b.log
+
+	do_facet mds1 "dmesg | grep -q 'Refusing connection.*client_limit'" ||
+		error "Expected 'client_limit' error message in server kernel log"
+
+	 dmesg | grep -q "connection refused.*client_limit" ||
+		error "Expected client-side 'client_limit' error message in dmesg"
+
+	# Verify client count didn't increase
+	local new_count=$(do_facet mds1 $LCTL get_param -n $mdt_param_count)
+	(( $new_count == $current_count )) ||
+		error "client_count changed: was $current_count, now $new_count"
+
+	# Increase limit by 1, mount should succeed
+	echo "Increasing client_limit to $((current_count + 1))"
+	do_facet mds1 $LCTL set_param $mdt_param_limit=$((current_count + 1))
+
+	mount -t lustre $MGSNID:/$FSNAME $mount2 ||
+		error "Failed to mount with increased limit"
+	stack_trap "umount $mount2" EXIT
+
+	# Verify client count increased
+	new_count=$(do_facet mds1 $LCTL get_param -n $mdt_param_count)
+	(( $new_count == $((current_count + 1)) )) ||
+		error "client_count should be $((current_count + 1)), got $new_count"
+
+	# Try to exceed limit again
+	echo "Trying to exceed limit (should fail)"
+	local mount3=$TMP/mnt_lustre_821c_$$
+	mkdir -p $mount3
+	stack_trap "rmdir $mount3" EXIT
+
+	! mount -t lustre $MGSNID:/$FSNAME $mount3 2>&1 |
+		tee $TMP/mount_821c.log
+
+	do_facet mds1 "dmesg | grep -q 'Refusing connection.*client_limit'" ||
+		error "Expected 'client_limit' error message on second overflow"
+
+	# Unmount mount2 and verify counter decrements
+	echo "Unmounting mount2 and checking counter decrement"
+	umount $mount2
+	sleep 2  # Give time for export cleanup
+
+	new_count=$(do_facet mds1 $LCTL get_param -n $mdt_param_count)
+	(( $new_count == $current_count )) ||
+		error "after umount, client_count should be $current_count, got $new_count"
+
+	# Set client_limit to -1 (unlimited)
+	echo "Setting client_limit to -1 (unlimited)"
+	do_facet mds1 $LCTL set_param $mdt_param_limit=-1
+
+	# Should now be able to mount without limit check
+	mount -t lustre $MGSNID:/$FSNAME $mount2 ||
+		error "Failed to mount with unlimited client_limit"
+
+	rm -f $TMP/mount_821b.log $TMP/mount_821c.log
+}
+run_test 821 "test client_limit connection limit enforcement"
+
 test_823() {
 	local p="$TMP/$TESTSUITE-$TESTNAME.parameters"
 	local OST_MAX_PRECREATE=20000

</pre>
</body>
</html>
